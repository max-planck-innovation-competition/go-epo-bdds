package docdb

import "encoding/xml"

// Yesorno
// added by Seb
type Yesorno string

// Code generated by xgen. DO NOT EDIT.

// Exchangedocument ...
type Exchangedocument struct {
	// XMLName                    xml.Name               `xml:"exchange-document"`
	CorrectioncodeAttr         string                 `xml:"correction-code,attr,omitempty"`
	CountryAttr                string                 `xml:"country,attr"`
	DateproducedAttr           int                    `xml:"date-produced,attr,omitempty"`
	DateaddeddocdbAttr         int                    `xml:"date-added-docdb,attr,omitempty"`
	DateofpreviousexchangeAttr int                    `xml:"date-of-previous-exchange,attr,omitempty"`
	DateoflastexchangeAttr     int                    `xml:"date-of-last-exchange,attr,omitempty"`
	DatepublAttr               int                    `xml:"date-publ,attr,omitempty"`
	DocnumberAttr              string                 `xml:"doc-number,attr,omitempty"`
	DtdversionAttr             string                 `xml:"dtd-version,attr,omitempty"`
	FileAttr                   string                 `xml:"file,attr,omitempty"`
	FilereferenceidAttr        string                 `xml:"file-reference-id,attr,omitempty"`
	IdAttr                     string                 `xml:"id,attr,omitempty"`
	FamilyidAttr               string                 `xml:"family-id,attr,omitempty"`
	DocidAttr                  string                 `xml:"doc-id,attr,omitempty"`
	IsrepresentativeAttr       string                 `xml:"is-representative,attr,omitempty"`
	KindAttr                   string                 `xml:"kind,attr,omitempty"`
	LangAttr                   string                 `xml:"lang,attr,omitempty"`
	OriginatingofficeAttr      string                 `xml:"originating-office,attr,omitempty"`
	StatusAttr                 string                 `xml:"status,attr,omitempty"`
	SystemAttr                 string                 `xml:"system,attr,omitempty"`
	ExchBibliographicdata      *BibliographicdataType `xml:"bibliographic-data"`
	ExchAbstract               []*AbstractType        `xml:"abstract"`
	ExchPatentfamily           *PatentfamilyType      `xml:"patent-family"`
	Exchangedocument           string                 `xml:"exchange-document"`
}

// SearchreportdataType ...
type SearchreportdataType struct {
	XMLName                xml.Name                `xml:"search-report-data"`
	IdAttr                 string                  `xml:"id,attr,omitempty"`
	LangAttr               string                  `xml:"lang,attr,omitempty"`
	SrepofficeAttr         string                  `xml:"srep-office,attr"`
	DateproducedAttr       string                  `xml:"date-produced,attr"`
	SreptypeAttr           string                  `xml:"srep-type,attr,omitempty"`
	StatusAttr             string                  `xml:"status,attr,omitempty"`
	Docpage                []*DocpageType          `xml:"doc-page"`
	ExchSrepinfo           *SrepinfoType           `xml:"srep-info"`
	ExchSrepforpub         *SrepforpubType         `xml:"srep-for-pub"`
	ExchSrepwrittenopinion *SrepwrittenopinionType `xml:"srep-written-opinion"`
}

// Searchreportdata is Attributes :
//   - id="srep"
//   - lang="en" or "fr" or "de"
//   - srep-office = CC (=search authority
//   - date-produced = date finished by the examiner
//   - srep-type="CC-sr" or "isr" or "CC-suppl" etc
type Searchreportdata *SearchreportdataType

// PrioritydateType ...
type PrioritydateType struct {
	XMLName           xml.Name `xml:"priority-date"`
	PriorityvalidAttr string   `xml:"priority-valid,attr,omitempty"`
	Value             string   `xml:",chardata"`
}

// Prioritydate is Rule 70.10: Any published application ... shall be accompanied by ...
//
//	its claimed priority date (if any).
//	In respect of the priority date of any such document, the report may indicate
//	that, in the opinion of the International Preliminary Examining Authority,
//	such date has not been validly claimed.
type Prioritydate *PrioritydateType

// ComplianceunityinventionType ...
type ComplianceunityinventionType struct {
	XMLName           xml.Name `xml:"compliance-unity-invention"`
	UnitycompliedAttr string   `xml:"unity-complied,attr"`
	P                 []*PType `xml:"p"`
}

// Complianceunityinvention is (PCT/ISA/237 ) - Box No. IV Lack of unity of invention
//
//	(3) This Authority considers that the requirement of unity of invention in
//	accordance with Rule 13.1, 13.2 and 13.3 is
//
//	complied with
//	not complied with for the following reasons
type Complianceunityinvention *ComplianceunityinventionType

// InvitationpayadditionalfeesType ...
type InvitationpayadditionalfeesType struct {
	XMLName          xml.Name `xml:"invitation-pay-additional-fees"`
	UnityfeecodeAttr *IntType `xml:"unity-fee-code,attr"`
}

// Invitationpayadditionalfees is In response to the invitation (Form PCT/ISA/206) to pay additional fees the
//
//	applicant has:
//
//	Attribute values:
//
//	(PCT/ISA/237 )
//	1 = paid additional fees
//	2 = paid additional fees under protest
//	3 = not paid additional fees
//	4 = not used
//
//	(PCT/IPEA/409 and PCT/IPEA/408 )
//	1 = restricted the claims
//	2 = paid additional fees
//	3 = paid additional fees under protest
//	4 = neither restricted nor paid additional fees
type Invitationpayadditionalfees *InvitationpayadditionalfeesType

// SequencelistingcomputerreadableformType ...
type SequencelistingcomputerreadableformType struct {
	XMLName          xml.Name `xml:"sequence-listing-computer-readable-form"`
	NotcompliantAttr string   `xml:"not-compliant,attr"`
}

// Sequencelistingcomputerreadableform is The computer readable form
//
//	has not been furnished
//	does not comply with the standard
type Sequencelistingcomputerreadableform *SequencelistingcomputerreadableformType

// SequencelistingwrittenformType ...
type SequencelistingwrittenformType struct {
	XMLName          xml.Name `xml:"sequence-listing-written-form"`
	NotcompliantAttr string   `xml:"not-compliant,attr"`
}

// Sequencelistingwrittenform is The written form
//
//	has not been furnished
//	does not comply with the standard
type Sequencelistingwrittenform *SequencelistingwrittenformType

// PriorityopinionType ...
type PriorityopinionType struct {
	XMLName        xml.Name            `xml:"priority-opinion"`
	VaridAttr      string              `xml:"varid,attr,omitempty"`
	Earlierappl    *EarlierapplType    `xml:"earlier-appl"`
	Claiminvalid   *ClaiminvalidType   `xml:"claim-invalid"`
	Additionalinfo *AdditionalinfoType `xml:"additional-info"`
}

// Priorityopinion is (PCT/ISA/237 - Box II) - Priority
type Priorityopinion *PriorityopinionType

// EarlierapplType ...
type EarlierapplType struct {
	XMLName      xml.Name `xml:"earlier-appl"`
	PriocodeAttr *IntType `xml:"prio-code,attr"`
}

// Earlierappl is (PCT/ISA/237 - Box II)
//
//	Priority
//
//	1. The following document has not yet been furnished:
//
//	Attribute value:
//	1 = copy of the earlier application whose priority has been claimed
//	(Rules 43bis.1 and 66.7(a)).
//
//	2 = translation of the earlier application whose priority has been claimed
//	(Rules 43bis.1 and 66.7(b)).
//
//	Consequently it has not been possible to consider the validity of the priority
//	claim. This opinion has nevertheless been established on the assumption that the
//	relevant date is the claimed priority date.
type Earlierappl *EarlierapplType

// TranslationofapplType ...
type TranslationofapplType struct {
	XMLName  xml.Name `xml:"translation-of-appl"`
	LangAttr string   `xml:"lang,attr"`
}

// Translationofappl is 1. With regard to the language, this opinion has been established on the basis of
//
//	the international application in the language in which it was filed, unless
//	otherwise indicated under this item.
//
//	This opinion has been established on the basis of a translation from the original
//	language into the following language________________ , which is the language of
//	a translation furnished for the purposes of international search
//	(under Rules 12.3 and 23.1(b)).
type Translationofappl *TranslationofapplType

// SreppatentfamilyType ...
type SreppatentfamilyType struct {
	XMLName              xml.Name                 `xml:"srep-patent-family"`
	IdAttr               string                   `xml:"id,attr,omitempty"`
	Priorityapplication  *PriorityapplicationType `xml:"priority-application"`
	ExchSrepfamilymember []*SrepfamilymemberType  `xml:"srep-family-member"`
	Text                 *TextType                `xml:"text"`
}

// Sreppatentfamily is Patent family member.
//
//	(ST.32:B345)
type Sreppatentfamily *SreppatentfamilyType

// SrepinfoType ...
type SrepinfoType struct {
	XMLName                  xml.Name                    `xml:"srep-info"`
	TotalpagecountAttr       string                      `xml:"total-page-count,attr,omitempty"`
	Docpage                  []*DocpageType              `xml:"doc-page"`
	Correspondenceaddress    *CorrespondenceaddressType  `xml:"correspondence-address"`
	Filereferenceid          *FilereferenceidType        `xml:"file-reference-id"`
	ExchApplicationreference []*ApplicationreferenceType `xml:"application-reference"`
	Dateofearliestpriority   *DateofearliestpriorityType `xml:"date-of-earliest-priority"`
	Applicantname            *ApplicantnameType          `xml:"applicant-name"`
	Srepestablished          *SrepestablishedType        `xml:"srep-established"`
	Srepprotestfees          *SrepprotestfeesType        `xml:"srep-protest-fees"`
	Sreprequestdate          *SreprequestdateType        `xml:"srep-request-date"`
	Sreprequestnumber        *SreprequestnumberType      `xml:"srep-request-number"`
	Sreppriorartdocs         []*SreppriorartdocsType     `xml:"srep-prior-art-docs"`
	Srepbasis                *SrepbasisType              `xml:"srep-basis"`
	Srepclaimsinfo           *SrepclaimsinfoType         `xml:"srep-claims-info"`
	ExchSrepunityofinvention *SrepunityofinventionType   `xml:"srep-unity-of-invention"`
	ExchSrepinventiontitle   *SrepinventiontitleType     `xml:"srep-invention-title"`
	Srepabstract             *SrepabstractType           `xml:"srep-abstract"`
	Srepfiguretopublish      *SrepfiguretopublishType    `xml:"srep-figure-to-publish"`
	Srepinfoadmin            *SrepinfoadminType          `xml:"srep-info-admin"`
	Srepotherinfo            *SrepotherinfoType          `xml:"srep-other-info"`
	Text                     []*TextType                 `xml:"text"`
}

// SrepabstractType ...
type SrepabstractType struct {
	XMLName         xml.Name      `xml:"srep-abstract"`
	AbsapprovalAttr string        `xml:"abs-approval,attr,omitempty"`
	Abstract        *AbstractType `xml:"abstract"`
}

// SrepinventiontitleType ...
type SrepinventiontitleType struct {
	XMLName            xml.Name            `xml:"srep-invention-title"`
	TitleapprovalAttr  string              `xml:"title-approval,attr,omitempty"`
	ExchInventiontitle *InventiontitleType `xml:"invention-title"`
}

// SrepinformationType ...
type SrepinformationType struct {
	XMLName      xml.Name `xml:"srep-information"`
	SrepcodeAttr string   `xml:"srep-code,attr,omitempty"`
	Value        string   `xml:",chardata"`
}

// Srepinformation ...
type Srepinformation *SrepinformationType

// ElectronicsignatureType ...
type ElectronicsignatureType struct {
	XMLName           xml.Name               `xml:"electronic-signature"`
	DateAttr          int                    `xml:"date,attr"`
	PlacesignedAttr   string                 `xml:"place-signed,attr,omitempty"`
	Basicsignature    *BasicsignatureType    `xml:"basic-signature"`
	Enhancedsignature *EnhancedsignatureType `xml:"enhanced-signature"`
}

// Electronicsignature is ***
//
//	A signature represented by electronic means
type Electronicsignature *ElectronicsignatureType

// FaximageType ...
type FaximageType struct {
	XMLName  xml.Name `xml:"fax-image"`
	FileAttr string   `xml:"file,attr"`
}

// Faximage is A TIFF image of a signature
type Faximage *FaximageType

// SrepfiguretopublishType ...
type SrepfiguretopublishType struct {
	XMLName         xml.Name             `xml:"srep-figure-to-publish"`
	FiginfoAttr     string               `xml:"figinfo,attr,omitempty"`
	Figuretopublish *FiguretopublishType `xml:"figure-to-publish"`
}

// Srepfiguretopublish is Attribute "figinfo" might in other sources be represented as
//
//	1 = as suggested by the applicant
//	2 = because the applicant failed to suggest a figure
//	3 = because this figure better characterizes the invention
//	4 = none of the figures is to be published with the abstract
//
//	Enumerated values will map to these as follows:
//	1 = "chosen-by-applicant"
//	2 = "chosen-by-office"
//	3 = "changed-by-office"
//	4 = "none"
type Srepfiguretopublish *SrepfiguretopublishType

// SearchfeeprotestType ...
type SearchfeeprotestType struct {
	XMLName     xml.Name `xml:"search-fee-protest"`
	ProtestAttr string   `xml:"protest,attr,omitempty"`
}

// Searchfeeprotest is Remark on protest
//
//	Attribute values:
//	no = No protest accompanied the payment of additional search fees
//	yes = The additional search fees were accompanied by the applicant's protest.
type Searchfeeprotest *SearchfeeprotestType

// SequencelistingfilingtimeType ...
type SequencelistingfilingtimeType struct {
	XMLName          xml.Name `xml:"sequence-listing-filing-time"`
	TimeoffilingAttr string   `xml:"time-of-filing,attr,omitempty"`
	Value            string   `xml:",chardata"`
}

// Sequencelistingfilingtime is c. time of filing/furnishing
type Sequencelistingfilingtime *SequencelistingfilingtimeType

// SequencelistingmaterialformatType ...
type SequencelistingmaterialformatType struct {
	XMLName            xml.Name `xml:"sequence-listing-material-format"`
	MaterialformatAttr string   `xml:"material-format,attr,omitempty"`
}

// Sequencelistingmaterialformat is b. format of material
type Sequencelistingmaterialformat *SequencelistingmaterialformatType

// SequencelistingmaterialtypeType ...
type SequencelistingmaterialtypeType struct {
	XMLName          xml.Name `xml:"sequence-listing-material-type"`
	MaterialtypeAttr string   `xml:"material-type,attr,omitempty"`
}

// Sequencelistingmaterialtype is a. type of material
type Sequencelistingmaterialtype *SequencelistingmaterialtypeType

// BasislanguageforsearchType ...
type BasislanguageforsearchType struct {
	XMLName         xml.Name `xml:"basis-language-for-search"`
	TranslationAttr string   `xml:"translation,attr,omitempty"`
}

// Basislanguageforsearch is +++++++++++++++++++++++++++++++++++++++
//
//	PCT ISR
//	PCT/ISA/210
//	Box 1: Basis of the Report
//	a. With regard to the language, the international search was carried out on the
//	basis of the international application in the language in which it was field,
//	unless otherwise indicated under this item.
//
//	attribute value = "no":
//
//	The international search was carried out on the basis of a translation of the
//	international application furnished to this Authority (Rule 23.1(b)).
//	+++++++++++++++++++++++++++++++++++++++
//	EPO
type Basislanguageforsearch *BasislanguageforsearchType

// SreppriorartdocsType ...
type SreppriorartdocsType struct {
	XMLName        xml.Name              `xml:"srep-prior-art-docs"`
	PriorartAttr   string                `xml:"prior-art,attr"`
	Docpage        []*DocpageType        `xml:"doc-page"`
	Priorartxmldoc []*PriorartxmldocType `xml:"prior-art-xml-doc"`
}

// Sreppriorartdocs is This part preceded by - on old PCT/ISA/210 :
//
//	This international search report has been prepared by this ISA and is transmitted
//	to the applicant according to Article 18.
//	A copy is being transmitted to the International Bureau.
//
//	This international search report consists of a total of ______ sheets.
//	It is also accompanied by a copy of each prior art document cited in this report.
//	(This text will need modification for electronic transmission of the SR).
//
//	If the attribute value is "yes" then the prior art may accompany the SR as paper,
//	image data, or xml (application-body) data
//	+++++++++++++++++++++++++++++++++++++++
type Sreppriorartdocs *SreppriorartdocsType

// PriorartxmldocType ...
type PriorartxmldocType struct {
	XMLName      xml.Name `xml:"prior-art-xml-doc"`
	IdAttr       string   `xml:"id,attr,omitempty"`
	FileAttr     string   `xml:"file,attr"`
	LangAttr     string   `xml:"lang,attr,omitempty"`
	CarriersAttr string   `xml:"carriers,attr,omitempty"`
	StatusAttr   string   `xml:"status,attr,omitempty"`
}

// Priorartxmldoc is XML version prior art document, if any
//
//	To be checked may be application-body.
//	+++++++++++++++++++++++++++++++++++++++
type Priorartxmldoc *PriorartxmldocType

// SrepprotestfeesType ...
type SrepprotestfeesType struct {
	XMLName         xml.Name `xml:"srep-protest-fees"`
	SrepprotestAttr string   `xml:"srep-protest,attr,omitempty"`
}

// Srepprotestfees is +++++++++++++++++++++++++++++++++++++++
//
//	PCT ISR
//	Form PCT/ISA/220 (January 2004)
//	Old form check box 3
//	+++++++++++++++++++++++++++++++++++++++
//	srep-protest-fees:
//	With regard to the protest against payment of (an) additional fee(s)
//	under Rule 40.2, the applicant is notified that:
//
//	if yes:
//	the protest together with the decision thereon has been transmitted to the
//	International Bureau together with the applicant s request to forward the texts
//	of both the protest and the decision thereon to the designated Offices.
//
//	if no:
//	no decision has been made yet on the protest; the applicant will be notified
//	as soon as a decision is made.
//	-
//	Sytlesheet note: this data is followed by Reminders and Notes (if printed)
//	otherwise put a link in to the relevant text.
//	+++++++++++++++++++++++++++++++++++++++
type Srepprotestfees *SrepprotestfeesType

// SrepestablishedType ...
type SrepestablishedType struct {
	XMLName             xml.Name `xml:"srep-established"`
	SrepestablishedAttr string   `xml:"srep-established,attr,omitempty"`
}

// Srepestablished is *******************************************************************************
//
//	END OF EP SR
//
//	The following elements (to maths section) are for PCT (ISR) use only and
//	are kept in if EPO use this DTD to process ISR data.
//	*******************************************************************************
//	+++++++++++++++++++++++++++++++++++++++
//	PCT ISR
//	Form PCT/ISA/220 (January 2004)
//	Old form check boxes 1 and 2
//	+++++++++++++++++++++++++++++++++++++++
//
//	srep-established:
//
//	If yes:
//	The applicant is hereby notified that the international search report and the
//	written opinion of the International Searching Authority have been established
//	and are transmitted herewith.
//
//	Filing of amendments and statement under Article 19:
//	The applicant is entitled, if he so wishes, to amend the claims of the
//	international application (see Rule 46):
//	When? The time limit for filing such amendments is normally two months from the
//	date of transmittal of the international search report.
//	Where? Directly to the International Bureau of WIPO, 34 chemin des Colombettes
//	1211 Geneva 20, Switzerland, Facsimile No.: +41 22 740 14 35
//
//	if no:
//	The applicant is hereby notified that no international search report will be
//	established and that the declaration under Article 17(2)(a) to that effect and
//	the written opinion of the International Searching Authority are transmitted
//	herewith.
//	+++++++++++++++++++++++++++++++++++++++
type Srepestablished *SrepestablishedType

// BibliographicdataType is IFD tag = 132; ST.30 tag = 151
type BibliographicdataType struct {
	// XMLName                       xml.Name                      `xml:"bibliographic-data"`
	IdAttr                        string                        `xml:"id,attr,omitempty"`
	LangAttr                      string                        `xml:"lang,attr,omitempty"`
	CountryAttr                   string                        `xml:"country,attr,omitempty"`
	StatusAttr                    string                        `xml:"status,attr,omitempty"`
	ExchPublicationreference      []*PublicationreferenceType   `xml:"publication-reference"`
	ExchPreviouslyfiledapp        *PreviouslyfiledappType       `xml:"previously-filed-app"`
	ExchPrecedingpublicationdate  *PrecedingpublicationdateType `xml:"preceding-publication-date"`
	ExchDateofcomingintoforce     *DateofcomingintoforceType    `xml:"date-of-coming-into-force"`
	ExchExtendedkindcode          *Extendedkindcode             `xml:"extended-kind-code"`
	ExchClassificationipc         *ClassificationipcType        `xml:"classification-ipc"`
	ExchClassificationsipcr       *ClassificationsipcrType      `xml:"classifications-ipcr"`
	ExchClassificationnational    *ClassificationnationalType   `xml:"classification-national"`
	ExchPatentclassifications     *PatentclassificationsType    `xml:"patent-classifications"`
	ExchApplicationreference      []*ApplicationreferenceType   `xml:"application-reference"`
	ExchLanguageoffiling          *LanguageoffilingType         `xml:"language-of-filing"`
	ExchLanguageofpublication     *LanguageofpublicationType    `xml:"language-of-publication"`
	ExchPriorityclaims            *PriorityclaimsType           `xml:"priority-claims"`
	ExchParties                   *PartiesType                  `xml:"parties"`
	ExchDesignationofstates       *DesignationofstatesType      `xml:"designation-of-states"`
	ExchInventiontitle            []*InventiontitleType         `xml:"invention-title"`
	ExchDatesofpublicavailability *Datesofpublicavailability    `xml:"dates-of-public-availability"`
	ExchSt50republication         *St50republicationType        `xml:"st50-republication"`
	ExchReferencescited           *ReferencescitedType          `xml:"references-cited"`
}

// Bibliographicdata is Bibliographic data covers all information printed on the first page, excluding abstracts.
type Bibliographicdata *BibliographicdataType

// St50republicationType ...
type St50republicationType struct {
	XMLName              xml.Name                `xml:"st50-republication"`
	StatusAttr           string                  `xml:"status,attr,omitempty"`
	Typeofcorrection     *TypeofcorrectionType   `xml:"type-of-correction"`
	Republicationcode    *RepublicationcodeType  `xml:"republication-code"`
	Cancellationdate     *CancellationdateType   `xml:"cancellation-date"`
	Modifications        *ModificationsType      `xml:"modifications"`
	Republicationnotes   *RepublicationnotesType `xml:"republication-notes"`
	ExchCorrectionnotice *CorrectionnoticeType   `xml:"correction-notice"`
}

// St50republication ...
type St50republication *St50republicationType

// RepublicationnoteType ...
type RepublicationnoteType struct {
	XMLName      xml.Name `xml:"republication-note"`
	SequenceAttr string   `xml:"sequence,attr,omitempty"`
	LangAttr     string   `xml:"lang,attr,omitempty"`
	Value        string   `xml:",chardata"`
}

// Republicationnote ...
type Republicationnote *RepublicationnoteType

// ModifiedpartType ...
type ModifiedpartType struct {
	XMLName          xml.Name              `xml:"modified-part"`
	SequenceAttr     string                `xml:"sequence,attr,omitempty"`
	LangAttr         string                `xml:"lang,attr,omitempty"`
	Modifiedpartname *ModifiedpartnameType `xml:"modified-part-name"`
	Modifieditem     []*ModifieditemType   `xml:"modified-item"`
}

// Modifiedpart is Part of the document other than bibliography affected by the correction information (ST.32 : B155EP)
type Modifiedpart *ModifiedpartType

// ModifieditemType ...
type ModifieditemType struct {
	XMLName      xml.Name `xml:"modified-item"`
	SequenceAttr string   `xml:"sequence,attr,omitempty"`
	Value        string   `xml:",chardata"`
}

// Modifieditem ...
type Modifieditem *ModifieditemType

// InidcodeType ...
type InidcodeType struct {
	XMLName      xml.Name `xml:"inid-code"`
	SequenceAttr string   `xml:"sequence,attr,omitempty"`
	Value        string   `xml:",chardata"`
}

// Inidcode is INID-codes affected by the correction information (ST.32 : B153)
type Inidcode *InidcodeType

// ReferencescitedType ...
type ReferencescitedType struct {
	XMLName      xml.Name        `xml:"references-cited"`
	StatusAttr   string          `xml:"status,attr,omitempty"`
	Text         *TextType       `xml:"text"`
	ExchCitation []*CitationType `xml:"citation"`
}

// Referencescited is Origin of the citation is indicated as follows
//
//	SEA Originates from the Search report
//	APP Cited by the Applicant
//	EXA Revealed during the Examination phase
//	OPP Revealed during the Opposition phase
//	115 Article 115 (Observation by third parties)
//	OTH Other documents of interest (cited in compte rendu but not in search report)
//	CH2 cited during PCT chapter II (preliminary examination)
//	Attribute "sequence" indicates the sequence within "srep-phase"
//	Sequence will restart with every new "srep-phase"
//	Patent citations are exchanged in "patcit", as a patent document-id
//	NPL citations are exchanged in "nplcit", as a string of freetext with embedded reference to patent
//	document or NPL
//	Patent document-ids and NPL reference numbers embedded in the NPL citation are extracted and exchanged
//	in "corresponding-docs"
//	Categories are exchanged in "category" in a concatenated string, one occurrence of "category" per
//	citation
type Referencescited *ReferencescitedType

// CitationType ...
type CitationType struct {
	XMLName               xml.Name                 `xml:"citation"`
	IdAttr                string                   `xml:"id,attr,omitempty"`
	CitedphaseAttr        string                   `xml:"cited-phase,attr,omitempty"`
	NameAttr              string                   `xml:"name,attr,omitempty"`
	CiteddateAttr         int                      `xml:"cited-date,attr,omitempty"`
	CitedbyAttr           string                   `xml:"cited-by,attr,omitempty"`
	SrepofficeAttr        string                   `xml:"srep-office,attr,omitempty"`
	SequenceAttr          string                   `xml:"sequence,attr,omitempty"`
	Patcit                *PatcitType              `xml:"patcit"`
	Nplcit                *NplcitType              `xml:"nplcit"`
	Relpassage            []*RelpassageType        `xml:"rel-passage"`
	Category              []*CategoryType          `xml:"category"`
	Relclaims             []*RelclaimsType         `xml:"rel-claims"`
	ExchCorrespondingdocs []*CorrespondingdocsType `xml:"corresponding-docs"`
}

// Citation is *******************************
//
//	CITATIONS
//	*******************************
//	Grouping tag for patent literature (patcit) or non-patent literature (nplcit) plus data related to those
//	citations.
type Citation *CitationType

// PriorityclaimType ...
type PriorityclaimType struct {
	XMLName                     xml.Name                  `xml:"priority-claim"`
	IdAttr                      string                    `xml:"id,attr,omitempty"`
	DataformatAttr              string                    `xml:"data-format,attr,omitempty"`
	StatusAttr                  string                    `xml:"status,attr,omitempty"`
	SequenceAttr                string                    `xml:"sequence,attr,omitempty"`
	Documentid                  *DocumentidType           `xml:"document-id"`
	Officeoffiling              *OfficeoffilingType       `xml:"office-of-filing"`
	Prioritydocrequested        *PrioritydocrequestedType `xml:"priority-doc-requested"`
	Prioritydocattached         *PrioritydocattachedType  `xml:"priority-doc-attached"`
	ExchPrioritylinkagetype     string                    `xml:"priority-linkage-type"`
	ExchPriorityactiveindicator string                    `xml:"priority-active-indicator"`
}

// Priorityclaim is Priority-claim, IFD tags :
//
//	080 = country;
//	090 = doc-number;
//	180 = kind-code (generated from kind in combination with linkage-type);
//	100= date;
//	Priority-claim,ST.30 tags :
//	330 = country;
//	310 = doc-number;
//	A31 = kind-code;
//	320 = date;
//	Notes on Contents :
//	When data-format = "original", ONLY the priority-number
//	DOCDB keeps record of very early publications; where possible these are grouped into families; in these
//	instances :
//	doc-number = suffixed by letter 'T';
//	date = all zeroes;
//	priority-linkage-type = 'T';
//	DOCDB has reformatted PCT applications for reasons of standardisation, in these instances :
//	country = country of filing;
//	doc-number = numerical string, preceded by year indication;
//	kind = 'W';
//	Linkage type and active indicator serve EPO internal business needs :
//	priority-linkage-type = 1 byte indication of priority relation, eg. '1' = "for continuation";
//	priority-active-indicate = Y or N included in the priority picture that defines EPO simple patent
//	family;
//	Attributes used :
//	sequence = sequence as printed on the published document;
//	data-format = "docdb" - standardised following the DOCDB standardisation rules - then exchange of a full
//	set of reference;
//	data-format= "epodoc" - format as represented in espacenet, concatenated in "doc-number";
//	data-format = "original" - as supplied by the provider - then exchange of "doc-number" only;
//	NOTE THAT "sequence" restarts with every change of "data-format"
//	priority claims in different formats but with identical sequence numbers cannot be guaranteed to be
//	representations of one and the same entity
type Priorityclaim *PriorityclaimType

// AgentType ...
type AgentType struct {
	XMLName      xml.Name           `xml:"agent"`
	SequenceAttr string             `xml:"sequence,attr"`
	ReptypeAttr  string             `xml:"rep-type,attr"`
	Addressbook  []*AddressbookType `xml:"addressbook"`
}

// Agent is Agent or common representative (Rules 90.1, 90.2)
type Agent *AgentType

// DeceasedinventorType ...
type DeceasedinventorType struct {
	XMLName          xml.Name          `xml:"deceased-inventor"`
	SequenceAttr     string            `xml:"sequence,attr"`
	LangAttr         string            `xml:"lang,attr,omitempty"`
	DataformatAttr   string            `xml:"data-format,attr,omitempty"`
	ExchInventorname *InventornameType `xml:"inventor-name"`
}

// Deceasedinventor is Deceased inventor name
type Deceasedinventor *DeceasedinventorType

// InventorType ...
type InventorType struct {
	XMLName          xml.Name              `xml:"inventor"`
	SequenceAttr     string                `xml:"sequence,attr,omitempty"`
	DesignationAttr  string                `xml:"designation,attr,omitempty"`
	DataformatAttr   string                `xml:"data-format,attr,omitempty"`
	StatusAttr       string                `xml:"status,attr,omitempty"`
	ExchInventorname []*InventornameType   `xml:"inventor-name"`
	Address          *AddressType          `xml:"address"`
	Residence        *ResidenceType        `xml:"residence"`
	Designatedstates *DesignatedstatesType `xml:"designated-states"`
}

// InventornameType ...
type InventornameType struct {
	XMLName        xml.Name `xml:"inventor-name"`
	LangAttr       string   `xml:"lang,attr,omitempty"`
	DataformatAttr string   `xml:"data-format,attr,omitempty"`
	ExchNameGroup  *NameGroup
}

// Inventorname is Inventor name (without address information)
type Inventorname *InventornameType

// ApplicantType ...
type ApplicantType struct {
	XMLName                    xml.Name                        `xml:"applicant"`
	SequenceAttr               string                          `xml:"sequence,attr,omitempty"`
	ApptypeAttr                string                          `xml:"app-type,attr,omitempty"`
	DesignationAttr            string                          `xml:"designation,attr,omitempty"`
	DataformatAttr             string                          `xml:"data-format,attr,omitempty"`
	StatusAttr                 string                          `xml:"status,attr,omitempty"`
	ExchApplicantname          []*ApplicantnameType            `xml:"applicant-name"`
	Address                    *AddressType                    `xml:"address"`
	Nationality                *NationalityType                `xml:"nationality"`
	Residence                  *ResidenceType                  `xml:"residence"`
	Usrights                   []*UsrightsType                 `xml:"us-rights"`
	Designatedstates           *DesignatedstatesType           `xml:"designated-states"`
	Designatedstatesasinventor *DesignatedstatesasinventorType `xml:"designated-states-as-inventor"`
}

// Applicant is DOCDB only keeps a record of applicant-name and country of residence; address is only available
//
//	sporadically
//	address is included in applicant data-format="docdba"
//	country of residence in applicant data-format="docdb"
//	Attributes used on "applicant" level
//	sequence = sequence as printed on the published document;
//	NOTE THAT "sequence" restarts with every change of "data-format"
//	applicants in different format but with identical sequence numbers cannot be guaranteed to be
//	representations of one and the same
//	Attributes used on "applicant-name" level
//	data-format = "docdb", standardised following DOCDB primary standardisation rules;
//	data-format = "docdba", standardised following DOCDB secondary rules (translation upper-case);
//	data-format = "original", as supplied by the provider, converted to UTF8;
//	IFD tags, applicant :
//	121 = name "docdb";
//	120 = name "docdba";
//	973 = name "original";
//	123 = address;
//	122 = residence;
//	ST.30 tags, applicant :
//	710 = name;
//	714 = country of residence;
type Applicant *ApplicantType

// UsrightsType ...
type UsrightsType struct {
	XMLName            xml.Name `xml:"us-rights"`
	TodeadinventorAttr string   `xml:"to-dead-inventor,attr"`
	KindAttr           string   `xml:"kind,attr"`
	Value              string   `xml:",chardata"`
}

// Usrights is ***
//
//	This person is successor to the rights of an inventor who is deceased, insane, or
//	legally incapacitated, for the purposes of the designation of the United States
//	of America
type Usrights *UsrightsType

// ApplicantnameType ...
type ApplicantnameType struct {
	XMLName        xml.Name `xml:"applicant-name"`
	LangAttr       string   `xml:"lang,attr,omitempty"`
	DataformatAttr string   `xml:"data-format,attr,omitempty"`
	Name           *NameType
}

// Applicantname is The name of the applicant (without address information)
type Applicantname *ApplicantnameType

// InventiontitleType ...
type InventiontitleType struct {
	XMLName        xml.Name   `xml:"invention-title"`
	IdAttr         string     `xml:"id,attr,omitempty"`
	LangAttr       string     `xml:"lang,attr,omitempty"`
	DataformatAttr string     `xml:"data-format,attr,omitempty"`
	StatusAttr     string     `xml:"status,attr,omitempty"`
	B              []*BType   `xml:"b"`
	I              []*IType   `xml:"i"`
	U              []*UType   `xml:"u"`
	Sup            []*SupType `xml:"sup"`
	Sub            []*SubType `xml:"sub"`
}

// Inventiontitle is Invention title, text embedded in tag itself,
//
//	Invention title, IFD tags :
//	130 = data-format "docdb";
//	954 = data-format "original";
//	131 = language;
//	Invention title, ST.30 tags :
//	541 = title;
//	540 = language;
//	Attributes used :
//	lang=language-code, when natural language;
//	data-format="docdb", when natural language;
//	data-format="original", when original language character set, converted to UTF8;
type Inventiontitle *InventiontitleType

// Extendedkindcode ...
type Extendedkindcode struct {
	XMLName    xml.Name `xml:"extended-kind-code"`
	StatusAttr string   `xml:"status,attr,omitempty"`
	Value      string   `xml:",chardata"`
}

// DesignationofstatesType ...
type DesignationofstatesType struct {
	XMLName                           xml.Name                               `xml:"designation-of-states"`
	StatusAttr                        string                                 `xml:"status,attr,omitempty"`
	ExchDesignationpct                *DesignationpctType                    `xml:"designation-pct"`
	ExchDesignationepc                *DesignationepcType                    `xml:"designation-epc"`
	ExchContractingstates             *ContractingstatesType                 `xml:"contracting-states"`
	Precautionarydesignationstatement *PrecautionarydesignationstatementType `xml:"precautionary-designation-statement"`
	ExchExclusionfromdesignation      *ExclusionfromdesignationType          `xml:"exclusion-from-designation"`
}

// Designationofstates is Desigation PCT, IFD tags :
//
//	081 = designated country;
//	082 = designated country for a regional patent;
//	Designation EPC, IFD tags :
//	081 = contracting-states;
//	083 = extension-states;
//	Designation other authorities, e.g. ARIPO, OAPI
//	081 = contracting states;
//	Designation of states not exchanged in ST.30;
type Designationofstates *DesignationofstatesType

// Datesofpublicavailability ...
type Datesofpublicavailability struct {
	XMLName                              xml.Name                              `xml:"dates-of-public-availability"`
	StatusAttr                           string                                `xml:"status,attr,omitempty"`
	ExchGazettereference                 *ExchangegazettereferenceType         `xml:"gazette-reference"`
	ExchAbstractreference                *AbstractreferenceType                `xml:"abstract-reference"`
	ExchSupplementalsreppub              *Supplementalsreppub                  `xml:"supplemental-srep-pub"`
	ExchGazettepubannouncement           *Gazettepubannouncement               `xml:"gazette-pub-announcement"`
	ExchModifiedfirstpagepub             *ModifiedfirstpagepubType             `xml:"modified-first-page-pub"`
	ExchModifiedcompletespecpub          *ModifiedcompletespecpubType          `xml:"modified-complete-spec-pub"`
	ExchUnexaminednotprintedwithoutgrant *UnexaminednotprintedwithoutgrantType `xml:"unexamined-not-printed-without-grant"`
	ExchExaminednotprintedwithoutgrant   *ExaminednotprintedwithoutgrantType   `xml:"examined-not-printed-without-grant"`
	ExchUnexaminedprintedwithoutgrant    *UnexaminedprintedwithoutgrantType    `xml:"unexamined-printed-without-grant"`
	ExchExaminedprintedwithoutgrant      *ExaminedprintedwithoutgrantType      `xml:"examined-printed-without-grant"`
	ExchPrintedwithgrant                 *PrintedwithgrantType                 `xml:"printed-with-grant"`
	ExchClaimsonlyavailable              *ClaimsonlyavailableType              `xml:"claims-only-available"`
	ExchNotprintedwithgrant              *NotprintedwithgrantType              `xml:"not-printed-with-grant"`
	Termofgrant                          *TermofgrantType                      `xml:"term-of-grant"`
	ExchInvalidationofpatent             *InvalidationofpatentType             `xml:"invalidation-of-patent"`
	ExchPrintedasamended                 *PrintedasamendedType                 `xml:"printed-as-amended"`
}

// PrintedwithgrantType ...
type PrintedwithgrantType struct {
	XMLName    xml.Name             `xml:"printed-with-grant"`
	LangAttr   string               `xml:"lang,attr,omitempty"`
	Documentid *DocumentidPrintType `xml:"document-id"`
	Text       *TextType            `xml:"text"`
}

// Printedwithgrant is Date of publication by printing or similar process of a document, on which grant has taken place on or
//
//	before the said date.
//	(INID 45, ST.32:B450)
type Printedwithgrant *PrintedwithgrantType

// AbstractreferenceType ...
type AbstractreferenceType struct {
	XMLName    xml.Name             `xml:"abstract-reference"`
	LangAttr   string               `xml:"lang,attr,omitempty"`
	Documentid *DocumentidPrintType `xml:"document-id"`
	Text       *TextType            `xml:"text"`
}

// ModifiedcompletespecpubType ...
type ModifiedcompletespecpubType struct {
	XMLName    xml.Name             `xml:"modified-complete-spec-pub"`
	LangAttr   string               `xml:"lang,attr,omitempty"`
	Documentid *DocumentidPrintType `xml:"document-id"`
	Text       *TextType            `xml:"text"`
}

// ModifiedfirstpagepubType ...
type ModifiedfirstpagepubType struct {
	XMLName    xml.Name             `xml:"modified-first-page-pub"`
	LangAttr   string               `xml:"lang,attr,omitempty"`
	Documentid *DocumentidPrintType `xml:"document-id"`
	Text       *TextType            `xml:"text"`
}

// NotprintedwithgrantType ...
type NotprintedwithgrantType struct {
	XMLName    xml.Name             `xml:"not-printed-with-grant"`
	LangAttr   string               `xml:"lang,attr,omitempty"`
	Documentid *DocumentidPrintType `xml:"document-id"`
	Text       *TextType            `xml:"text"`
}

// Notprintedwithgrant is Not printed document with grant
//
//	(INID 47, ST.32:B470)
type Notprintedwithgrant *NotprintedwithgrantType

// ClaimsonlyavailableType ...
type ClaimsonlyavailableType struct {
	XMLName    xml.Name             `xml:"claims-only-available"`
	LangAttr   string               `xml:"lang,attr,omitempty"`
	Documentid *DocumentidPrintType `xml:"document-id"`
	Text       *TextType            `xml:"text"`
}

// Claimsonlyavailable is Document claims only available. (INID 46, ST.32 B460)
type Claimsonlyavailable *ClaimsonlyavailableType

// ExaminedprintedwithoutgrantType ...
type ExaminedprintedwithoutgrantType struct {
	XMLName    xml.Name             `xml:"examined-printed-without-grant"`
	LangAttr   string               `xml:"lang,attr,omitempty"`
	Documentid *DocumentidPrintType `xml:"document-id"`
	Text       *TextType            `xml:"text"`
}

// Examinedprintedwithoutgrant is Examined, printed document without grant.
//
//	(INID 44, ST.32:B440)
type Examinedprintedwithoutgrant *ExaminedprintedwithoutgrantType

// UnexaminedprintedwithoutgrantType ...
type UnexaminedprintedwithoutgrantType struct {
	XMLName    xml.Name             `xml:"unexamined-printed-without-grant"`
	LangAttr   string               `xml:"lang,attr,omitempty"`
	Documentid *DocumentidPrintType `xml:"document-id"`
	Text       *TextType            `xml:"text"`
}

// Unexaminedprintedwithoutgrant is Unexamined, printed document without grant.
//
//	(INID 43, ST.32:B430)
type Unexaminedprintedwithoutgrant *UnexaminedprintedwithoutgrantType

// ExaminednotprintedwithoutgrantType ...
type ExaminednotprintedwithoutgrantType struct {
	XMLName    xml.Name             `xml:"examined-not-printed-without-grant"`
	LangAttr   string               `xml:"lang,attr,omitempty"`
	Documentid *DocumentidPrintType `xml:"document-id"`
	Text       *TextType            `xml:"text"`
}

// Examinednotprintedwithoutgrant is Examined, not printed document without grant.
//
//	(INID 42, ST.32:B420)
type Examinednotprintedwithoutgrant *ExaminednotprintedwithoutgrantType

// UnexaminednotprintedwithoutgrantType ...
type UnexaminednotprintedwithoutgrantType struct {
	XMLName    xml.Name             `xml:"unexamined-not-printed-without-grant"`
	LangAttr   string               `xml:"lang,attr,omitempty"`
	Documentid *DocumentidPrintType `xml:"document-id"`
	Text       *TextType            `xml:"text"`
}

// Unexaminednotprintedwithoutgrant is Unexamined, not printed document without grant.
//
//	(INID 41, ST.32:B410)
type Unexaminednotprintedwithoutgrant *UnexaminednotprintedwithoutgrantType

// ExchangegazettereferenceType ...
type ExchangegazettereferenceType struct {
	XMLName     xml.Name        `xml:"gazette-reference"`
	IdAttr      string          `xml:"id,attr,omitempty"`
	CountryAttr string          `xml:"country,attr,omitempty"`
	LangAttr    string          `xml:"lang,attr,omitempty"`
	Gazettenum  *GazettenumType `xml:"gazette-num"`
	Date        int             `xml:"date"`
	Text        *TextType       `xml:"text"`
}

// Gazettereference is Information about an office's gazette or bulletin - paper, electronic, etc.
//
//	where, the details of the patent publication are also given.
//	Examples WIPO gazette and EPO Bulletin The date is mandatory.
//	(ST.32:B405)
type Gazettereference *ExchangegazettereferenceType

// PatentclassificationsType ...
type PatentclassificationsType struct {
	XMLName              xml.Name                    `xml:"patent-classifications"`
	IDAttr               string                      `xml:"ID,attr,omitempty"`
	Patentclassification []*PatentclassificationType `xml:"patent-classification"`
	Combinationset       []*CombinationsetType       `xml:"combination-set"`
}

// Patentclassifications is This sequence will contain at least one of patent-classification or one of combination-set
//
//	patent-classifications - e.g. CPC, CPCNO, FI, FTERM, DOCUS
//	combination-sets - e.g. patent-classifications in sequence
type Patentclassifications *PatentclassificationsType

// CombinationsetType ...
type CombinationsetType struct {
	XMLName         xml.Name               `xml:"combination-set"`
	IDAttr          string                 `xml:"ID,attr,omitempty"`
	StatusAttr      string                 `xml:"status,attr,omitempty"`
	SequenceAttr    string                 `xml:"sequence,attr"`
	Groupnumber     string                 `xml:"group-number"`
	Combinationrank []*CombinationrankType `xml:"combination-rank"`
}

// Combinationset ...
type Combinationset *CombinationsetType

// Classificationscheme ...
type Classificationscheme struct {
	XMLName    xml.Name `xml:"classification-scheme"`
	OfficeAttr string   `xml:"office,attr"`
	SchemeAttr string   `xml:"scheme,attr"`
	Edition    string   `xml:"edition"`
	Date       string   `xml:"date"`
}

// Class ...
type Class struct {
	XMLName       xml.Name `xml:"class"`
	ClasstypeAttr string   `xml:"class-type,attr,omitempty"`
}

// Actiondate ...
type Actiondate struct {
	XMLName xml.Name `xml:"action-date"`
	Date    string   `xml:"date"`
}

// PatentclassificationType ...
type PatentclassificationType struct {
	XMLName                  xml.Name              `xml:"patent-classification"`
	IDAttr                   string                `xml:"ID,attr,omitempty"`
	StatusAttr               string                `xml:"status,attr,omitempty"`
	SequenceAttr             string                `xml:"sequence,attr,omitempty"`
	Classificationscheme     *Classificationscheme `xml:"classification-scheme"`
	Classificationsymbol     string                `xml:"classification-symbol"`
	Section                  string                `xml:"section"`
	Class                    *ClassType            `xml:"class"`
	Subclass                 string                `xml:"subclass"`
	Maingroup                string                `xml:"main-group"`
	Subgroup                 string                `xml:"subgroup"`
	Classificationlevel      string                `xml:"classification-level"`
	Symbolposition           string                `xml:"symbol-position"`
	Classificationvalue      string                `xml:"classification-value"`
	Classificationstatus     string                `xml:"classification-status"`
	Classificationdatasource string                `xml:"classification-data-source"`
	Generatingoffice         string                `xml:"generating-office"`
	Actiondate               *ActiondateType       `xml:"action-date"`
}

// Patentclassification is Notes on Contents
//
//	scheme = EC office = EP - from A through H
//	scheme = ICO office = EP - from K through Z
//	scheme = IDT office = EP "indeling der techniek"
//	scheme = ECNO office = cc
//	scheme = DOCUS office = US
//	scheme = FI office = JP
//	scheme = FTERM office = JP
//	From Jan/2013 onwards
//	schemes EC, ICO, IDT, ECNO discontinued
//	schemes CPC and CPCNO introduced
type Patentclassification *PatentclassificationType

// ClassificationipcType ...
type ClassificationipcType struct {
	XMLName                 xml.Name                       `xml:"classification-ipc"`
	IdAttr                  string                         `xml:"id,attr,omitempty"`
	StatusAttr              string                         `xml:"status,attr,omitempty"`
	Edition                 *EditionType                   `xml:"edition"`
	Mainclassification      []*MainclassificationType      `xml:"main-classification"`
	Furtherclassification   []*FurtherclassificationType   `xml:"further-classification"`
	Additionalinfo          []*AdditionalinfoType          `xml:"additional-info"`
	Linkedindexingcodegroup []*LinkedindexingcodegroupType `xml:"linked-indexing-code-group"`
	Unlinkedindexingcode    []*UnlinkedindexingcodeType    `xml:"unlinked-indexing-code"`
	Text                    []*TextType                    `xml:"text"`
}

// Classificationipc is IFD tag = 070
//
//	ST.30 tags are :
//	511 = main-classification;
//	512 = further-classification;
//	513 = additonal info;
//	514 = linked-indexing-code-group;
//	515 = unlinked-indexing-code;
//	510 = text;
//	Notes on Contents
//	when qualified by 'A' : main-classification;
//	when qualified by 'B' : further-classification;
//	when qualified by '-' : additional-info;
//	when qualified by 'J' through 'Y' : linked-indexing-code-group;
//	when qualified by 'Z' : unlinked-indexing-code;
//	when qualified by none of the above : text;
//	edition is generally included in the symbol;
type Classificationipc *ClassificationipcType

// ApplicationreferenceType ...
type ApplicationreferenceType struct {
	XMLName              xml.Name        `xml:"application-reference"`
	IdAttr               string          `xml:"id,attr,omitempty"`
	DocidAttr            string          `xml:"doc-id,attr,omitempty"`
	AppltypeAttr         string          `xml:"appl-type,attr,omitempty"`
	IsrepresentativeAttr string          `xml:"is-representative,attr,omitempty"`
	DataformatAttr       string          `xml:"data-format,attr,omitempty"`
	StatusAttr           string          `xml:"status,attr,omitempty"`
	Documentid           *DocumentidType `xml:"document-id"`
}

// Applicationreference is NOTE - these annotations have no bearance on"application-reference" unless referred to INSIDE element
//
//	"bibliographic-data"
//
//	Application-reference, IFD tags :
//	040 = doc-number;
//	070 = kind-code;
//	050 = date
//	country is not included as separate entity;
//	Application-reference,ST.30 tags :
//	A21 = country;
//	210 = doc-number;
//	221 = kind-code;
//	220 = date;
//	Notes on Contents :
//	Defined "repeatable" to be able to cater for multiple formats;
//	when data-format = "original", application-reference will contain ONLY the application-number
//	DOCDB keeps record of very early publications; in these instances
//	doc-number = suffixed by letter 'D';
//	date = all zeroes;
//	DOCDB contains "exotic" kind-codes introduced for internal EPO business purposes, in these instances
//	kind = 'D', 'K', 'L', 'M', 'N', 'Q';
//	DOCDB has reformatted PCT applications for reasons of standardisation, in these instances :
//	country = country of filing;
//	doc-number = numerical string, preceded by year indication;
//	kind = 'W';
//	Attributes used :
//	data-format = "docdb" - standardised following DOCDB standardisation rules - then exchange of a full set
//	of reference;
//	data-format= "epodoc" - format as represented in espacenet; concatenated in "doc-number"
//	data-format = "original" - as supplied by the provider - then exchange of "doc-number" only;
//	is-representative, identifies whether this application is the family representative in the EPO simple
//	patent family
type Applicationreference *ApplicationreferenceType

// PreviouslyfiledappType ...
type PreviouslyfiledappType struct {
	XMLName    xml.Name `xml:"previously-filed-app"`
	StatusAttr string   `xml:"status,attr,omitempty"`
	Value      string   `xml:",chardata"`
}

// Previouslyfiledapp ...
type Previouslyfiledapp *PreviouslyfiledappType

// DateofcomingintoforceType ...
type DateofcomingintoforceType struct {
	XMLName    xml.Name `xml:"date-of-coming-into-force"`
	StatusAttr string   `xml:"status,attr,omitempty"`
	Date       int      `xml:"date"`
}

// Dateofcomingintoforce is Date of coming into force of DE utility model = "Eintragungstag"
//
//	IFD tag = 151; not in ST.30
type Dateofcomingintoforce *DateofcomingintoforceType

// PrecedingpublicationdateType ...
type PrecedingpublicationdateType struct {
	XMLName    xml.Name `xml:"preceding-publication-date"`
	StatusAttr string   `xml:"status,attr,omitempty"`
	Date       int      `xml:"date"`
}

// Precedingpublicationdate is IFD tag = 150; not in ST.30
type Precedingpublicationdate *PrecedingpublicationdateType

// LanguageofpublicationType ...
type LanguageofpublicationType struct {
	XMLName    xml.Name `xml:"language-of-publication"`
	StatusAttr string   `xml:"status,attr,omitempty"`
	Value      string   `xml:",chardata"`
}

// Languageofpublication is Publication language, ISO639 language code, e.g, en,de,ja, etc.
//
//	(INID 26, ST.32:B260)
type Languageofpublication *LanguageofpublicationType

// LanguageoffilingType ...
type LanguageoffilingType struct {
	XMLName    xml.Name `xml:"language-of-filing"`
	StatusAttr string   `xml:"status,attr,omitempty"`
	Value      string   `xml:",chardata"`
}

// Languageoffiling is Filing language, ISO639 language code, e.g, en,de,ja, etc.
//
//	(INID 25, ST.32:B250)
type Languageoffiling *LanguageoffilingType

// ClassificationnationalType ...
type ClassificationnationalType struct {
	XMLName                 xml.Name                       `xml:"classification-national"`
	IdAttr                  string                         `xml:"id,attr,omitempty"`
	StatusAttr              string                         `xml:"status,attr,omitempty"`
	Country                 string                         `xml:"country"`
	Edition                 *EditionType                   `xml:"edition"`
	Mainclassification      []*MainclassificationType      `xml:"main-classification"`
	Furtherclassification   []*FurtherclassificationType   `xml:"further-classification"`
	Additionalinfo          []*AdditionalinfoType          `xml:"additional-info"`
	Linkedindexingcodegroup []*LinkedindexingcodegroupType `xml:"linked-indexing-code-group"`
	Unlinkedindexingcode    []*UnlinkedindexingcodeType    `xml:"unlinked-indexing-code"`
	Text                    []*TextType                    `xml:"text"`
}

// Classificationnational is Domestic or national classification.
//
//	IFD tag = 071; ST.30 not available
type Classificationnational *ClassificationnationalType

// FurtherclassificationType ...
type FurtherclassificationType struct {
	XMLName      xml.Name `xml:"further-classification"`
	IdAttr       string   `xml:"id,attr,omitempty"`
	SequenceAttr string   `xml:"sequence,attr,omitempty"`
	Value        string   `xml:",chardata"`
}

// Furtherclassification is Further/secondary classification ST.32 equivalency = B512/B522
type Furtherclassification *FurtherclassificationType

// ClassificationsipcrType ...
type ClassificationsipcrType struct {
	XMLName            xml.Name                  `xml:"classifications-ipcr"`
	IdAttr             string                    `xml:"id,attr,omitempty"`
	StatusAttr         string                    `xml:"status,attr,omitempty"`
	DataformatAttr     string                    `xml:"data-format,attr,omitempty"`
	Classificationipcr []*ClassificationipcrType `xml:"classification-ipcr"`
}

// Classificationsipcr is ***********
//
//	Classification IPCR - NEW IPCR8
//	(INID 53, ST.32:B530)
type Classificationsipcr *ClassificationsipcrType

// ClassificationipcrType ...
type ClassificationipcrType struct {
	XMLName                  xml.Name                      `xml:"classification-ipcr"`
	IdAttr                   string                        `xml:"id,attr,omitempty"`
	SequenceAttr             string                        `xml:"sequence,attr,omitempty"`
	Ipcversionindicator      *IpcversionindicatorType      `xml:"ipc-version-indicator"`
	Classificationlevel      *ClassificationlevelType      `xml:"classification-level"`
	Section                  *SectionType                  `xml:"section"`
	Class                    *ClassType                    `xml:"class"`
	Subclass                 *SubclassType                 `xml:"subclass"`
	Maingroup                *MaingroupType                `xml:"main-group"`
	Subgroup                 *SubgroupType                 `xml:"subgroup"`
	Symbolposition           *SymbolpositionType           `xml:"symbol-position"`
	Classificationvalue      *ClassificationvalueType      `xml:"classification-value"`
	Actiondate               *ActiondateType               `xml:"action-date"`
	Generatingoffice         *GeneratingofficeType         `xml:"generating-office"`
	Classificationstatus     *ClassificationstatusType     `xml:"classification-status"`
	Classificationdatasource *ClassificationdatasourceType `xml:"classification-data-source"`
	Text                     *TextType                     `xml:"text"`
}

// Classificationipcr is *******************************
//
//   - IPC DATA - NEW IPC8
//     *******************************
//     International Patent Classification (IPC) data;
//
//   - to be implemented in 2006
//
//   - use B510 for until week 52, 2005
//
//   - see: http://www.wipo.int/scit/en/standards/pdf/03-08-01.pdf:
//
//     Industrial property offices are asked to implement this new version of Standard ST.8 for all patent
//     documents with a publication date from January 1, 2006, onwards. For patent documents published prior to
//     that date, the previous version of the Standard should continue to be used.
//     . . .
//     This recording convention provides that symbols of the International Patent Classification (IPC) should
//     be
//     presented on machine-readable records for the exchange of information in machine-readable form in a
//     fixed-length field in 50 positions, each part of the Int. Cl. symbol being recorded in specific
//     positions and in the manner prescribed.
//
//   - this can be recorded within the <text> tag.
//
//     Position(s) Content Values
//
//     1 Section A-H
//     23 Class 01-99
//     4 Subclass A-Z
//     5 to 8 Main Group (right aligned) 1-9999, blank
//     9 Separating character / ("Slash")
//     10 to 15 Subgroup (left aligned) 00-999999 blank
//     16 to 19 For future use 4 blanks
//     20 to 27 Version indicator YYYYMMDD date format
//     28 Classification level C, A, S
//     29 First or later position of symbol F, L
//     30 Classification value (inventive or non-inventive) I, N
//     31 to 38 Action date YYYYMMDD date format
//     39 Original or reclassified data BRVD
//     40 Source of classification data H M G
//     41-42 Generating office AA ZZ (ST.3)
//     43-50 For future use 8 blanks
type Classificationipcr *ClassificationipcrType

// PublicationreferenceType ...
type PublicationreferenceType struct {
	XMLName        xml.Name        `xml:"publication-reference"`
	IdAttr         string          `xml:"id,attr,omitempty"`
	DocidAttr      string          `xml:"doc-id,attr,omitempty"`
	DataformatAttr string          `xml:"data-format,attr,omitempty"`
	StatusAttr     string          `xml:"status,attr,omitempty"`
	SequenceAttr   string          `xml:"sequence,attr,omitempty"`
	Documentid     *DocumentidType `xml:"document-id"`
}

// Publicationreference is Publication-reference, IFD tags
//
//	010 = country
//	030 = doc-number
//	020 = kind
//	060 = date
//	Publication-reference, ST.30 tags
//	190 = country
//	110 = doc-number
//	221 = kind
//	A40 = date
//	Notes on Contents :
//	Defined "repeatable"
//	to be able to cater for multiple formats in the future, e.g. data-format="docdb" and
//	data-format="epodoc".
//	DOCDB keeps record of very early publications, in those instances
//	date = all zeroes
//	DOCDB exchanges "withdrawn" publications, in those instances
//	date = not supplied
//	DE utility models: publication-date = "Bekanntmachunstag"
//	"Modifications of full specification/first page", eg. A8
//	multiple publication stages per publication-id possible
//	extending key with publication-date provides unique and unambiguous reference
//	Attributes used
//	data-format="docdb", standardised following DOCDB prime standardisation rules
//	Provisions for future use :
//	defined "repeatable" to be able to exchange more than one representation, eg.
//	data-format="epodoc" etc.
type Publicationreference *PublicationreferenceType

// AbstractType ...
type AbstractType struct {
	XMLName            xml.Name          `xml:"abstract"`
	IdAttr             string            `xml:"id,attr,omitempty"`
	LangAttr           string            `xml:"lang,attr,omitempty"`
	StatusAttr         string            `xml:"status,attr,omitempty"`
	CountryAttr        string            `xml:"country,attr,omitempty"`
	DocnumberAttr      string            `xml:"doc-number,attr,omitempty"`
	KindAttr           string            `xml:"kind,attr,omitempty"`
	DateAttr           int               `xml:"date,attr,omitempty"`
	DataformatAttr     string            `xml:"data-format,attr,omitempty"`
	AbstractsourceAttr string            `xml:"abstract-source,attr,omitempty"`
	Docpage            []*DocpageType    `xml:"doc-page"`
	Abstproblem        *AbstproblemType  `xml:"abst-problem"`
	Abstsolution       *AbstsolutionType `xml:"abst-solution"`
	ExchP              []*ExchpType      `xml:"p"`
}

// Abstract is Abstract, text embedded in "p";
//
//	Notes on contents :
//	publication may have more than one abstract
//	multiple formats :
//	"docdb" - natural language abstract, eg. EN, FR etc.
//	"original" - original language character set, converted to UTF8
//	multiple sources :
//	"national office"
//	"transcript" - English transcript of non-English abstract
//	"translation" - English translation of non-English abstract
//	"EPO" - abstract in DE, FR, or EN as provided with EP publication
//	"PAJ" - Patent Abstract of Japan, in English language
//	Abstract, IFD tags; not in ST.30 :
//	136 = data-format "docdb";
//	137 = data-format "original";
//	Attributes used :
//	lang=abstract language (only supplied with data-format "docdb")
//	country=publication country
//	doc-number=publication number
//	kind=publication kind-code
//	date=publication-date
//	data-format="docdb" or "original"
//	abstract-source=one of the above listed sources
type Abstract *AbstractType

// AbstsolutionType ...
type AbstsolutionType struct {
	XMLName xml.Name `xml:"abst-solution"`
	IdAttr  string   `xml:"id,attr,omitempty"`
	P       []*PType `xml:"p"`
}

// AbstproblemType ...
type AbstproblemType struct {
	XMLName xml.Name `xml:"abst-problem"`
	IdAttr  string   `xml:"id,attr,omitempty"`
	P       []*PType `xml:"p"`
}

// ExchpType ...
type ExchpType struct {
	XMLName          xml.Name                `xml:"p"`
	IdAttr           string                  `xml:"id,attr,omitempty"`
	NumAttr          string                  `xml:"num,attr,omitempty"`
	O                []*OType                `xml:"o"`
	B                []*BType                `xml:"b"`
	I                []*IType                `xml:"i"`
	U                []*UType                `xml:"u"`
	Sup              []*SupType              `xml:"sup"`
	Sub              []*SubType              `xml:"sub"`
	Smallcaps        []*SmallcapsType        `xml:"smallcaps"`
	Br               []*BrType               `xml:"br"`
	Pre              []*PreType              `xml:"pre"`
	Dl               []*DlType               `xml:"dl"`
	Ul               []*UlType               `xml:"ul"`
	Ol               []*OlType               `xml:"ol"`
	Crossref         []*CrossrefType         `xml:"crossref"`
	Figref           []*FigrefType           `xml:"figref"`
	Patcit           []*PatcitType           `xml:"patcit"`
	Nplcit           []*NplcitType           `xml:"nplcit"`
	Biodeposit       []*BiodepositType       `xml:"bio-deposit"`
	Img              []*ImgType              `xml:"img"`
	Chemistry        []*ChemistryType        `xml:"chemistry"`
	Maths            []*MathsType            `xml:"maths"`
	Tables           []*TablesType           `xml:"tables"`
	Tableexternaldoc []*TableexternaldocType `xml:"table-external-doc"`
	Value            string                  `xml:",chardata"`
}

// PType ...
type PType struct {
	XMLName          xml.Name                `xml:"p"`
	IdAttr           string                  `xml:"id,attr,omitempty"`
	NumAttr          string                  `xml:"num,attr"`
	B                []*BType                `xml:"b"`
	I                []*IType                `xml:"i"`
	U                []*UType                `xml:"u"`
	Sup              []*SupType              `xml:"sup"`
	Sub              []*SubType              `xml:"sub"`
	Smallcaps        []*SmallcapsType        `xml:"smallcaps"`
	Br               []*BrType               `xml:"br"`
	Pre              []*PreType              `xml:"pre"`
	Dl               []*DlType               `xml:"dl"`
	Ul               []*UlType               `xml:"ul"`
	Ol               []*OlType               `xml:"ol"`
	Crossref         []*CrossrefType         `xml:"crossref"`
	Figref           []*FigrefType           `xml:"figref"`
	Patcit           []*PatcitType           `xml:"patcit"`
	Nplcit           []*NplcitType           `xml:"nplcit"`
	Biodeposit       []*BiodepositType       `xml:"bio-deposit"`
	Img              []*ImgType              `xml:"img"`
	Chemistry        []*ChemistryType        `xml:"chemistry"`
	Maths            []*MathsType            `xml:"maths"`
	Tables           []*TablesType           `xml:"tables"`
	Tableexternaldoc []*TableexternaldocType `xml:"table-external-doc"`
	Value            string                  `xml:",chardata"`
}

// TableexternaldocType ...
type TableexternaldocType struct {
	XMLName          xml.Name `xml:"table-external-doc"`
	IdAttr           string   `xml:"id,attr,omitempty"`
	FileAttr         string   `xml:"file,attr"`
	LangAttr         string   `xml:"lang,attr,omitempty"`
	StatusAttr       string   `xml:"status,attr,omitempty"`
	DoccodeAttr      string   `xml:"doc-code,attr,omitempty"`
	DateoffilingAttr int      `xml:"date-of-filing,attr,omitempty"`
	CarriersAttr     string   `xml:"carriers,attr,omitempty"`
	ExternaltypeAttr string   `xml:"external-type,attr,omitempty"`
	Value            string   `xml:",chardata"`
}

// Tableexternaldoc is *******************************
//
//	TABLE EXTERNAL - NOT USED
//	*******************************
//	References a stand-alone table authored with the table-external DTD.
//	This is unlikely to be used by the EPO
type Tableexternaldoc *TableexternaldocType

// TablesType ...
type TablesType struct {
	XMLName xml.Name   `xml:"tables"`
	IdAttr  string     `xml:"id,attr,omitempty"`
	NumAttr string     `xml:"num,attr"`
	Img     *ImgType   `xml:"img"`
	Table   *TableType `xml:"table"`
}

// Tables is *********************************
//
//	TABLES
//	*********************************
//	This is image data or coded according to OASIS Exchange model with modified cell
//	'entry' content.
//
//	EPO required usage:
//	- id="tabl0001" etc.
//	- If parent element is abstract: id="tabla01";
//	- num="0001" etc.
//	- tables may be images or marked up. Mark up should be the default
type Tables *TablesType

// TableType ...
type TableType struct {
	XMLName      xml.Name `xml:"table"`
	ExchTableAtt *TableAtt
	FrameAttr    string        `xml:"frame,attr,omitempty"`
	ColsepAttr   *Yesorno      `xml:"colsep,attr,omitempty"`
	RowsepAttr   *Yesorno      `xml:"rowsep,attr,omitempty"`
	PgwideAttr   *Yesorno      `xml:"pgwide,attr,omitempty"`
	Title        *TitleType    `xml:"title"`
	Tgroup       []*TgroupType `xml:"tgroup"`
}

// TitleType ...
type TitleType struct {
	XMLName   xml.Name         `xml:"title"`
	B         []*BType         `xml:"b"`
	I         []*IType         `xml:"i"`
	U         []*UType         `xml:"u"`
	Sup       []*SupType       `xml:"sup"`
	Sub       []*SubType       `xml:"sub"`
	Smallcaps []*SmallcapsType `xml:"smallcaps"`
}

// TgroupType ...
type TgroupType struct {
	XMLName       xml.Name `xml:"tgroup"`
	ExchTgroupAtt *TgroupAtt
	ColsAttr      *IntType       `xml:"cols,attr"`
	ColsepAttr    *Yesorno       `xml:"colsep,attr,omitempty"`
	RowsepAttr    *Yesorno       `xml:"rowsep,attr,omitempty"`
	AlignAttr     string         `xml:"align,attr,omitempty"`
	Colspec       []*ColspecType `xml:"colspec"`
	Thead         *TheadType     `xml:"thead"`
	Tbody         *TbodyType     `xml:"tbody"`
}

// ColspecType ...
type ColspecType struct {
	XMLName        xml.Name `xml:"colspec"`
	ExchColspecAtt *ColspecAtt
	ColnumAttr     *IntType `xml:"colnum,attr,omitempty"`
	ColnameAttr    string   `xml:"colname,attr,omitempty"`
	ColwidthAttr   string   `xml:"colwidth,attr,omitempty"`
	ColsepAttr     *Yesorno `xml:"colsep,attr,omitempty"`
	RowsepAttr     *Yesorno `xml:"rowsep,attr,omitempty"`
	AlignAttr      string   `xml:"align,attr,omitempty"`
	CharAttr       string   `xml:"char,attr,omitempty"`
	CharoffAttr    string   `xml:"charoff,attr,omitempty"`
}

// TheadType ...
type TheadType struct {
	XMLName      xml.Name `xml:"thead"`
	ExchTheadAtt *TheadAtt
	ValignAttr   string     `xml:"valign,attr,omitempty"`
	Row          []*RowType `xml:"row"`
}

// TbodyType ...
type TbodyType struct {
	XMLName      xml.Name `xml:"tbody"`
	ExchTbodyAtt *TbodyAtt
	ValignAttr   string     `xml:"valign,attr,omitempty"`
	Row          []*RowType `xml:"row"`
}

// RowType ...
type RowType struct {
	XMLName    xml.Name `xml:"row"`
	ExchRowAtt *RowAtt
	RowsepAttr *Yesorno     `xml:"rowsep,attr,omitempty"`
	ValignAttr string       `xml:"valign,attr,omitempty"`
	Entry      []*EntryType `xml:"entry"`
}

// EntryType ...
type EntryType struct {
	XMLName      xml.Name `xml:"entry"`
	ExchEntryAtt *EntryAtt
	ColnameAttr  string            `xml:"colname,attr,omitempty"`
	NamestAttr   string            `xml:"namest,attr,omitempty"`
	NameendAttr  string            `xml:"nameend,attr,omitempty"`
	MorerowsAttr *IntType          `xml:"morerows,attr,omitempty"`
	ColsepAttr   *Yesorno          `xml:"colsep,attr,omitempty"`
	RowsepAttr   *Yesorno          `xml:"rowsep,attr,omitempty"`
	AlignAttr    string            `xml:"align,attr,omitempty"`
	CharAttr     string            `xml:"char,attr,omitempty"`
	CharoffAttr  string            `xml:"charoff,attr,omitempty"`
	ValignAttr   string            `xml:"valign,attr,omitempty"`
	B            []*BType          `xml:"b"`
	I            []*IType          `xml:"i"`
	U            []*UType          `xml:"u"`
	O            []*OType          `xml:"o"`
	Sup          []*SupType        `xml:"sup"`
	Sub          []*SubType        `xml:"sub"`
	Smallcaps    []*SmallcapsType  `xml:"smallcaps"`
	Br           []*BrType         `xml:"br"`
	Patcit       []*PatcitType     `xml:"patcit"`
	Nplcit       []*NplcitType     `xml:"nplcit"`
	Biodeposit   []*BiodepositType `xml:"bio-deposit"`
	Crossref     []*CrossrefType   `xml:"crossref"`
	Figref       []*FigrefType     `xml:"figref"`
	Img          []*ImgType        `xml:"img"`
	Dl           []*DlType         `xml:"dl"`
	Ul           []*UlType         `xml:"ul"`
	Ol           []*OlType         `xml:"ol"`
	Chemistry    []*ChemistryType  `xml:"chemistry"`
	Maths        []*MathsType      `xml:"maths"`
}

// Title ...
type Title *TitleType

// Tgroup ...
type Tgroup *TgroupType

// Colspec ...
type Colspec *ColspecType

// Thead ...
type Thead *TheadType

// Tbody ...
type Tbody *TbodyType

// Row ...
type Row *RowType

// Entry ...
type Entry *EntryType

// Table ...
type Table *TableType

// DlType ...
type DlType struct {
	XMLName     xml.Name `xml:"dl"`
	IdAttr      string   `xml:"id,attr,omitempty"`
	TsizeAttr   string   `xml:"tsize,attr,omitempty"`
	CompactAttr string   `xml:"compact,attr,omitempty"`
	Dt          *DtType  `xml:"dt"`
	Dd          *DdType  `xml:"dd"`
}

// Dl is *******************************
//
//	LISTS
//	*******************************
//	DEFINTION LISTS
//	*******************************
//	EPO required usage:
//	- For dl elements in the main part of the document: id="dl0001"
//	- If parent element is abstract: id="dla01" BUT contractors
//	should, if possible, not use in abstracts.
//	(It is not used in PatXML in abstracts)
//	- tsize: the "gutter" size in mm between the the dt and the dd
type Dl *DlType

// UlType ...
type UlType struct {
	XMLName       xml.Name  `xml:"ul"`
	IdAttr        string    `xml:"id,attr,omitempty"`
	ListstyleAttr string    `xml:"list-style,attr,omitempty"`
	CompactAttr   string    `xml:"compact,attr,omitempty"`
	Li            []*LiType `xml:"li"`
}

// Ul is *******************************
//
//	UNORDERED LISTS:
//	*******************************
//
//	List-style may be empty for lists with no bullet or other symbol
//	default list-style is 'bullets'.
//
//	EPO required usage:
//	- for ul element in the description: id="ul0001"
//	- If parent element is abstract: id="ula01"; BUT contractors
//	should, if possible, not use in abstracts just type in the
//	numbers as text (not used in PatXML)
//	- list-style: "none" means "none" or other type of symbol;
//	that is if the applicant used
//	some other symbol use this and then in the body of the text enter that symbol
//	- bullet and dash may be used
//	- compact
//
//
//	EPO style: indent whole list 6mm from left margin
//
//	Example:
//	<ul id="ul0001" list-style="bullet">
type Ul *UlType

// LiType ...
type LiType struct {
	XMLName    xml.Name          `xml:"li"`
	IdAttr     string            `xml:"id,attr,omitempty"`
	NumAttr    string            `xml:"num,attr,omitempty"`
	B          []*BType          `xml:"b"`
	I          []*IType          `xml:"i"`
	U          []*UType          `xml:"u"`
	O          []*OType          `xml:"o"`
	Sup        []*SupType        `xml:"sup"`
	Sub        []*SubType        `xml:"sub"`
	Smallcaps  []*SmallcapsType  `xml:"smallcaps"`
	Br         []*BrType         `xml:"br"`
	Pre        []*PreType        `xml:"pre"`
	Patcit     []*PatcitType     `xml:"patcit"`
	Nplcit     []*NplcitType     `xml:"nplcit"`
	Biodeposit []*BiodepositType `xml:"bio-deposit"`
	Crossref   []*CrossrefType   `xml:"crossref"`
	Figref     []*FigrefType     `xml:"figref"`
	Img        []*ImgType        `xml:"img"`
	Dl         []*DlType         `xml:"dl"`
	Ul         []*UlType         `xml:"ul"`
	Ol         []*OlType         `xml:"ol"`
	Chemistry  []*ChemistryType  `xml:"chemistry"`
	Maths      []*MathsType      `xml:"maths"`
}

// Li is LIST ITEM
//
//	EPO required usage:
//	- DO NOT USE ID
type Li *LiType

// MathsType ...
type MathsType struct {
	XMLName xml.Name  `xml:"maths"`
	IdAttr  string    `xml:"id,attr,omitempty"`
	NumAttr string    `xml:"num,attr"`
	Img     *ImgType  `xml:"img"`
	Math    *MathType `xml:"math"`
}

// Maths is *******************************************************************************
//
//	*******************************
//	MATHEMATICS
//	*******************************
//
//	This is image data or coded according to mathml, version 2
//
//	The top-level element "math" contains MathML encoded
//	mathematics. The "math" element has the browser info
//	attributes if it is also the browser interface element.
//
//	EPO required usage:
//	- id="math0001"
//	- If parent element is abstract: id="matha01";
//	- num 0001, 0002, etc.
type Maths *MathsType

// MathType ...
type MathType struct {
	XMLName            xml.Name `xml:"math"`
	DisplayAttr        string   `xml:"display,attr,omitempty"`
	ExchMathExpression []*MathExpression
}

// Mi ...
type Mi *MiType

// MiType ...
type MiType struct {
	XMLName            xml.Name          `xml:"mi"`
	XlinkHrefAttr      interface{}       `xml:"xlink:href,attr,omitempty"`
	XlinkTypeAttr      string            `xml:"xlink:type,attr,omitempty"`
	ClassAttr          string            `xml:"class,attr,omitempty"`
	StyleAttr          string            `xml:"style,attr,omitempty"`
	IdAttr             string            `xml:"id,attr,omitempty"`
	XrefAttr           string            `xml:"xref,attr,omitempty"`
	OtherAttr          string            `xml:"other,attr,omitempty"`
	FontsizeAttr       string            `xml:"fontsize,attr,omitempty"`
	FontweightAttr     string            `xml:"fontweight,attr,omitempty"`
	FontstyleAttr      string            `xml:"fontstyle,attr,omitempty"`
	FontfamilyAttr     string            `xml:"fontfamily,attr,omitempty"`
	ColorAttr          string            `xml:"color,attr,omitempty"`
	MathvariantAttr    string            `xml:"mathvariant,attr,omitempty"`
	MathsizeAttr       string            `xml:"mathsize,attr,omitempty"`
	MathcolorAttr      string            `xml:"mathcolor,attr,omitempty"`
	MathbackgroundAttr string            `xml:"mathbackground,attr,omitempty"`
	Mglyph             []*MglyphType     `xml:"mglyph"`
	Malignmark         []*MalignmarkType `xml:"malignmark"`
}

// Mglyph ...
type Mglyph *MglyphType

// MglyphType ...
type MglyphType struct {
	XMLName        xml.Name `xml:"mglyph"`
	AltAttr        string   `xml:"alt,attr,omitempty"`
	FontfamilyAttr string   `xml:"fontfamily,attr,omitempty"`
	IndexAttr      string   `xml:"index,attr,omitempty"`
}

// Malignmark ...
type Malignmark *MalignmarkType

// MalignmarkType ...
type MalignmarkType struct {
	XMLName  xml.Name `xml:"malignmark"`
	EdgeAttr string   `xml:"edge,attr,omitempty"`
}

// Mn ...
type Mn *MnType

// MnType ...
type MnType struct {
	XMLName            xml.Name          `xml:"mn"`
	XlinkHrefAttr      interface{}       `xml:"xlink:href,attr,omitempty"`
	XlinkTypeAttr      string            `xml:"xlink:type,attr,omitempty"`
	ClassAttr          string            `xml:"class,attr,omitempty"`
	StyleAttr          string            `xml:"style,attr,omitempty"`
	IdAttr             string            `xml:"id,attr,omitempty"`
	XrefAttr           string            `xml:"xref,attr,omitempty"`
	OtherAttr          string            `xml:"other,attr,omitempty"`
	FontsizeAttr       string            `xml:"fontsize,attr,omitempty"`
	FontweightAttr     string            `xml:"fontweight,attr,omitempty"`
	FontstyleAttr      string            `xml:"fontstyle,attr,omitempty"`
	FontfamilyAttr     string            `xml:"fontfamily,attr,omitempty"`
	ColorAttr          string            `xml:"color,attr,omitempty"`
	MathvariantAttr    string            `xml:"mathvariant,attr,omitempty"`
	MathsizeAttr       string            `xml:"mathsize,attr,omitempty"`
	MathcolorAttr      string            `xml:"mathcolor,attr,omitempty"`
	MathbackgroundAttr string            `xml:"mathbackground,attr,omitempty"`
	Mglyph             []*MglyphType     `xml:"mglyph"`
	Malignmark         []*MalignmarkType `xml:"malignmark"`
}

// Mo ...
type Mo *MoType

// MoType ...
type MoType struct {
	XMLName            xml.Name          `xml:"mo"`
	XlinkHrefAttr      interface{}       `xml:"xlink:href,attr,omitempty"`
	XlinkTypeAttr      string            `xml:"xlink:type,attr,omitempty"`
	ClassAttr          string            `xml:"class,attr,omitempty"`
	StyleAttr          string            `xml:"style,attr,omitempty"`
	IdAttr             string            `xml:"id,attr,omitempty"`
	XrefAttr           string            `xml:"xref,attr,omitempty"`
	OtherAttr          string            `xml:"other,attr,omitempty"`
	FontsizeAttr       string            `xml:"fontsize,attr,omitempty"`
	FontweightAttr     string            `xml:"fontweight,attr,omitempty"`
	FontstyleAttr      string            `xml:"fontstyle,attr,omitempty"`
	FontfamilyAttr     string            `xml:"fontfamily,attr,omitempty"`
	ColorAttr          string            `xml:"color,attr,omitempty"`
	MathvariantAttr    string            `xml:"mathvariant,attr,omitempty"`
	MathsizeAttr       string            `xml:"mathsize,attr,omitempty"`
	MathcolorAttr      string            `xml:"mathcolor,attr,omitempty"`
	MathbackgroundAttr string            `xml:"mathbackground,attr,omitempty"`
	FormAttr           string            `xml:"form,attr,omitempty"`
	FenceAttr          string            `xml:"fence,attr,omitempty"`
	SeparatorAttr      string            `xml:"separator,attr,omitempty"`
	LspaceAttr         string            `xml:"lspace,attr,omitempty"`
	RspaceAttr         string            `xml:"rspace,attr,omitempty"`
	StretchyAttr       string            `xml:"stretchy,attr,omitempty"`
	SymmetricAttr      string            `xml:"symmetric,attr,omitempty"`
	MaxsizeAttr        string            `xml:"maxsize,attr,omitempty"`
	MinsizeAttr        string            `xml:"minsize,attr,omitempty"`
	LargeopAttr        string            `xml:"largeop,attr,omitempty"`
	MovablelimitsAttr  string            `xml:"movablelimits,attr,omitempty"`
	AccentAttr         string            `xml:"accent,attr,omitempty"`
	Mglyph             []*MglyphType     `xml:"mglyph"`
	Malignmark         []*MalignmarkType `xml:"malignmark"`
}

// Mtext ...
type Mtext *MtextType

// MtextType ...
type MtextType struct {
	XMLName            xml.Name          `xml:"mtext"`
	XlinkHrefAttr      interface{}       `xml:"xlink:href,attr,omitempty"`
	XlinkTypeAttr      string            `xml:"xlink:type,attr,omitempty"`
	ClassAttr          string            `xml:"class,attr,omitempty"`
	StyleAttr          string            `xml:"style,attr,omitempty"`
	IdAttr             string            `xml:"id,attr,omitempty"`
	XrefAttr           string            `xml:"xref,attr,omitempty"`
	OtherAttr          string            `xml:"other,attr,omitempty"`
	FontsizeAttr       string            `xml:"fontsize,attr,omitempty"`
	FontweightAttr     string            `xml:"fontweight,attr,omitempty"`
	FontstyleAttr      string            `xml:"fontstyle,attr,omitempty"`
	FontfamilyAttr     string            `xml:"fontfamily,attr,omitempty"`
	ColorAttr          string            `xml:"color,attr,omitempty"`
	MathvariantAttr    string            `xml:"mathvariant,attr,omitempty"`
	MathsizeAttr       string            `xml:"mathsize,attr,omitempty"`
	MathcolorAttr      string            `xml:"mathcolor,attr,omitempty"`
	MathbackgroundAttr string            `xml:"mathbackground,attr,omitempty"`
	Mglyph             []*MglyphType     `xml:"mglyph"`
	Malignmark         []*MalignmarkType `xml:"malignmark"`
}

// Ms ...
type Ms *MsType

// MsType ...
type MsType struct {
	XMLName            xml.Name          `xml:"ms"`
	XlinkHrefAttr      interface{}       `xml:"xlink:href,attr,omitempty"`
	XlinkTypeAttr      string            `xml:"xlink:type,attr,omitempty"`
	ClassAttr          string            `xml:"class,attr,omitempty"`
	StyleAttr          string            `xml:"style,attr,omitempty"`
	IdAttr             string            `xml:"id,attr,omitempty"`
	XrefAttr           string            `xml:"xref,attr,omitempty"`
	OtherAttr          string            `xml:"other,attr,omitempty"`
	FontsizeAttr       string            `xml:"fontsize,attr,omitempty"`
	FontweightAttr     string            `xml:"fontweight,attr,omitempty"`
	FontstyleAttr      string            `xml:"fontstyle,attr,omitempty"`
	FontfamilyAttr     string            `xml:"fontfamily,attr,omitempty"`
	ColorAttr          string            `xml:"color,attr,omitempty"`
	MathvariantAttr    string            `xml:"mathvariant,attr,omitempty"`
	MathsizeAttr       string            `xml:"mathsize,attr,omitempty"`
	MathcolorAttr      string            `xml:"mathcolor,attr,omitempty"`
	MathbackgroundAttr string            `xml:"mathbackground,attr,omitempty"`
	LquoteAttr         string            `xml:"lquote,attr,omitempty"`
	RquoteAttr         string            `xml:"rquote,attr,omitempty"`
	Mglyph             []*MglyphType     `xml:"mglyph"`
	Malignmark         []*MalignmarkType `xml:"malignmark"`
}

// Mspace ...
type Mspace *MspaceType

// MspaceType ...
type MspaceType struct {
	XMLName       xml.Name    `xml:"mspace"`
	WidthAttr     string      `xml:"width,attr,omitempty"`
	HeightAttr    string      `xml:"height,attr,omitempty"`
	DepthAttr     string      `xml:"depth,attr,omitempty"`
	LinebreakAttr string      `xml:"linebreak,attr,omitempty"`
	XlinkHrefAttr interface{} `xml:"xlink:href,attr,omitempty"`
	XlinkTypeAttr string      `xml:"xlink:type,attr,omitempty"`
	ClassAttr     string      `xml:"class,attr,omitempty"`
	StyleAttr     string      `xml:"style,attr,omitempty"`
	IdAttr        string      `xml:"id,attr,omitempty"`
	XrefAttr      string      `xml:"xref,attr,omitempty"`
	OtherAttr     string      `xml:"other,attr,omitempty"`
}

// Mrow ...
type Mrow *MrowType

// MrowType ...
type MrowType struct {
	XMLName            xml.Name    `xml:"mrow"`
	XlinkHrefAttr      interface{} `xml:"xlink:href,attr,omitempty"`
	XlinkTypeAttr      string      `xml:"xlink:type,attr,omitempty"`
	ClassAttr          string      `xml:"class,attr,omitempty"`
	StyleAttr          string      `xml:"style,attr,omitempty"`
	IdAttr             string      `xml:"id,attr,omitempty"`
	XrefAttr           string      `xml:"xref,attr,omitempty"`
	OtherAttr          string      `xml:"other,attr,omitempty"`
	ExchPresExpression []*PresExpression
}

// Mprescripts ...
type Mprescripts *MprescriptsType

// MprescriptsType ...
type MprescriptsType struct {
	XMLName xml.Name `xml:"mprescripts"`
}

// None ...
type None *NoneType

// NoneType ...
type NoneType struct {
	XMLName xml.Name `xml:"none"`
}

// Mfrac ...
type Mfrac *MfracType

// MfracType ...
type MfracType struct {
	XMLName               xml.Name    `xml:"mfrac"`
	XlinkHrefAttr         interface{} `xml:"xlink:href,attr,omitempty"`
	XlinkTypeAttr         string      `xml:"xlink:type,attr,omitempty"`
	ClassAttr             string      `xml:"class,attr,omitempty"`
	StyleAttr             string      `xml:"style,attr,omitempty"`
	IdAttr                string      `xml:"id,attr,omitempty"`
	XrefAttr              string      `xml:"xref,attr,omitempty"`
	OtherAttr             string      `xml:"other,attr,omitempty"`
	BevelledAttr          string      `xml:"bevelled,attr,omitempty"`
	NumalignAttr          string      `xml:"numalign,attr,omitempty"`
	DenomalignAttr        string      `xml:"denomalign,attr,omitempty"`
	LinethicknessAttr     string      `xml:"linethickness,attr,omitempty"`
	ExchTwoPresExpression []*TwoPresExpression
}

// Msqrt ...
type Msqrt *MsqrtType

// MsqrtType ...
type MsqrtType struct {
	XMLName            xml.Name    `xml:"msqrt"`
	XlinkHrefAttr      interface{} `xml:"xlink:href,attr,omitempty"`
	XlinkTypeAttr      string      `xml:"xlink:type,attr,omitempty"`
	ClassAttr          string      `xml:"class,attr,omitempty"`
	StyleAttr          string      `xml:"style,attr,omitempty"`
	IdAttr             string      `xml:"id,attr,omitempty"`
	XrefAttr           string      `xml:"xref,attr,omitempty"`
	OtherAttr          string      `xml:"other,attr,omitempty"`
	ExchPresExpression []*PresExpression
}

// Mroot ...
type Mroot *MrootType

// MrootType ...
type MrootType struct {
	XMLName               xml.Name    `xml:"mroot"`
	XlinkHrefAttr         interface{} `xml:"xlink:href,attr,omitempty"`
	XlinkTypeAttr         string      `xml:"xlink:type,attr,omitempty"`
	ClassAttr             string      `xml:"class,attr,omitempty"`
	StyleAttr             string      `xml:"style,attr,omitempty"`
	IdAttr                string      `xml:"id,attr,omitempty"`
	XrefAttr              string      `xml:"xref,attr,omitempty"`
	OtherAttr             string      `xml:"other,attr,omitempty"`
	ExchTwoPresExpression []*TwoPresExpression
}

// Menclose ...
type Menclose *MencloseType

// MencloseType ...
type MencloseType struct {
	XMLName            xml.Name    `xml:"menclose"`
	XlinkHrefAttr      interface{} `xml:"xlink:href,attr,omitempty"`
	XlinkTypeAttr      string      `xml:"xlink:type,attr,omitempty"`
	ClassAttr          string      `xml:"class,attr,omitempty"`
	StyleAttr          string      `xml:"style,attr,omitempty"`
	IdAttr             string      `xml:"id,attr,omitempty"`
	XrefAttr           string      `xml:"xref,attr,omitempty"`
	OtherAttr          string      `xml:"other,attr,omitempty"`
	NotationAttr       string      `xml:"notation,attr,omitempty"`
	ExchPresExpression []*PresExpression
}

// Mstyle ...
type Mstyle *MstyleType

// MstyleType ...
type MstyleType struct {
	XMLName                    xml.Name    `xml:"mstyle"`
	XlinkHrefAttr              interface{} `xml:"xlink:href,attr,omitempty"`
	XlinkTypeAttr              string      `xml:"xlink:type,attr,omitempty"`
	ClassAttr                  string      `xml:"class,attr,omitempty"`
	StyleAttr                  string      `xml:"style,attr,omitempty"`
	IdAttr                     string      `xml:"id,attr,omitempty"`
	XrefAttr                   string      `xml:"xref,attr,omitempty"`
	OtherAttr                  string      `xml:"other,attr,omitempty"`
	FontsizeAttr               string      `xml:"fontsize,attr,omitempty"`
	FontweightAttr             string      `xml:"fontweight,attr,omitempty"`
	FontstyleAttr              string      `xml:"fontstyle,attr,omitempty"`
	FontfamilyAttr             string      `xml:"fontfamily,attr,omitempty"`
	ColorAttr                  string      `xml:"color,attr,omitempty"`
	MathvariantAttr            string      `xml:"mathvariant,attr,omitempty"`
	MathsizeAttr               string      `xml:"mathsize,attr,omitempty"`
	MathcolorAttr              string      `xml:"mathcolor,attr,omitempty"`
	MathbackgroundAttr         string      `xml:"mathbackground,attr,omitempty"`
	FormAttr                   string      `xml:"form,attr,omitempty"`
	FenceAttr                  string      `xml:"fence,attr,omitempty"`
	SeparatorAttr              string      `xml:"separator,attr,omitempty"`
	LspaceAttr                 string      `xml:"lspace,attr,omitempty"`
	RspaceAttr                 string      `xml:"rspace,attr,omitempty"`
	StretchyAttr               string      `xml:"stretchy,attr,omitempty"`
	SymmetricAttr              string      `xml:"symmetric,attr,omitempty"`
	MaxsizeAttr                string      `xml:"maxsize,attr,omitempty"`
	MinsizeAttr                string      `xml:"minsize,attr,omitempty"`
	LargeopAttr                string      `xml:"largeop,attr,omitempty"`
	MovablelimitsAttr          string      `xml:"movablelimits,attr,omitempty"`
	AccentAttr                 string      `xml:"accent,attr,omitempty"`
	LquoteAttr                 string      `xml:"lquote,attr,omitempty"`
	RquoteAttr                 string      `xml:"rquote,attr,omitempty"`
	LinethicknessAttr          string      `xml:"linethickness,attr,omitempty"`
	ScriptlevelAttr            string      `xml:"scriptlevel,attr,omitempty"`
	ScriptsizemultiplierAttr   string      `xml:"scriptsizemultiplier,attr,omitempty"`
	ScriptminsizeAttr          string      `xml:"scriptminsize,attr,omitempty"`
	BackgroundAttr             string      `xml:"background,attr,omitempty"`
	VeryverythinmathspaceAttr  string      `xml:"veryverythinmathspace,attr,omitempty"`
	VerythinmathspaceAttr      string      `xml:"verythinmathspace,attr,omitempty"`
	ThinmathspaceAttr          string      `xml:"thinmathspace,attr,omitempty"`
	MediummathspaceAttr        string      `xml:"mediummathspace,attr,omitempty"`
	ThickmathspaceAttr         string      `xml:"thickmathspace,attr,omitempty"`
	VerythickmathspaceAttr     string      `xml:"verythickmathspace,attr,omitempty"`
	VeryverythickmathspaceAttr string      `xml:"veryverythickmathspace,attr,omitempty"`
	OpenAttr                   string      `xml:"open,attr,omitempty"`
	CloseAttr                  string      `xml:"close,attr,omitempty"`
	SeparatorsAttr             string      `xml:"separators,attr,omitempty"`
	SubscriptshiftAttr         string      `xml:"subscriptshift,attr,omitempty"`
	SuperscriptshiftAttr       string      `xml:"superscriptshift,attr,omitempty"`
	AccentunderAttr            string      `xml:"accentunder,attr,omitempty"`
	AlignAttr                  string      `xml:"align,attr,omitempty"`
	RowalignAttr               string      `xml:"rowalign,attr,omitempty"`
	ColumnalignAttr            string      `xml:"columnalign,attr,omitempty"`
	ColumnwidthAttr            string      `xml:"columnwidth,attr,omitempty"`
	GroupalignAttr             string      `xml:"groupalign,attr,omitempty"`
	AlignmentscopeAttr         string      `xml:"alignmentscope,attr,omitempty"`
	SideAttr                   string      `xml:"side,attr,omitempty"`
	RowspacingAttr             string      `xml:"rowspacing,attr,omitempty"`
	ColumnspacingAttr          string      `xml:"columnspacing,attr,omitempty"`
	RowlinesAttr               string      `xml:"rowlines,attr,omitempty"`
	ColumnlinesAttr            string      `xml:"columnlines,attr,omitempty"`
	WidthAttr                  string      `xml:"width,attr,omitempty"`
	FrameAttr                  string      `xml:"frame,attr,omitempty"`
	FramespacingAttr           string      `xml:"framespacing,attr,omitempty"`
	MinlabelspacingAttr        string      `xml:"minlabelspacing,attr,omitempty"`
	EqualrowsAttr              string      `xml:"equalrows,attr,omitempty"`
	EqualcolumnsAttr           string      `xml:"equalcolumns,attr,omitempty"`
	DisplaystyleAttr           string      `xml:"displaystyle,attr,omitempty"`
	RowspanAttr                string      `xml:"rowspan,attr,omitempty"`
	ColumnspanAttr             string      `xml:"columnspan,attr,omitempty"`
	EdgeAttr                   string      `xml:"edge,attr,omitempty"`
	SelectionAttr              string      `xml:"selection,attr,omitempty"`
	BevelledAttr               string      `xml:"bevelled,attr,omitempty"`
	HeightAttr                 string      `xml:"height,attr,omitempty"`
	DepthAttr                  string      `xml:"depth,attr,omitempty"`
	ExchPresExpression         []*PresExpression
}

// Merror ...
type Merror *MerrorType

// MerrorType ...
type MerrorType struct {
	XMLName            xml.Name    `xml:"merror"`
	XlinkHrefAttr      interface{} `xml:"xlink:href,attr,omitempty"`
	XlinkTypeAttr      string      `xml:"xlink:type,attr,omitempty"`
	ClassAttr          string      `xml:"class,attr,omitempty"`
	StyleAttr          string      `xml:"style,attr,omitempty"`
	IdAttr             string      `xml:"id,attr,omitempty"`
	XrefAttr           string      `xml:"xref,attr,omitempty"`
	OtherAttr          string      `xml:"other,attr,omitempty"`
	ExchPresExpression []*PresExpression
}

// Mpadded ...
type Mpadded *MpaddedType

// MpaddedType ...
type MpaddedType struct {
	XMLName            xml.Name    `xml:"mpadded"`
	XlinkHrefAttr      interface{} `xml:"xlink:href,attr,omitempty"`
	XlinkTypeAttr      string      `xml:"xlink:type,attr,omitempty"`
	ClassAttr          string      `xml:"class,attr,omitempty"`
	StyleAttr          string      `xml:"style,attr,omitempty"`
	IdAttr             string      `xml:"id,attr,omitempty"`
	XrefAttr           string      `xml:"xref,attr,omitempty"`
	OtherAttr          string      `xml:"other,attr,omitempty"`
	WidthAttr          string      `xml:"width,attr,omitempty"`
	HeightAttr         string      `xml:"height,attr,omitempty"`
	DepthAttr          string      `xml:"depth,attr,omitempty"`
	LspaceAttr         string      `xml:"lspace,attr,omitempty"`
	ExchPresExpression []*PresExpression
}

// Mphantom ...
type Mphantom *MphantomType

// MphantomType ...
type MphantomType struct {
	XMLName            xml.Name    `xml:"mphantom"`
	XlinkHrefAttr      interface{} `xml:"xlink:href,attr,omitempty"`
	XlinkTypeAttr      string      `xml:"xlink:type,attr,omitempty"`
	ClassAttr          string      `xml:"class,attr,omitempty"`
	StyleAttr          string      `xml:"style,attr,omitempty"`
	IdAttr             string      `xml:"id,attr,omitempty"`
	XrefAttr           string      `xml:"xref,attr,omitempty"`
	OtherAttr          string      `xml:"other,attr,omitempty"`
	ExchPresExpression []*PresExpression
}

// Mfenced ...
type Mfenced *MfencedType

// MfencedType ...
type MfencedType struct {
	XMLName            xml.Name    `xml:"mfenced"`
	XlinkHrefAttr      interface{} `xml:"xlink:href,attr,omitempty"`
	XlinkTypeAttr      string      `xml:"xlink:type,attr,omitempty"`
	ClassAttr          string      `xml:"class,attr,omitempty"`
	StyleAttr          string      `xml:"style,attr,omitempty"`
	IdAttr             string      `xml:"id,attr,omitempty"`
	XrefAttr           string      `xml:"xref,attr,omitempty"`
	OtherAttr          string      `xml:"other,attr,omitempty"`
	OpenAttr           string      `xml:"open,attr,omitempty"`
	CloseAttr          string      `xml:"close,attr,omitempty"`
	SeparatorsAttr     string      `xml:"separators,attr,omitempty"`
	ExchPresExpression []*PresExpression
}

// Msub ...
type Msub *MsubType

// MsubType ...
type MsubType struct {
	XMLName               xml.Name    `xml:"msub"`
	XlinkHrefAttr         interface{} `xml:"xlink:href,attr,omitempty"`
	XlinkTypeAttr         string      `xml:"xlink:type,attr,omitempty"`
	ClassAttr             string      `xml:"class,attr,omitempty"`
	StyleAttr             string      `xml:"style,attr,omitempty"`
	IdAttr                string      `xml:"id,attr,omitempty"`
	XrefAttr              string      `xml:"xref,attr,omitempty"`
	OtherAttr             string      `xml:"other,attr,omitempty"`
	SubscriptshiftAttr    string      `xml:"subscriptshift,attr,omitempty"`
	ExchTwoPresExpression []*TwoPresExpression
}

// Msup ...
type Msup *MsupType

// MsupType ...
type MsupType struct {
	XMLName               xml.Name    `xml:"msup"`
	XlinkHrefAttr         interface{} `xml:"xlink:href,attr,omitempty"`
	XlinkTypeAttr         string      `xml:"xlink:type,attr,omitempty"`
	ClassAttr             string      `xml:"class,attr,omitempty"`
	StyleAttr             string      `xml:"style,attr,omitempty"`
	IdAttr                string      `xml:"id,attr,omitempty"`
	XrefAttr              string      `xml:"xref,attr,omitempty"`
	OtherAttr             string      `xml:"other,attr,omitempty"`
	SuperscriptshiftAttr  string      `xml:"superscriptshift,attr,omitempty"`
	ExchTwoPresExpression []*TwoPresExpression
}

// Msubsup ...
type Msubsup *MsubsupType

// MsubsupType ...
type MsubsupType struct {
	XMLName                 xml.Name    `xml:"msubsup"`
	XlinkHrefAttr           interface{} `xml:"xlink:href,attr,omitempty"`
	XlinkTypeAttr           string      `xml:"xlink:type,attr,omitempty"`
	ClassAttr               string      `xml:"class,attr,omitempty"`
	StyleAttr               string      `xml:"style,attr,omitempty"`
	IdAttr                  string      `xml:"id,attr,omitempty"`
	XrefAttr                string      `xml:"xref,attr,omitempty"`
	OtherAttr               string      `xml:"other,attr,omitempty"`
	SubscriptshiftAttr      string      `xml:"subscriptshift,attr,omitempty"`
	SuperscriptshiftAttr    string      `xml:"superscriptshift,attr,omitempty"`
	ExchThreePresExpression []*ThreePresExpression
}

// Munder ...
type Munder *MunderType

// MunderType ...
type MunderType struct {
	XMLName               xml.Name    `xml:"munder"`
	XlinkHrefAttr         interface{} `xml:"xlink:href,attr,omitempty"`
	XlinkTypeAttr         string      `xml:"xlink:type,attr,omitempty"`
	ClassAttr             string      `xml:"class,attr,omitempty"`
	StyleAttr             string      `xml:"style,attr,omitempty"`
	IdAttr                string      `xml:"id,attr,omitempty"`
	XrefAttr              string      `xml:"xref,attr,omitempty"`
	OtherAttr             string      `xml:"other,attr,omitempty"`
	AccentunderAttr       string      `xml:"accentunder,attr,omitempty"`
	ExchTwoPresExpression []*TwoPresExpression
}

// Mover ...
type Mover *MoverType

// MoverType ...
type MoverType struct {
	XMLName               xml.Name    `xml:"mover"`
	XlinkHrefAttr         interface{} `xml:"xlink:href,attr,omitempty"`
	XlinkTypeAttr         string      `xml:"xlink:type,attr,omitempty"`
	ClassAttr             string      `xml:"class,attr,omitempty"`
	StyleAttr             string      `xml:"style,attr,omitempty"`
	IdAttr                string      `xml:"id,attr,omitempty"`
	XrefAttr              string      `xml:"xref,attr,omitempty"`
	OtherAttr             string      `xml:"other,attr,omitempty"`
	AccentAttr            string      `xml:"accent,attr,omitempty"`
	ExchTwoPresExpression []*TwoPresExpression
}

// Munderover ...
type Munderover *MunderoverType

// MunderoverType ...
type MunderoverType struct {
	XMLName                 xml.Name    `xml:"munderover"`
	XlinkHrefAttr           interface{} `xml:"xlink:href,attr,omitempty"`
	XlinkTypeAttr           string      `xml:"xlink:type,attr,omitempty"`
	ClassAttr               string      `xml:"class,attr,omitempty"`
	StyleAttr               string      `xml:"style,attr,omitempty"`
	IdAttr                  string      `xml:"id,attr,omitempty"`
	XrefAttr                string      `xml:"xref,attr,omitempty"`
	OtherAttr               string      `xml:"other,attr,omitempty"`
	AccentAttr              string      `xml:"accent,attr,omitempty"`
	AccentunderAttr         string      `xml:"accentunder,attr,omitempty"`
	ExchThreePresExpression []*ThreePresExpression
}

// Mmultiscripts ...
type Mmultiscripts *MmultiscriptsType

// MmultiscriptsType ...
type MmultiscriptsType struct {
	XMLName                 xml.Name    `xml:"mmultiscripts"`
	XlinkHrefAttr           interface{} `xml:"xlink:href,attr,omitempty"`
	XlinkTypeAttr           string      `xml:"xlink:type,attr,omitempty"`
	ClassAttr               string      `xml:"class,attr,omitempty"`
	StyleAttr               string      `xml:"style,attr,omitempty"`
	IdAttr                  string      `xml:"id,attr,omitempty"`
	XrefAttr                string      `xml:"xref,attr,omitempty"`
	OtherAttr               string      `xml:"other,attr,omitempty"`
	SubscriptshiftAttr      string      `xml:"subscriptshift,attr,omitempty"`
	SuperscriptshiftAttr    string      `xml:"superscriptshift,attr,omitempty"`
	ExchPrscrPresExpression []*PrscrPresExpression
}

// Mtable ...
type Mtable *MtableType

// MtableType ...
type MtableType struct {
	XMLName               xml.Name    `xml:"mtable"`
	XlinkHrefAttr         interface{} `xml:"xlink:href,attr,omitempty"`
	XlinkTypeAttr         string      `xml:"xlink:type,attr,omitempty"`
	ClassAttr             string      `xml:"class,attr,omitempty"`
	StyleAttr             string      `xml:"style,attr,omitempty"`
	IdAttr                string      `xml:"id,attr,omitempty"`
	XrefAttr              string      `xml:"xref,attr,omitempty"`
	OtherAttr             string      `xml:"other,attr,omitempty"`
	AlignAttr             string      `xml:"align,attr,omitempty"`
	RowalignAttr          string      `xml:"rowalign,attr,omitempty"`
	ColumnalignAttr       string      `xml:"columnalign,attr,omitempty"`
	ColumnwidthAttr       string      `xml:"columnwidth,attr,omitempty"`
	GroupalignAttr        string      `xml:"groupalign,attr,omitempty"`
	AlignmentscopeAttr    string      `xml:"alignmentscope,attr,omitempty"`
	SideAttr              string      `xml:"side,attr,omitempty"`
	RowspacingAttr        string      `xml:"rowspacing,attr,omitempty"`
	ColumnspacingAttr     string      `xml:"columnspacing,attr,omitempty"`
	RowlinesAttr          string      `xml:"rowlines,attr,omitempty"`
	ColumnlinesAttr       string      `xml:"columnlines,attr,omitempty"`
	WidthAttr             string      `xml:"width,attr,omitempty"`
	FrameAttr             string      `xml:"frame,attr,omitempty"`
	FramespacingAttr      string      `xml:"framespacing,attr,omitempty"`
	MinlabelspacingAttr   string      `xml:"minlabelspacing,attr,omitempty"`
	EqualrowsAttr         string      `xml:"equalrows,attr,omitempty"`
	EqualcolumnsAttr      string      `xml:"equalcolumns,attr,omitempty"`
	DisplaystyleAttr      string      `xml:"displaystyle,attr,omitempty"`
	ExchMtrPresExpression []*MtrPresExpression
}

// Mtr ...
type Mtr *MtrType

// MtrType ...
type MtrType struct {
	XMLName               xml.Name    `xml:"mtr"`
	XlinkHrefAttr         interface{} `xml:"xlink:href,attr,omitempty"`
	XlinkTypeAttr         string      `xml:"xlink:type,attr,omitempty"`
	ClassAttr             string      `xml:"class,attr,omitempty"`
	StyleAttr             string      `xml:"style,attr,omitempty"`
	IdAttr                string      `xml:"id,attr,omitempty"`
	XrefAttr              string      `xml:"xref,attr,omitempty"`
	OtherAttr             string      `xml:"other,attr,omitempty"`
	RowalignAttr          string      `xml:"rowalign,attr,omitempty"`
	ColumnalignAttr       string      `xml:"columnalign,attr,omitempty"`
	GroupalignAttr        string      `xml:"groupalign,attr,omitempty"`
	ExchMtdPresExpression []*MtdPresExpression
}

// Mlabeledtr ...
type Mlabeledtr *MlabeledtrType

// MlabeledtrType ...
type MlabeledtrType struct {
	XMLName               xml.Name    `xml:"mlabeledtr"`
	XlinkHrefAttr         interface{} `xml:"xlink:href,attr,omitempty"`
	XlinkTypeAttr         string      `xml:"xlink:type,attr,omitempty"`
	ClassAttr             string      `xml:"class,attr,omitempty"`
	StyleAttr             string      `xml:"style,attr,omitempty"`
	IdAttr                string      `xml:"id,attr,omitempty"`
	XrefAttr              string      `xml:"xref,attr,omitempty"`
	OtherAttr             string      `xml:"other,attr,omitempty"`
	RowalignAttr          string      `xml:"rowalign,attr,omitempty"`
	ColumnalignAttr       string      `xml:"columnalign,attr,omitempty"`
	GroupalignAttr        string      `xml:"groupalign,attr,omitempty"`
	ExchMtdPresExpression []*MtdPresExpression
}

// Mtd ...
type Mtd *MtdType

// MtdType ...
type MtdType struct {
	XMLName            xml.Name    `xml:"mtd"`
	XlinkHrefAttr      interface{} `xml:"xlink:href,attr,omitempty"`
	XlinkTypeAttr      string      `xml:"xlink:type,attr,omitempty"`
	ClassAttr          string      `xml:"class,attr,omitempty"`
	StyleAttr          string      `xml:"style,attr,omitempty"`
	IdAttr             string      `xml:"id,attr,omitempty"`
	XrefAttr           string      `xml:"xref,attr,omitempty"`
	OtherAttr          string      `xml:"other,attr,omitempty"`
	RowalignAttr       string      `xml:"rowalign,attr,omitempty"`
	ColumnalignAttr    string      `xml:"columnalign,attr,omitempty"`
	GroupalignAttr     string      `xml:"groupalign,attr,omitempty"`
	RowspanAttr        string      `xml:"rowspan,attr,omitempty"`
	ColumnspanAttr     string      `xml:"columnspan,attr,omitempty"`
	ExchPresExpression []*PresExpression
}

// Maligngroup ...
type Maligngroup *MaligngroupType

// MaligngroupType ...
type MaligngroupType struct {
	XMLName        xml.Name    `xml:"maligngroup"`
	XlinkHrefAttr  interface{} `xml:"xlink:href,attr,omitempty"`
	XlinkTypeAttr  string      `xml:"xlink:type,attr,omitempty"`
	ClassAttr      string      `xml:"class,attr,omitempty"`
	StyleAttr      string      `xml:"style,attr,omitempty"`
	IdAttr         string      `xml:"id,attr,omitempty"`
	XrefAttr       string      `xml:"xref,attr,omitempty"`
	OtherAttr      string      `xml:"other,attr,omitempty"`
	GroupalignAttr string      `xml:"groupalign,attr,omitempty"`
}

// Maction ...
type Maction *MactionType

// MactionType ...
type MactionType struct {
	XMLName            xml.Name    `xml:"maction"`
	XlinkHrefAttr      interface{} `xml:"xlink:href,attr,omitempty"`
	XlinkTypeAttr      string      `xml:"xlink:type,attr,omitempty"`
	ClassAttr          string      `xml:"class,attr,omitempty"`
	StyleAttr          string      `xml:"style,attr,omitempty"`
	IdAttr             string      `xml:"id,attr,omitempty"`
	XrefAttr           string      `xml:"xref,attr,omitempty"`
	OtherAttr          string      `xml:"other,attr,omitempty"`
	ActiontypeAttr     string      `xml:"actiontype,attr,omitempty"`
	SelectionAttr      string      `xml:"selection,attr,omitempty"`
	ExchPresExpression []*PresExpression
}

// Ci ...
type Ci *CiType

// CiType ...
type CiType struct {
	XMLName           xml.Name             `xml:"ci"`
	XlinkHrefAttr     interface{}          `xml:"xlink:href,attr,omitempty"`
	XlinkTypeAttr     string               `xml:"xlink:type,attr,omitempty"`
	ClassAttr         string               `xml:"class,attr,omitempty"`
	StyleAttr         string               `xml:"style,attr,omitempty"`
	IdAttr            string               `xml:"id,attr,omitempty"`
	XrefAttr          string               `xml:"xref,attr,omitempty"`
	OtherAttr         string               `xml:"other,attr,omitempty"`
	TypeAttr          string               `xml:"type,attr,omitempty"`
	DefinitionURLAttr string               `xml:"definitionURL,attr,omitempty"`
	EncodingAttr      string               `xml:"encoding,attr,omitempty"`
	Mglyph            []*MglyphType        `xml:"mglyph"`
	Mi                []*MiType            `xml:"mi"`
	Mn                []*MnType            `xml:"mn"`
	Mo                []*MoType            `xml:"mo"`
	Mtext             []*MtextType         `xml:"mtext"`
	Ms                []*MsType            `xml:"ms"`
	Mspace            []*MspaceType        `xml:"mspace"`
	Mrow              []*MrowType          `xml:"mrow"`
	Mfrac             []*MfracType         `xml:"mfrac"`
	Msqrt             []*MsqrtType         `xml:"msqrt"`
	Mroot             []*MrootType         `xml:"mroot"`
	Menclose          []*MencloseType      `xml:"menclose"`
	Mstyle            []*MstyleType        `xml:"mstyle"`
	Merror            []*MerrorType        `xml:"merror"`
	Mpadded           []*MpaddedType       `xml:"mpadded"`
	Mphantom          []*MphantomType      `xml:"mphantom"`
	Mfenced           []*MfencedType       `xml:"mfenced"`
	Msub              []*MsubType          `xml:"msub"`
	Msup              []*MsupType          `xml:"msup"`
	Msubsup           []*MsubsupType       `xml:"msubsup"`
	Munder            []*MunderType        `xml:"munder"`
	Mover             []*MoverType         `xml:"mover"`
	Munderover        []*MunderoverType    `xml:"munderover"`
	Mmultiscripts     []*MmultiscriptsType `xml:"mmultiscripts"`
	Mtable            []*MtableType        `xml:"mtable"`
	Mtr               []*MtrType           `xml:"mtr"`
	Mlabeledtr        []*MlabeledtrType    `xml:"mlabeledtr"`
	Mtd               []*MtdType           `xml:"mtd"`
	Maligngroup       []*MaligngroupType   `xml:"maligngroup"`
	Malignmark        []*MalignmarkType    `xml:"malignmark"`
	Maction           []*MactionType       `xml:"maction"`
}

// Csymbol ...
type Csymbol *CsymbolType

// CsymbolType ...
type CsymbolType struct {
	XMLName           xml.Name             `xml:"csymbol"`
	XlinkHrefAttr     interface{}          `xml:"xlink:href,attr,omitempty"`
	XlinkTypeAttr     string               `xml:"xlink:type,attr,omitempty"`
	ClassAttr         string               `xml:"class,attr,omitempty"`
	StyleAttr         string               `xml:"style,attr,omitempty"`
	IdAttr            string               `xml:"id,attr,omitempty"`
	XrefAttr          string               `xml:"xref,attr,omitempty"`
	OtherAttr         string               `xml:"other,attr,omitempty"`
	EncodingAttr      string               `xml:"encoding,attr,omitempty"`
	TypeAttr          string               `xml:"type,attr,omitempty"`
	DefinitionURLAttr string               `xml:"definitionURL,attr,omitempty"`
	Mglyph            []*MglyphType        `xml:"mglyph"`
	Mi                []*MiType            `xml:"mi"`
	Mn                []*MnType            `xml:"mn"`
	Mo                []*MoType            `xml:"mo"`
	Mtext             []*MtextType         `xml:"mtext"`
	Ms                []*MsType            `xml:"ms"`
	Mspace            []*MspaceType        `xml:"mspace"`
	Mrow              []*MrowType          `xml:"mrow"`
	Mfrac             []*MfracType         `xml:"mfrac"`
	Msqrt             []*MsqrtType         `xml:"msqrt"`
	Mroot             []*MrootType         `xml:"mroot"`
	Menclose          []*MencloseType      `xml:"menclose"`
	Mstyle            []*MstyleType        `xml:"mstyle"`
	Merror            []*MerrorType        `xml:"merror"`
	Mpadded           []*MpaddedType       `xml:"mpadded"`
	Mphantom          []*MphantomType      `xml:"mphantom"`
	Mfenced           []*MfencedType       `xml:"mfenced"`
	Msub              []*MsubType          `xml:"msub"`
	Msup              []*MsupType          `xml:"msup"`
	Msubsup           []*MsubsupType       `xml:"msubsup"`
	Munder            []*MunderType        `xml:"munder"`
	Mover             []*MoverType         `xml:"mover"`
	Munderover        []*MunderoverType    `xml:"munderover"`
	Mmultiscripts     []*MmultiscriptsType `xml:"mmultiscripts"`
	Mtable            []*MtableType        `xml:"mtable"`
	Mtr               []*MtrType           `xml:"mtr"`
	Mlabeledtr        []*MlabeledtrType    `xml:"mlabeledtr"`
	Mtd               []*MtdType           `xml:"mtd"`
	Maligngroup       []*MaligngroupType   `xml:"maligngroup"`
	Malignmark        []*MalignmarkType    `xml:"malignmark"`
	Maction           []*MactionType       `xml:"maction"`
}

// Cn ...
type Cn *CnType

// CnType ...
type CnType struct {
	XMLName           xml.Name             `xml:"cn"`
	XlinkHrefAttr     interface{}          `xml:"xlink:href,attr,omitempty"`
	XlinkTypeAttr     string               `xml:"xlink:type,attr,omitempty"`
	ClassAttr         string               `xml:"class,attr,omitempty"`
	StyleAttr         string               `xml:"style,attr,omitempty"`
	IdAttr            string               `xml:"id,attr,omitempty"`
	XrefAttr          string               `xml:"xref,attr,omitempty"`
	OtherAttr         string               `xml:"other,attr,omitempty"`
	TypeAttr          string               `xml:"type,attr,omitempty"`
	BaseAttr          string               `xml:"base,attr,omitempty"`
	DefinitionURLAttr string               `xml:"definitionURL,attr,omitempty"`
	EncodingAttr      string               `xml:"encoding,attr,omitempty"`
	Mglyph            []*MglyphType        `xml:"mglyph"`
	Sep               []*SepType           `xml:"sep"`
	Mi                []*MiType            `xml:"mi"`
	Mn                []*MnType            `xml:"mn"`
	Mo                []*MoType            `xml:"mo"`
	Mtext             []*MtextType         `xml:"mtext"`
	Ms                []*MsType            `xml:"ms"`
	Mspace            []*MspaceType        `xml:"mspace"`
	Mrow              []*MrowType          `xml:"mrow"`
	Mfrac             []*MfracType         `xml:"mfrac"`
	Msqrt             []*MsqrtType         `xml:"msqrt"`
	Mroot             []*MrootType         `xml:"mroot"`
	Menclose          []*MencloseType      `xml:"menclose"`
	Mstyle            []*MstyleType        `xml:"mstyle"`
	Merror            []*MerrorType        `xml:"merror"`
	Mpadded           []*MpaddedType       `xml:"mpadded"`
	Mphantom          []*MphantomType      `xml:"mphantom"`
	Mfenced           []*MfencedType       `xml:"mfenced"`
	Msub              []*MsubType          `xml:"msub"`
	Msup              []*MsupType          `xml:"msup"`
	Msubsup           []*MsubsupType       `xml:"msubsup"`
	Munder            []*MunderType        `xml:"munder"`
	Mover             []*MoverType         `xml:"mover"`
	Munderover        []*MunderoverType    `xml:"munderover"`
	Mmultiscripts     []*MmultiscriptsType `xml:"mmultiscripts"`
	Mtable            []*MtableType        `xml:"mtable"`
	Mtr               []*MtrType           `xml:"mtr"`
	Mlabeledtr        []*MlabeledtrType    `xml:"mlabeledtr"`
	Mtd               []*MtdType           `xml:"mtd"`
	Maligngroup       []*MaligngroupType   `xml:"maligngroup"`
	Malignmark        []*MalignmarkType    `xml:"malignmark"`
	Maction           []*MactionType       `xml:"maction"`
}

// Sep ...
type Sep *SepType

// SepType ...
type SepType struct {
	XMLName xml.Name `xml:"sep"`
}

// Integers ...
type Integers *IntegersType

// IntegersType ...
type IntegersType struct {
	XMLName           xml.Name    `xml:"integers"`
	XlinkHrefAttr     interface{} `xml:"xlink:href,attr,omitempty"`
	XlinkTypeAttr     string      `xml:"xlink:type,attr,omitempty"`
	ClassAttr         string      `xml:"class,attr,omitempty"`
	StyleAttr         string      `xml:"style,attr,omitempty"`
	IdAttr            string      `xml:"id,attr,omitempty"`
	XrefAttr          string      `xml:"xref,attr,omitempty"`
	OtherAttr         string      `xml:"other,attr,omitempty"`
	DefinitionURLAttr string      `xml:"definitionURL,attr,omitempty"`
	EncodingAttr      string      `xml:"encoding,attr,omitempty"`
}

// Reals ...
type Reals *RealsType

// RealsType ...
type RealsType struct {
	XMLName           xml.Name    `xml:"reals"`
	XlinkHrefAttr     interface{} `xml:"xlink:href,attr,omitempty"`
	XlinkTypeAttr     string      `xml:"xlink:type,attr,omitempty"`
	ClassAttr         string      `xml:"class,attr,omitempty"`
	StyleAttr         string      `xml:"style,attr,omitempty"`
	IdAttr            string      `xml:"id,attr,omitempty"`
	XrefAttr          string      `xml:"xref,attr,omitempty"`
	OtherAttr         string      `xml:"other,attr,omitempty"`
	DefinitionURLAttr string      `xml:"definitionURL,attr,omitempty"`
	EncodingAttr      string      `xml:"encoding,attr,omitempty"`
}

// Rationals ...
type Rationals *RationalsType

// RationalsType ...
type RationalsType struct {
	XMLName           xml.Name    `xml:"rationals"`
	XlinkHrefAttr     interface{} `xml:"xlink:href,attr,omitempty"`
	XlinkTypeAttr     string      `xml:"xlink:type,attr,omitempty"`
	ClassAttr         string      `xml:"class,attr,omitempty"`
	StyleAttr         string      `xml:"style,attr,omitempty"`
	IdAttr            string      `xml:"id,attr,omitempty"`
	XrefAttr          string      `xml:"xref,attr,omitempty"`
	OtherAttr         string      `xml:"other,attr,omitempty"`
	DefinitionURLAttr string      `xml:"definitionURL,attr,omitempty"`
	EncodingAttr      string      `xml:"encoding,attr,omitempty"`
}

// Naturalnumbers ...
type Naturalnumbers *NaturalnumbersType

// NaturalnumbersType ...
type NaturalnumbersType struct {
	XMLName           xml.Name    `xml:"naturalnumbers"`
	XlinkHrefAttr     interface{} `xml:"xlink:href,attr,omitempty"`
	XlinkTypeAttr     string      `xml:"xlink:type,attr,omitempty"`
	ClassAttr         string      `xml:"class,attr,omitempty"`
	StyleAttr         string      `xml:"style,attr,omitempty"`
	IdAttr            string      `xml:"id,attr,omitempty"`
	XrefAttr          string      `xml:"xref,attr,omitempty"`
	OtherAttr         string      `xml:"other,attr,omitempty"`
	DefinitionURLAttr string      `xml:"definitionURL,attr,omitempty"`
	EncodingAttr      string      `xml:"encoding,attr,omitempty"`
}

// Complexes ...
type Complexes *ComplexesType

// ComplexesType ...
type ComplexesType struct {
	XMLName           xml.Name    `xml:"complexes"`
	XlinkHrefAttr     interface{} `xml:"xlink:href,attr,omitempty"`
	XlinkTypeAttr     string      `xml:"xlink:type,attr,omitempty"`
	ClassAttr         string      `xml:"class,attr,omitempty"`
	StyleAttr         string      `xml:"style,attr,omitempty"`
	IdAttr            string      `xml:"id,attr,omitempty"`
	XrefAttr          string      `xml:"xref,attr,omitempty"`
	OtherAttr         string      `xml:"other,attr,omitempty"`
	DefinitionURLAttr string      `xml:"definitionURL,attr,omitempty"`
	EncodingAttr      string      `xml:"encoding,attr,omitempty"`
}

// Primes ...
type Primes *PrimesType

// PrimesType ...
type PrimesType struct {
	XMLName           xml.Name    `xml:"primes"`
	XlinkHrefAttr     interface{} `xml:"xlink:href,attr,omitempty"`
	XlinkTypeAttr     string      `xml:"xlink:type,attr,omitempty"`
	ClassAttr         string      `xml:"class,attr,omitempty"`
	StyleAttr         string      `xml:"style,attr,omitempty"`
	IdAttr            string      `xml:"id,attr,omitempty"`
	XrefAttr          string      `xml:"xref,attr,omitempty"`
	OtherAttr         string      `xml:"other,attr,omitempty"`
	DefinitionURLAttr string      `xml:"definitionURL,attr,omitempty"`
	EncodingAttr      string      `xml:"encoding,attr,omitempty"`
}

// Exponentiale ...
type Exponentiale *ExponentialeType

// ExponentialeType ...
type ExponentialeType struct {
	XMLName           xml.Name    `xml:"exponentiale"`
	XlinkHrefAttr     interface{} `xml:"xlink:href,attr,omitempty"`
	XlinkTypeAttr     string      `xml:"xlink:type,attr,omitempty"`
	ClassAttr         string      `xml:"class,attr,omitempty"`
	StyleAttr         string      `xml:"style,attr,omitempty"`
	IdAttr            string      `xml:"id,attr,omitempty"`
	XrefAttr          string      `xml:"xref,attr,omitempty"`
	OtherAttr         string      `xml:"other,attr,omitempty"`
	DefinitionURLAttr string      `xml:"definitionURL,attr,omitempty"`
	EncodingAttr      string      `xml:"encoding,attr,omitempty"`
}

// Imaginaryi ...
type Imaginaryi *ImaginaryiType

// ImaginaryiType ...
type ImaginaryiType struct {
	XMLName           xml.Name    `xml:"imaginaryi"`
	XlinkHrefAttr     interface{} `xml:"xlink:href,attr,omitempty"`
	XlinkTypeAttr     string      `xml:"xlink:type,attr,omitempty"`
	ClassAttr         string      `xml:"class,attr,omitempty"`
	StyleAttr         string      `xml:"style,attr,omitempty"`
	IdAttr            string      `xml:"id,attr,omitempty"`
	XrefAttr          string      `xml:"xref,attr,omitempty"`
	OtherAttr         string      `xml:"other,attr,omitempty"`
	DefinitionURLAttr string      `xml:"definitionURL,attr,omitempty"`
	EncodingAttr      string      `xml:"encoding,attr,omitempty"`
}

// Notanumber ...
type Notanumber *NotanumberType

// NotanumberType ...
type NotanumberType struct {
	XMLName           xml.Name    `xml:"notanumber"`
	XlinkHrefAttr     interface{} `xml:"xlink:href,attr,omitempty"`
	XlinkTypeAttr     string      `xml:"xlink:type,attr,omitempty"`
	ClassAttr         string      `xml:"class,attr,omitempty"`
	StyleAttr         string      `xml:"style,attr,omitempty"`
	IdAttr            string      `xml:"id,attr,omitempty"`
	XrefAttr          string      `xml:"xref,attr,omitempty"`
	OtherAttr         string      `xml:"other,attr,omitempty"`
	DefinitionURLAttr string      `xml:"definitionURL,attr,omitempty"`
	EncodingAttr      string      `xml:"encoding,attr,omitempty"`
}

// True ...
type True *TrueType

// TrueType ...
type TrueType struct {
	XMLName           xml.Name    `xml:"true"`
	XlinkHrefAttr     interface{} `xml:"xlink:href,attr,omitempty"`
	XlinkTypeAttr     string      `xml:"xlink:type,attr,omitempty"`
	ClassAttr         string      `xml:"class,attr,omitempty"`
	StyleAttr         string      `xml:"style,attr,omitempty"`
	IdAttr            string      `xml:"id,attr,omitempty"`
	XrefAttr          string      `xml:"xref,attr,omitempty"`
	OtherAttr         string      `xml:"other,attr,omitempty"`
	DefinitionURLAttr string      `xml:"definitionURL,attr,omitempty"`
	EncodingAttr      string      `xml:"encoding,attr,omitempty"`
}

// False ...
type False *FalseType

// FalseType ...
type FalseType struct {
	XMLName           xml.Name    `xml:"false"`
	XlinkHrefAttr     interface{} `xml:"xlink:href,attr,omitempty"`
	XlinkTypeAttr     string      `xml:"xlink:type,attr,omitempty"`
	ClassAttr         string      `xml:"class,attr,omitempty"`
	StyleAttr         string      `xml:"style,attr,omitempty"`
	IdAttr            string      `xml:"id,attr,omitempty"`
	XrefAttr          string      `xml:"xref,attr,omitempty"`
	OtherAttr         string      `xml:"other,attr,omitempty"`
	DefinitionURLAttr string      `xml:"definitionURL,attr,omitempty"`
	EncodingAttr      string      `xml:"encoding,attr,omitempty"`
}

// Emptyset ...
type Emptyset *EmptysetType

// EmptysetType ...
type EmptysetType struct {
	XMLName           xml.Name    `xml:"emptyset"`
	XlinkHrefAttr     interface{} `xml:"xlink:href,attr,omitempty"`
	XlinkTypeAttr     string      `xml:"xlink:type,attr,omitempty"`
	ClassAttr         string      `xml:"class,attr,omitempty"`
	StyleAttr         string      `xml:"style,attr,omitempty"`
	IdAttr            string      `xml:"id,attr,omitempty"`
	XrefAttr          string      `xml:"xref,attr,omitempty"`
	OtherAttr         string      `xml:"other,attr,omitempty"`
	DefinitionURLAttr string      `xml:"definitionURL,attr,omitempty"`
	EncodingAttr      string      `xml:"encoding,attr,omitempty"`
}

// Pi ...
type Pi *PiType

// PiType ...
type PiType struct {
	XMLName           xml.Name    `xml:"pi"`
	XlinkHrefAttr     interface{} `xml:"xlink:href,attr,omitempty"`
	XlinkTypeAttr     string      `xml:"xlink:type,attr,omitempty"`
	ClassAttr         string      `xml:"class,attr,omitempty"`
	StyleAttr         string      `xml:"style,attr,omitempty"`
	IdAttr            string      `xml:"id,attr,omitempty"`
	XrefAttr          string      `xml:"xref,attr,omitempty"`
	OtherAttr         string      `xml:"other,attr,omitempty"`
	DefinitionURLAttr string      `xml:"definitionURL,attr,omitempty"`
	EncodingAttr      string      `xml:"encoding,attr,omitempty"`
}

// Eulergamma ...
type Eulergamma *EulergammaType

// EulergammaType ...
type EulergammaType struct {
	XMLName           xml.Name    `xml:"eulergamma"`
	XlinkHrefAttr     interface{} `xml:"xlink:href,attr,omitempty"`
	XlinkTypeAttr     string      `xml:"xlink:type,attr,omitempty"`
	ClassAttr         string      `xml:"class,attr,omitempty"`
	StyleAttr         string      `xml:"style,attr,omitempty"`
	IdAttr            string      `xml:"id,attr,omitempty"`
	XrefAttr          string      `xml:"xref,attr,omitempty"`
	OtherAttr         string      `xml:"other,attr,omitempty"`
	DefinitionURLAttr string      `xml:"definitionURL,attr,omitempty"`
	EncodingAttr      string      `xml:"encoding,attr,omitempty"`
}

// Infinity ...
type Infinity *InfinityType

// InfinityType ...
type InfinityType struct {
	XMLName           xml.Name    `xml:"infinity"`
	XlinkHrefAttr     interface{} `xml:"xlink:href,attr,omitempty"`
	XlinkTypeAttr     string      `xml:"xlink:type,attr,omitempty"`
	ClassAttr         string      `xml:"class,attr,omitempty"`
	StyleAttr         string      `xml:"style,attr,omitempty"`
	IdAttr            string      `xml:"id,attr,omitempty"`
	XrefAttr          string      `xml:"xref,attr,omitempty"`
	OtherAttr         string      `xml:"other,attr,omitempty"`
	DefinitionURLAttr string      `xml:"definitionURL,attr,omitempty"`
	EncodingAttr      string      `xml:"encoding,attr,omitempty"`
}

// Apply ...
type Apply *ApplyType

// ApplyType ...
type ApplyType struct {
	XMLName               xml.Name    `xml:"apply"`
	XlinkHrefAttr         interface{} `xml:"xlink:href,attr,omitempty"`
	XlinkTypeAttr         string      `xml:"xlink:type,attr,omitempty"`
	ClassAttr             string      `xml:"class,attr,omitempty"`
	StyleAttr             string      `xml:"style,attr,omitempty"`
	IdAttr                string      `xml:"id,attr,omitempty"`
	XrefAttr              string      `xml:"xref,attr,omitempty"`
	OtherAttr             string      `xml:"other,attr,omitempty"`
	ExchContentExpression []*ContentExpression
}

// Reln ...
type Reln *RelnType

// RelnType ...
type RelnType struct {
	XMLName               xml.Name    `xml:"reln"`
	XlinkHrefAttr         interface{} `xml:"xlink:href,attr,omitempty"`
	XlinkTypeAttr         string      `xml:"xlink:type,attr,omitempty"`
	ClassAttr             string      `xml:"class,attr,omitempty"`
	StyleAttr             string      `xml:"style,attr,omitempty"`
	IdAttr                string      `xml:"id,attr,omitempty"`
	XrefAttr              string      `xml:"xref,attr,omitempty"`
	OtherAttr             string      `xml:"other,attr,omitempty"`
	ExchContentExpression []*ContentExpression
}

// Lambda ...
type Lambda *LambdaType

// LambdaType ...
type LambdaType struct {
	XMLName               xml.Name    `xml:"lambda"`
	XlinkHrefAttr         interface{} `xml:"xlink:href,attr,omitempty"`
	XlinkTypeAttr         string      `xml:"xlink:type,attr,omitempty"`
	ClassAttr             string      `xml:"class,attr,omitempty"`
	StyleAttr             string      `xml:"style,attr,omitempty"`
	IdAttr                string      `xml:"id,attr,omitempty"`
	XrefAttr              string      `xml:"xref,attr,omitempty"`
	OtherAttr             string      `xml:"other,attr,omitempty"`
	ExchContentExpression []*ContentExpression
}

// Condition ...
type Condition *ConditionType

// ConditionType ...
type ConditionType struct {
	XMLName               xml.Name    `xml:"condition"`
	XlinkHrefAttr         interface{} `xml:"xlink:href,attr,omitempty"`
	XlinkTypeAttr         string      `xml:"xlink:type,attr,omitempty"`
	ClassAttr             string      `xml:"class,attr,omitempty"`
	StyleAttr             string      `xml:"style,attr,omitempty"`
	IdAttr                string      `xml:"id,attr,omitempty"`
	XrefAttr              string      `xml:"xref,attr,omitempty"`
	OtherAttr             string      `xml:"other,attr,omitempty"`
	ExchContentExpression []*ContentExpression
}

// Declare ...
type Declare *DeclareType

// DeclareType ...
type DeclareType struct {
	XMLName               xml.Name    `xml:"declare"`
	XlinkHrefAttr         interface{} `xml:"xlink:href,attr,omitempty"`
	XlinkTypeAttr         string      `xml:"xlink:type,attr,omitempty"`
	ClassAttr             string      `xml:"class,attr,omitempty"`
	StyleAttr             string      `xml:"style,attr,omitempty"`
	IdAttr                string      `xml:"id,attr,omitempty"`
	XrefAttr              string      `xml:"xref,attr,omitempty"`
	OtherAttr             string      `xml:"other,attr,omitempty"`
	TypeAttr              string      `xml:"type,attr,omitempty"`
	ScopeAttr             string      `xml:"scope,attr,omitempty"`
	NargsAttr             string      `xml:"nargs,attr,omitempty"`
	OccurrenceAttr        string      `xml:"occurrence,attr,omitempty"`
	DefinitionURLAttr     string      `xml:"definitionURL,attr,omitempty"`
	EncodingAttr          string      `xml:"encoding,attr,omitempty"`
	ExchContentExpression []*ContentExpression
}

// Semantics ...
type Semantics *SemanticsType

// SemanticsType ...
type SemanticsType struct {
	XMLName                        xml.Name    `xml:"semantics"`
	XlinkHrefAttr                  interface{} `xml:"xlink:href,attr,omitempty"`
	XlinkTypeAttr                  string      `xml:"xlink:type,attr,omitempty"`
	ClassAttr                      string      `xml:"class,attr,omitempty"`
	StyleAttr                      string      `xml:"style,attr,omitempty"`
	IdAttr                         string      `xml:"id,attr,omitempty"`
	XrefAttr                       string      `xml:"xref,attr,omitempty"`
	OtherAttr                      string      `xml:"other,attr,omitempty"`
	DefinitionURLAttr              string      `xml:"definitionURL,attr,omitempty"`
	EncodingAttr                   string      `xml:"encoding,attr,omitempty"`
	ExchSemanticsContentExpression []*SemanticsContentExpression
}

// Annotation ...
type Annotation *AnnotationType

// AnnotationType ...
type AnnotationType struct {
	XMLName       xml.Name    `xml:"annotation"`
	XlinkHrefAttr interface{} `xml:"xlink:href,attr,omitempty"`
	XlinkTypeAttr string      `xml:"xlink:type,attr,omitempty"`
	ClassAttr     string      `xml:"class,attr,omitempty"`
	StyleAttr     string      `xml:"style,attr,omitempty"`
	IdAttr        string      `xml:"id,attr,omitempty"`
	XrefAttr      string      `xml:"xref,attr,omitempty"`
	OtherAttr     string      `xml:"other,attr,omitempty"`
	EncodingAttr  string      `xml:"encoding,attr,omitempty"`
	Value         string      `xml:",chardata"`
}

// Annotationxml ...
type Annotationxml *AnnotationxmlType

// AnnotationxmlType ...
type AnnotationxmlType struct {
	XMLName       xml.Name    `xml:"annotation-xml"`
	XlinkHrefAttr interface{} `xml:"xlink:href,attr,omitempty"`
	XlinkTypeAttr string      `xml:"xlink:type,attr,omitempty"`
	ClassAttr     string      `xml:"class,attr,omitempty"`
	StyleAttr     string      `xml:"style,attr,omitempty"`
	IdAttr        string      `xml:"id,attr,omitempty"`
	XrefAttr      string      `xml:"xref,attr,omitempty"`
	OtherAttr     string      `xml:"other,attr,omitempty"`
	EncodingAttr  string      `xml:"encoding,attr,omitempty"`
	Value         string      `xml:",chardata"`
}

// Interval ...
type Interval *IntervalType

// IntervalType ...
type IntervalType struct {
	XMLName               xml.Name    `xml:"interval"`
	XlinkHrefAttr         interface{} `xml:"xlink:href,attr,omitempty"`
	XlinkTypeAttr         string      `xml:"xlink:type,attr,omitempty"`
	ClassAttr             string      `xml:"class,attr,omitempty"`
	StyleAttr             string      `xml:"style,attr,omitempty"`
	IdAttr                string      `xml:"id,attr,omitempty"`
	XrefAttr              string      `xml:"xref,attr,omitempty"`
	OtherAttr             string      `xml:"other,attr,omitempty"`
	ClosureAttr           string      `xml:"closure,attr,omitempty"`
	ExchContentExpression []*ContentExpression
}

// List ...
type List *ListType

// ListType ...
type ListType struct {
	XMLName               xml.Name    `xml:"list"`
	XlinkHrefAttr         interface{} `xml:"xlink:href,attr,omitempty"`
	XlinkTypeAttr         string      `xml:"xlink:type,attr,omitempty"`
	ClassAttr             string      `xml:"class,attr,omitempty"`
	StyleAttr             string      `xml:"style,attr,omitempty"`
	IdAttr                string      `xml:"id,attr,omitempty"`
	XrefAttr              string      `xml:"xref,attr,omitempty"`
	OtherAttr             string      `xml:"other,attr,omitempty"`
	OrderAttr             string      `xml:"order,attr,omitempty"`
	ExchContentExpression []*ContentExpression
}

// Matrix ...
type Matrix *MatrixType

// MatrixType ...
type MatrixType struct {
	XMLName               xml.Name    `xml:"matrix"`
	XlinkHrefAttr         interface{} `xml:"xlink:href,attr,omitempty"`
	XlinkTypeAttr         string      `xml:"xlink:type,attr,omitempty"`
	ClassAttr             string      `xml:"class,attr,omitempty"`
	StyleAttr             string      `xml:"style,attr,omitempty"`
	IdAttr                string      `xml:"id,attr,omitempty"`
	XrefAttr              string      `xml:"xref,attr,omitempty"`
	OtherAttr             string      `xml:"other,attr,omitempty"`
	ExchContentExpression []*ContentExpression
}

// Matrixrow ...
type Matrixrow *MatrixrowType

// MatrixrowType ...
type MatrixrowType struct {
	XMLName               xml.Name    `xml:"matrixrow"`
	XlinkHrefAttr         interface{} `xml:"xlink:href,attr,omitempty"`
	XlinkTypeAttr         string      `xml:"xlink:type,attr,omitempty"`
	ClassAttr             string      `xml:"class,attr,omitempty"`
	StyleAttr             string      `xml:"style,attr,omitempty"`
	IdAttr                string      `xml:"id,attr,omitempty"`
	XrefAttr              string      `xml:"xref,attr,omitempty"`
	OtherAttr             string      `xml:"other,attr,omitempty"`
	ExchContentExpression []*ContentExpression
}

// Set ...
type Set *SetType

// SetType ...
type SetType struct {
	XMLName               xml.Name    `xml:"set"`
	XlinkHrefAttr         interface{} `xml:"xlink:href,attr,omitempty"`
	XlinkTypeAttr         string      `xml:"xlink:type,attr,omitempty"`
	ClassAttr             string      `xml:"class,attr,omitempty"`
	StyleAttr             string      `xml:"style,attr,omitempty"`
	IdAttr                string      `xml:"id,attr,omitempty"`
	XrefAttr              string      `xml:"xref,attr,omitempty"`
	OtherAttr             string      `xml:"other,attr,omitempty"`
	TypeAttr              string      `xml:"type,attr,omitempty"`
	ExchContentExpression []*ContentExpression
}

// Vector ...
type Vector *VectorType

// VectorType ...
type VectorType struct {
	XMLName               xml.Name    `xml:"vector"`
	XlinkHrefAttr         interface{} `xml:"xlink:href,attr,omitempty"`
	XlinkTypeAttr         string      `xml:"xlink:type,attr,omitempty"`
	ClassAttr             string      `xml:"class,attr,omitempty"`
	StyleAttr             string      `xml:"style,attr,omitempty"`
	IdAttr                string      `xml:"id,attr,omitempty"`
	XrefAttr              string      `xml:"xref,attr,omitempty"`
	OtherAttr             string      `xml:"other,attr,omitempty"`
	ExchContentExpression []*ContentExpression
}

// Piecewise ...
type Piecewise *PiecewiseType

// PiecewiseType ...
type PiecewiseType struct {
	XMLName       xml.Name       `xml:"piecewise"`
	XlinkHrefAttr interface{}    `xml:"xlink:href,attr,omitempty"`
	XlinkTypeAttr string         `xml:"xlink:type,attr,omitempty"`
	ClassAttr     string         `xml:"class,attr,omitempty"`
	StyleAttr     string         `xml:"style,attr,omitempty"`
	IdAttr        string         `xml:"id,attr,omitempty"`
	XrefAttr      string         `xml:"xref,attr,omitempty"`
	OtherAttr     string         `xml:"other,attr,omitempty"`
	ExchPiece     []*PieceType   `xml:"piece"`
	ExchOtherwise *OtherwiseType `xml:"otherwise"`
}

// Piece ...
type Piece *PieceType

// PieceType ...
type PieceType struct {
	XMLName               xml.Name    `xml:"piece"`
	XlinkHrefAttr         interface{} `xml:"xlink:href,attr,omitempty"`
	XlinkTypeAttr         string      `xml:"xlink:type,attr,omitempty"`
	ClassAttr             string      `xml:"class,attr,omitempty"`
	StyleAttr             string      `xml:"style,attr,omitempty"`
	IdAttr                string      `xml:"id,attr,omitempty"`
	XrefAttr              string      `xml:"xref,attr,omitempty"`
	OtherAttr             string      `xml:"other,attr,omitempty"`
	ExchContentExpression []*ContentExpression
}

// Otherwise ...
type Otherwise *OtherwiseType

// OtherwiseType ...
type OtherwiseType struct {
	XMLName               xml.Name    `xml:"otherwise"`
	XlinkHrefAttr         interface{} `xml:"xlink:href,attr,omitempty"`
	XlinkTypeAttr         string      `xml:"xlink:type,attr,omitempty"`
	ClassAttr             string      `xml:"class,attr,omitempty"`
	StyleAttr             string      `xml:"style,attr,omitempty"`
	IdAttr                string      `xml:"id,attr,omitempty"`
	XrefAttr              string      `xml:"xref,attr,omitempty"`
	OtherAttr             string      `xml:"other,attr,omitempty"`
	ExchContentExpression []*ContentExpression
}

// Lowlimit ...
type Lowlimit *LowlimitType

// LowlimitType ...
type LowlimitType struct {
	XMLName               xml.Name    `xml:"lowlimit"`
	XlinkHrefAttr         interface{} `xml:"xlink:href,attr,omitempty"`
	XlinkTypeAttr         string      `xml:"xlink:type,attr,omitempty"`
	ClassAttr             string      `xml:"class,attr,omitempty"`
	StyleAttr             string      `xml:"style,attr,omitempty"`
	IdAttr                string      `xml:"id,attr,omitempty"`
	XrefAttr              string      `xml:"xref,attr,omitempty"`
	OtherAttr             string      `xml:"other,attr,omitempty"`
	ExchContentExpression []*ContentExpression
}

// Uplimit ...
type Uplimit *UplimitType

// UplimitType ...
type UplimitType struct {
	XMLName               xml.Name    `xml:"uplimit"`
	XlinkHrefAttr         interface{} `xml:"xlink:href,attr,omitempty"`
	XlinkTypeAttr         string      `xml:"xlink:type,attr,omitempty"`
	ClassAttr             string      `xml:"class,attr,omitempty"`
	StyleAttr             string      `xml:"style,attr,omitempty"`
	IdAttr                string      `xml:"id,attr,omitempty"`
	XrefAttr              string      `xml:"xref,attr,omitempty"`
	OtherAttr             string      `xml:"other,attr,omitempty"`
	ExchContentExpression []*ContentExpression
}

// Bvar ...
type Bvar *BvarType

// BvarType ...
type BvarType struct {
	XMLName               xml.Name    `xml:"bvar"`
	XlinkHrefAttr         interface{} `xml:"xlink:href,attr,omitempty"`
	XlinkTypeAttr         string      `xml:"xlink:type,attr,omitempty"`
	ClassAttr             string      `xml:"class,attr,omitempty"`
	StyleAttr             string      `xml:"style,attr,omitempty"`
	IdAttr                string      `xml:"id,attr,omitempty"`
	XrefAttr              string      `xml:"xref,attr,omitempty"`
	OtherAttr             string      `xml:"other,attr,omitempty"`
	ExchContentExpression []*ContentExpression
}

// Degree ...
type Degree *DegreeType

// DegreeType ...
type DegreeType struct {
	XMLName               xml.Name    `xml:"degree"`
	XlinkHrefAttr         interface{} `xml:"xlink:href,attr,omitempty"`
	XlinkTypeAttr         string      `xml:"xlink:type,attr,omitempty"`
	ClassAttr             string      `xml:"class,attr,omitempty"`
	StyleAttr             string      `xml:"style,attr,omitempty"`
	IdAttr                string      `xml:"id,attr,omitempty"`
	XrefAttr              string      `xml:"xref,attr,omitempty"`
	OtherAttr             string      `xml:"other,attr,omitempty"`
	ExchContentExpression []*ContentExpression
}

// Logbase ...
type Logbase *LogbaseType

// LogbaseType ...
type LogbaseType struct {
	XMLName               xml.Name    `xml:"logbase"`
	XlinkHrefAttr         interface{} `xml:"xlink:href,attr,omitempty"`
	XlinkTypeAttr         string      `xml:"xlink:type,attr,omitempty"`
	ClassAttr             string      `xml:"class,attr,omitempty"`
	StyleAttr             string      `xml:"style,attr,omitempty"`
	IdAttr                string      `xml:"id,attr,omitempty"`
	XrefAttr              string      `xml:"xref,attr,omitempty"`
	OtherAttr             string      `xml:"other,attr,omitempty"`
	ExchContentExpression []*ContentExpression
}

// Momentabout ...
type Momentabout *MomentaboutType

// MomentaboutType ...
type MomentaboutType struct {
	XMLName               xml.Name    `xml:"momentabout"`
	XlinkHrefAttr         interface{} `xml:"xlink:href,attr,omitempty"`
	XlinkTypeAttr         string      `xml:"xlink:type,attr,omitempty"`
	ClassAttr             string      `xml:"class,attr,omitempty"`
	StyleAttr             string      `xml:"style,attr,omitempty"`
	IdAttr                string      `xml:"id,attr,omitempty"`
	XrefAttr              string      `xml:"xref,attr,omitempty"`
	OtherAttr             string      `xml:"other,attr,omitempty"`
	ExchContentExpression []*ContentExpression
}

// Domainofapplication ...
type Domainofapplication *DomainofapplicationType

// DomainofapplicationType ...
type DomainofapplicationType struct {
	XMLName               xml.Name    `xml:"domainofapplication"`
	XlinkHrefAttr         interface{} `xml:"xlink:href,attr,omitempty"`
	XlinkTypeAttr         string      `xml:"xlink:type,attr,omitempty"`
	ClassAttr             string      `xml:"class,attr,omitempty"`
	StyleAttr             string      `xml:"style,attr,omitempty"`
	IdAttr                string      `xml:"id,attr,omitempty"`
	XrefAttr              string      `xml:"xref,attr,omitempty"`
	OtherAttr             string      `xml:"other,attr,omitempty"`
	ExchContentExpression []*ContentExpression
}

// Inverse ...
type Inverse *InverseType

// InverseType ...
type InverseType struct {
	XMLName           xml.Name    `xml:"inverse"`
	XlinkHrefAttr     interface{} `xml:"xlink:href,attr,omitempty"`
	XlinkTypeAttr     string      `xml:"xlink:type,attr,omitempty"`
	ClassAttr         string      `xml:"class,attr,omitempty"`
	StyleAttr         string      `xml:"style,attr,omitempty"`
	IdAttr            string      `xml:"id,attr,omitempty"`
	XrefAttr          string      `xml:"xref,attr,omitempty"`
	OtherAttr         string      `xml:"other,attr,omitempty"`
	DefinitionURLAttr string      `xml:"definitionURL,attr,omitempty"`
	EncodingAttr      string      `xml:"encoding,attr,omitempty"`
}

// Ident ...
type Ident *IdentType

// IdentType ...
type IdentType struct {
	XMLName           xml.Name    `xml:"ident"`
	XlinkHrefAttr     interface{} `xml:"xlink:href,attr,omitempty"`
	XlinkTypeAttr     string      `xml:"xlink:type,attr,omitempty"`
	ClassAttr         string      `xml:"class,attr,omitempty"`
	StyleAttr         string      `xml:"style,attr,omitempty"`
	IdAttr            string      `xml:"id,attr,omitempty"`
	XrefAttr          string      `xml:"xref,attr,omitempty"`
	OtherAttr         string      `xml:"other,attr,omitempty"`
	DefinitionURLAttr string      `xml:"definitionURL,attr,omitempty"`
	EncodingAttr      string      `xml:"encoding,attr,omitempty"`
}

// Domain ...
type Domain *DomainType

// DomainType ...
type DomainType struct {
	XMLName           xml.Name    `xml:"domain"`
	XlinkHrefAttr     interface{} `xml:"xlink:href,attr,omitempty"`
	XlinkTypeAttr     string      `xml:"xlink:type,attr,omitempty"`
	ClassAttr         string      `xml:"class,attr,omitempty"`
	StyleAttr         string      `xml:"style,attr,omitempty"`
	IdAttr            string      `xml:"id,attr,omitempty"`
	XrefAttr          string      `xml:"xref,attr,omitempty"`
	OtherAttr         string      `xml:"other,attr,omitempty"`
	DefinitionURLAttr string      `xml:"definitionURL,attr,omitempty"`
	EncodingAttr      string      `xml:"encoding,attr,omitempty"`
}

// Codomain ...
type Codomain *CodomainType

// CodomainType ...
type CodomainType struct {
	XMLName           xml.Name    `xml:"codomain"`
	XlinkHrefAttr     interface{} `xml:"xlink:href,attr,omitempty"`
	XlinkTypeAttr     string      `xml:"xlink:type,attr,omitempty"`
	ClassAttr         string      `xml:"class,attr,omitempty"`
	StyleAttr         string      `xml:"style,attr,omitempty"`
	IdAttr            string      `xml:"id,attr,omitempty"`
	XrefAttr          string      `xml:"xref,attr,omitempty"`
	OtherAttr         string      `xml:"other,attr,omitempty"`
	DefinitionURLAttr string      `xml:"definitionURL,attr,omitempty"`
	EncodingAttr      string      `xml:"encoding,attr,omitempty"`
}

// Image ...
type Image *ImageType

// ImageType ...
type ImageType struct {
	XMLName           xml.Name    `xml:"image"`
	XlinkHrefAttr     interface{} `xml:"xlink:href,attr,omitempty"`
	XlinkTypeAttr     string      `xml:"xlink:type,attr,omitempty"`
	ClassAttr         string      `xml:"class,attr,omitempty"`
	StyleAttr         string      `xml:"style,attr,omitempty"`
	IdAttr            string      `xml:"id,attr,omitempty"`
	XrefAttr          string      `xml:"xref,attr,omitempty"`
	OtherAttr         string      `xml:"other,attr,omitempty"`
	DefinitionURLAttr string      `xml:"definitionURL,attr,omitempty"`
	EncodingAttr      string      `xml:"encoding,attr,omitempty"`
}

// Abs ...
type Abs *AbsType

// AbsType ...
type AbsType struct {
	XMLName           xml.Name    `xml:"abs"`
	XlinkHrefAttr     interface{} `xml:"xlink:href,attr,omitempty"`
	XlinkTypeAttr     string      `xml:"xlink:type,attr,omitempty"`
	ClassAttr         string      `xml:"class,attr,omitempty"`
	StyleAttr         string      `xml:"style,attr,omitempty"`
	IdAttr            string      `xml:"id,attr,omitempty"`
	XrefAttr          string      `xml:"xref,attr,omitempty"`
	OtherAttr         string      `xml:"other,attr,omitempty"`
	DefinitionURLAttr string      `xml:"definitionURL,attr,omitempty"`
	EncodingAttr      string      `xml:"encoding,attr,omitempty"`
}

// Conjugate ...
type Conjugate *ConjugateType

// ConjugateType ...
type ConjugateType struct {
	XMLName           xml.Name    `xml:"conjugate"`
	XlinkHrefAttr     interface{} `xml:"xlink:href,attr,omitempty"`
	XlinkTypeAttr     string      `xml:"xlink:type,attr,omitempty"`
	ClassAttr         string      `xml:"class,attr,omitempty"`
	StyleAttr         string      `xml:"style,attr,omitempty"`
	IdAttr            string      `xml:"id,attr,omitempty"`
	XrefAttr          string      `xml:"xref,attr,omitempty"`
	OtherAttr         string      `xml:"other,attr,omitempty"`
	DefinitionURLAttr string      `xml:"definitionURL,attr,omitempty"`
	EncodingAttr      string      `xml:"encoding,attr,omitempty"`
}

// Exp ...
type Exp *ExpType

// ExpType ...
type ExpType struct {
	XMLName           xml.Name    `xml:"exp"`
	XlinkHrefAttr     interface{} `xml:"xlink:href,attr,omitempty"`
	XlinkTypeAttr     string      `xml:"xlink:type,attr,omitempty"`
	ClassAttr         string      `xml:"class,attr,omitempty"`
	StyleAttr         string      `xml:"style,attr,omitempty"`
	IdAttr            string      `xml:"id,attr,omitempty"`
	XrefAttr          string      `xml:"xref,attr,omitempty"`
	OtherAttr         string      `xml:"other,attr,omitempty"`
	DefinitionURLAttr string      `xml:"definitionURL,attr,omitempty"`
	EncodingAttr      string      `xml:"encoding,attr,omitempty"`
}

// Factorial ...
type Factorial *FactorialType

// FactorialType ...
type FactorialType struct {
	XMLName           xml.Name    `xml:"factorial"`
	XlinkHrefAttr     interface{} `xml:"xlink:href,attr,omitempty"`
	XlinkTypeAttr     string      `xml:"xlink:type,attr,omitempty"`
	ClassAttr         string      `xml:"class,attr,omitempty"`
	StyleAttr         string      `xml:"style,attr,omitempty"`
	IdAttr            string      `xml:"id,attr,omitempty"`
	XrefAttr          string      `xml:"xref,attr,omitempty"`
	OtherAttr         string      `xml:"other,attr,omitempty"`
	DefinitionURLAttr string      `xml:"definitionURL,attr,omitempty"`
	EncodingAttr      string      `xml:"encoding,attr,omitempty"`
}

// Arg ...
type Arg *ArgType

// ArgType ...
type ArgType struct {
	XMLName           xml.Name    `xml:"arg"`
	XlinkHrefAttr     interface{} `xml:"xlink:href,attr,omitempty"`
	XlinkTypeAttr     string      `xml:"xlink:type,attr,omitempty"`
	ClassAttr         string      `xml:"class,attr,omitempty"`
	StyleAttr         string      `xml:"style,attr,omitempty"`
	IdAttr            string      `xml:"id,attr,omitempty"`
	XrefAttr          string      `xml:"xref,attr,omitempty"`
	OtherAttr         string      `xml:"other,attr,omitempty"`
	DefinitionURLAttr string      `xml:"definitionURL,attr,omitempty"`
	EncodingAttr      string      `xml:"encoding,attr,omitempty"`
}

// Real ...
type Real *RealType

// RealType ...
type RealType struct {
	XMLName           xml.Name    `xml:"real"`
	XlinkHrefAttr     interface{} `xml:"xlink:href,attr,omitempty"`
	XlinkTypeAttr     string      `xml:"xlink:type,attr,omitempty"`
	ClassAttr         string      `xml:"class,attr,omitempty"`
	StyleAttr         string      `xml:"style,attr,omitempty"`
	IdAttr            string      `xml:"id,attr,omitempty"`
	XrefAttr          string      `xml:"xref,attr,omitempty"`
	OtherAttr         string      `xml:"other,attr,omitempty"`
	DefinitionURLAttr string      `xml:"definitionURL,attr,omitempty"`
	EncodingAttr      string      `xml:"encoding,attr,omitempty"`
}

// Imaginary ...
type Imaginary *ImaginaryType

// ImaginaryType ...
type ImaginaryType struct {
	XMLName           xml.Name    `xml:"imaginary"`
	XlinkHrefAttr     interface{} `xml:"xlink:href,attr,omitempty"`
	XlinkTypeAttr     string      `xml:"xlink:type,attr,omitempty"`
	ClassAttr         string      `xml:"class,attr,omitempty"`
	StyleAttr         string      `xml:"style,attr,omitempty"`
	IdAttr            string      `xml:"id,attr,omitempty"`
	XrefAttr          string      `xml:"xref,attr,omitempty"`
	OtherAttr         string      `xml:"other,attr,omitempty"`
	DefinitionURLAttr string      `xml:"definitionURL,attr,omitempty"`
	EncodingAttr      string      `xml:"encoding,attr,omitempty"`
}

// Floor ...
type Floor *FloorType

// FloorType ...
type FloorType struct {
	XMLName           xml.Name    `xml:"floor"`
	XlinkHrefAttr     interface{} `xml:"xlink:href,attr,omitempty"`
	XlinkTypeAttr     string      `xml:"xlink:type,attr,omitempty"`
	ClassAttr         string      `xml:"class,attr,omitempty"`
	StyleAttr         string      `xml:"style,attr,omitempty"`
	IdAttr            string      `xml:"id,attr,omitempty"`
	XrefAttr          string      `xml:"xref,attr,omitempty"`
	OtherAttr         string      `xml:"other,attr,omitempty"`
	DefinitionURLAttr string      `xml:"definitionURL,attr,omitempty"`
	EncodingAttr      string      `xml:"encoding,attr,omitempty"`
}

// Ceiling ...
type Ceiling *CeilingType

// CeilingType ...
type CeilingType struct {
	XMLName           xml.Name    `xml:"ceiling"`
	XlinkHrefAttr     interface{} `xml:"xlink:href,attr,omitempty"`
	XlinkTypeAttr     string      `xml:"xlink:type,attr,omitempty"`
	ClassAttr         string      `xml:"class,attr,omitempty"`
	StyleAttr         string      `xml:"style,attr,omitempty"`
	IdAttr            string      `xml:"id,attr,omitempty"`
	XrefAttr          string      `xml:"xref,attr,omitempty"`
	OtherAttr         string      `xml:"other,attr,omitempty"`
	DefinitionURLAttr string      `xml:"definitionURL,attr,omitempty"`
	EncodingAttr      string      `xml:"encoding,attr,omitempty"`
}

// Not ...
type Not *NotType

// NotType ...
type NotType struct {
	XMLName           xml.Name    `xml:"not"`
	XlinkHrefAttr     interface{} `xml:"xlink:href,attr,omitempty"`
	XlinkTypeAttr     string      `xml:"xlink:type,attr,omitempty"`
	ClassAttr         string      `xml:"class,attr,omitempty"`
	StyleAttr         string      `xml:"style,attr,omitempty"`
	IdAttr            string      `xml:"id,attr,omitempty"`
	XrefAttr          string      `xml:"xref,attr,omitempty"`
	OtherAttr         string      `xml:"other,attr,omitempty"`
	DefinitionURLAttr string      `xml:"definitionURL,attr,omitempty"`
	EncodingAttr      string      `xml:"encoding,attr,omitempty"`
}

// Ln ...
type Ln *LnType

// LnType ...
type LnType struct {
	XMLName           xml.Name    `xml:"ln"`
	XlinkHrefAttr     interface{} `xml:"xlink:href,attr,omitempty"`
	XlinkTypeAttr     string      `xml:"xlink:type,attr,omitempty"`
	ClassAttr         string      `xml:"class,attr,omitempty"`
	StyleAttr         string      `xml:"style,attr,omitempty"`
	IdAttr            string      `xml:"id,attr,omitempty"`
	XrefAttr          string      `xml:"xref,attr,omitempty"`
	OtherAttr         string      `xml:"other,attr,omitempty"`
	DefinitionURLAttr string      `xml:"definitionURL,attr,omitempty"`
	EncodingAttr      string      `xml:"encoding,attr,omitempty"`
}

// Sin ...
type Sin *SinType

// SinType ...
type SinType struct {
	XMLName           xml.Name    `xml:"sin"`
	XlinkHrefAttr     interface{} `xml:"xlink:href,attr,omitempty"`
	XlinkTypeAttr     string      `xml:"xlink:type,attr,omitempty"`
	ClassAttr         string      `xml:"class,attr,omitempty"`
	StyleAttr         string      `xml:"style,attr,omitempty"`
	IdAttr            string      `xml:"id,attr,omitempty"`
	XrefAttr          string      `xml:"xref,attr,omitempty"`
	OtherAttr         string      `xml:"other,attr,omitempty"`
	DefinitionURLAttr string      `xml:"definitionURL,attr,omitempty"`
	EncodingAttr      string      `xml:"encoding,attr,omitempty"`
}

// Cos ...
type Cos *CosType

// CosType ...
type CosType struct {
	XMLName           xml.Name    `xml:"cos"`
	XlinkHrefAttr     interface{} `xml:"xlink:href,attr,omitempty"`
	XlinkTypeAttr     string      `xml:"xlink:type,attr,omitempty"`
	ClassAttr         string      `xml:"class,attr,omitempty"`
	StyleAttr         string      `xml:"style,attr,omitempty"`
	IdAttr            string      `xml:"id,attr,omitempty"`
	XrefAttr          string      `xml:"xref,attr,omitempty"`
	OtherAttr         string      `xml:"other,attr,omitempty"`
	DefinitionURLAttr string      `xml:"definitionURL,attr,omitempty"`
	EncodingAttr      string      `xml:"encoding,attr,omitempty"`
}

// Tan ...
type Tan *TanType

// TanType ...
type TanType struct {
	XMLName           xml.Name    `xml:"tan"`
	XlinkHrefAttr     interface{} `xml:"xlink:href,attr,omitempty"`
	XlinkTypeAttr     string      `xml:"xlink:type,attr,omitempty"`
	ClassAttr         string      `xml:"class,attr,omitempty"`
	StyleAttr         string      `xml:"style,attr,omitempty"`
	IdAttr            string      `xml:"id,attr,omitempty"`
	XrefAttr          string      `xml:"xref,attr,omitempty"`
	OtherAttr         string      `xml:"other,attr,omitempty"`
	DefinitionURLAttr string      `xml:"definitionURL,attr,omitempty"`
	EncodingAttr      string      `xml:"encoding,attr,omitempty"`
}

// Sec ...
type Sec *SecType

// SecType ...
type SecType struct {
	XMLName           xml.Name    `xml:"sec"`
	XlinkHrefAttr     interface{} `xml:"xlink:href,attr,omitempty"`
	XlinkTypeAttr     string      `xml:"xlink:type,attr,omitempty"`
	ClassAttr         string      `xml:"class,attr,omitempty"`
	StyleAttr         string      `xml:"style,attr,omitempty"`
	IdAttr            string      `xml:"id,attr,omitempty"`
	XrefAttr          string      `xml:"xref,attr,omitempty"`
	OtherAttr         string      `xml:"other,attr,omitempty"`
	DefinitionURLAttr string      `xml:"definitionURL,attr,omitempty"`
	EncodingAttr      string      `xml:"encoding,attr,omitempty"`
}

// Csc ...
type Csc *CscType

// CscType ...
type CscType struct {
	XMLName           xml.Name    `xml:"csc"`
	XlinkHrefAttr     interface{} `xml:"xlink:href,attr,omitempty"`
	XlinkTypeAttr     string      `xml:"xlink:type,attr,omitempty"`
	ClassAttr         string      `xml:"class,attr,omitempty"`
	StyleAttr         string      `xml:"style,attr,omitempty"`
	IdAttr            string      `xml:"id,attr,omitempty"`
	XrefAttr          string      `xml:"xref,attr,omitempty"`
	OtherAttr         string      `xml:"other,attr,omitempty"`
	DefinitionURLAttr string      `xml:"definitionURL,attr,omitempty"`
	EncodingAttr      string      `xml:"encoding,attr,omitempty"`
}

// Cot ...
type Cot *CotType

// CotType ...
type CotType struct {
	XMLName           xml.Name    `xml:"cot"`
	XlinkHrefAttr     interface{} `xml:"xlink:href,attr,omitempty"`
	XlinkTypeAttr     string      `xml:"xlink:type,attr,omitempty"`
	ClassAttr         string      `xml:"class,attr,omitempty"`
	StyleAttr         string      `xml:"style,attr,omitempty"`
	IdAttr            string      `xml:"id,attr,omitempty"`
	XrefAttr          string      `xml:"xref,attr,omitempty"`
	OtherAttr         string      `xml:"other,attr,omitempty"`
	DefinitionURLAttr string      `xml:"definitionURL,attr,omitempty"`
	EncodingAttr      string      `xml:"encoding,attr,omitempty"`
}

// Sinh ...
type Sinh *SinhType

// SinhType ...
type SinhType struct {
	XMLName           xml.Name    `xml:"sinh"`
	XlinkHrefAttr     interface{} `xml:"xlink:href,attr,omitempty"`
	XlinkTypeAttr     string      `xml:"xlink:type,attr,omitempty"`
	ClassAttr         string      `xml:"class,attr,omitempty"`
	StyleAttr         string      `xml:"style,attr,omitempty"`
	IdAttr            string      `xml:"id,attr,omitempty"`
	XrefAttr          string      `xml:"xref,attr,omitempty"`
	OtherAttr         string      `xml:"other,attr,omitempty"`
	DefinitionURLAttr string      `xml:"definitionURL,attr,omitempty"`
	EncodingAttr      string      `xml:"encoding,attr,omitempty"`
}

// Cosh ...
type Cosh *CoshType

// CoshType ...
type CoshType struct {
	XMLName           xml.Name    `xml:"cosh"`
	XlinkHrefAttr     interface{} `xml:"xlink:href,attr,omitempty"`
	XlinkTypeAttr     string      `xml:"xlink:type,attr,omitempty"`
	ClassAttr         string      `xml:"class,attr,omitempty"`
	StyleAttr         string      `xml:"style,attr,omitempty"`
	IdAttr            string      `xml:"id,attr,omitempty"`
	XrefAttr          string      `xml:"xref,attr,omitempty"`
	OtherAttr         string      `xml:"other,attr,omitempty"`
	DefinitionURLAttr string      `xml:"definitionURL,attr,omitempty"`
	EncodingAttr      string      `xml:"encoding,attr,omitempty"`
}

// Tanh ...
type Tanh *TanhType

// TanhType ...
type TanhType struct {
	XMLName           xml.Name    `xml:"tanh"`
	XlinkHrefAttr     interface{} `xml:"xlink:href,attr,omitempty"`
	XlinkTypeAttr     string      `xml:"xlink:type,attr,omitempty"`
	ClassAttr         string      `xml:"class,attr,omitempty"`
	StyleAttr         string      `xml:"style,attr,omitempty"`
	IdAttr            string      `xml:"id,attr,omitempty"`
	XrefAttr          string      `xml:"xref,attr,omitempty"`
	OtherAttr         string      `xml:"other,attr,omitempty"`
	DefinitionURLAttr string      `xml:"definitionURL,attr,omitempty"`
	EncodingAttr      string      `xml:"encoding,attr,omitempty"`
}

// Sech ...
type Sech *SechType

// SechType ...
type SechType struct {
	XMLName           xml.Name    `xml:"sech"`
	XlinkHrefAttr     interface{} `xml:"xlink:href,attr,omitempty"`
	XlinkTypeAttr     string      `xml:"xlink:type,attr,omitempty"`
	ClassAttr         string      `xml:"class,attr,omitempty"`
	StyleAttr         string      `xml:"style,attr,omitempty"`
	IdAttr            string      `xml:"id,attr,omitempty"`
	XrefAttr          string      `xml:"xref,attr,omitempty"`
	OtherAttr         string      `xml:"other,attr,omitempty"`
	DefinitionURLAttr string      `xml:"definitionURL,attr,omitempty"`
	EncodingAttr      string      `xml:"encoding,attr,omitempty"`
}

// Csch ...
type Csch *CschType

// CschType ...
type CschType struct {
	XMLName           xml.Name    `xml:"csch"`
	XlinkHrefAttr     interface{} `xml:"xlink:href,attr,omitempty"`
	XlinkTypeAttr     string      `xml:"xlink:type,attr,omitempty"`
	ClassAttr         string      `xml:"class,attr,omitempty"`
	StyleAttr         string      `xml:"style,attr,omitempty"`
	IdAttr            string      `xml:"id,attr,omitempty"`
	XrefAttr          string      `xml:"xref,attr,omitempty"`
	OtherAttr         string      `xml:"other,attr,omitempty"`
	DefinitionURLAttr string      `xml:"definitionURL,attr,omitempty"`
	EncodingAttr      string      `xml:"encoding,attr,omitempty"`
}

// Coth ...
type Coth *CothType

// CothType ...
type CothType struct {
	XMLName           xml.Name    `xml:"coth"`
	XlinkHrefAttr     interface{} `xml:"xlink:href,attr,omitempty"`
	XlinkTypeAttr     string      `xml:"xlink:type,attr,omitempty"`
	ClassAttr         string      `xml:"class,attr,omitempty"`
	StyleAttr         string      `xml:"style,attr,omitempty"`
	IdAttr            string      `xml:"id,attr,omitempty"`
	XrefAttr          string      `xml:"xref,attr,omitempty"`
	OtherAttr         string      `xml:"other,attr,omitempty"`
	DefinitionURLAttr string      `xml:"definitionURL,attr,omitempty"`
	EncodingAttr      string      `xml:"encoding,attr,omitempty"`
}

// Arcsin ...
type Arcsin *ArcsinType

// ArcsinType ...
type ArcsinType struct {
	XMLName           xml.Name    `xml:"arcsin"`
	XlinkHrefAttr     interface{} `xml:"xlink:href,attr,omitempty"`
	XlinkTypeAttr     string      `xml:"xlink:type,attr,omitempty"`
	ClassAttr         string      `xml:"class,attr,omitempty"`
	StyleAttr         string      `xml:"style,attr,omitempty"`
	IdAttr            string      `xml:"id,attr,omitempty"`
	XrefAttr          string      `xml:"xref,attr,omitempty"`
	OtherAttr         string      `xml:"other,attr,omitempty"`
	DefinitionURLAttr string      `xml:"definitionURL,attr,omitempty"`
	EncodingAttr      string      `xml:"encoding,attr,omitempty"`
}

// Arccos ...
type Arccos *ArccosType

// ArccosType ...
type ArccosType struct {
	XMLName           xml.Name    `xml:"arccos"`
	XlinkHrefAttr     interface{} `xml:"xlink:href,attr,omitempty"`
	XlinkTypeAttr     string      `xml:"xlink:type,attr,omitempty"`
	ClassAttr         string      `xml:"class,attr,omitempty"`
	StyleAttr         string      `xml:"style,attr,omitempty"`
	IdAttr            string      `xml:"id,attr,omitempty"`
	XrefAttr          string      `xml:"xref,attr,omitempty"`
	OtherAttr         string      `xml:"other,attr,omitempty"`
	DefinitionURLAttr string      `xml:"definitionURL,attr,omitempty"`
	EncodingAttr      string      `xml:"encoding,attr,omitempty"`
}

// Arctan ...
type Arctan *ArctanType

// ArctanType ...
type ArctanType struct {
	XMLName           xml.Name    `xml:"arctan"`
	XlinkHrefAttr     interface{} `xml:"xlink:href,attr,omitempty"`
	XlinkTypeAttr     string      `xml:"xlink:type,attr,omitempty"`
	ClassAttr         string      `xml:"class,attr,omitempty"`
	StyleAttr         string      `xml:"style,attr,omitempty"`
	IdAttr            string      `xml:"id,attr,omitempty"`
	XrefAttr          string      `xml:"xref,attr,omitempty"`
	OtherAttr         string      `xml:"other,attr,omitempty"`
	DefinitionURLAttr string      `xml:"definitionURL,attr,omitempty"`
	EncodingAttr      string      `xml:"encoding,attr,omitempty"`
}

// Arccosh ...
type Arccosh *ArccoshType

// ArccoshType ...
type ArccoshType struct {
	XMLName           xml.Name    `xml:"arccosh"`
	XlinkHrefAttr     interface{} `xml:"xlink:href,attr,omitempty"`
	XlinkTypeAttr     string      `xml:"xlink:type,attr,omitempty"`
	ClassAttr         string      `xml:"class,attr,omitempty"`
	StyleAttr         string      `xml:"style,attr,omitempty"`
	IdAttr            string      `xml:"id,attr,omitempty"`
	XrefAttr          string      `xml:"xref,attr,omitempty"`
	OtherAttr         string      `xml:"other,attr,omitempty"`
	DefinitionURLAttr string      `xml:"definitionURL,attr,omitempty"`
	EncodingAttr      string      `xml:"encoding,attr,omitempty"`
}

// Arccot ...
type Arccot *ArccotType

// ArccotType ...
type ArccotType struct {
	XMLName           xml.Name    `xml:"arccot"`
	XlinkHrefAttr     interface{} `xml:"xlink:href,attr,omitempty"`
	XlinkTypeAttr     string      `xml:"xlink:type,attr,omitempty"`
	ClassAttr         string      `xml:"class,attr,omitempty"`
	StyleAttr         string      `xml:"style,attr,omitempty"`
	IdAttr            string      `xml:"id,attr,omitempty"`
	XrefAttr          string      `xml:"xref,attr,omitempty"`
	OtherAttr         string      `xml:"other,attr,omitempty"`
	DefinitionURLAttr string      `xml:"definitionURL,attr,omitempty"`
	EncodingAttr      string      `xml:"encoding,attr,omitempty"`
}

// Arccoth ...
type Arccoth *ArccothType

// ArccothType ...
type ArccothType struct {
	XMLName           xml.Name    `xml:"arccoth"`
	XlinkHrefAttr     interface{} `xml:"xlink:href,attr,omitempty"`
	XlinkTypeAttr     string      `xml:"xlink:type,attr,omitempty"`
	ClassAttr         string      `xml:"class,attr,omitempty"`
	StyleAttr         string      `xml:"style,attr,omitempty"`
	IdAttr            string      `xml:"id,attr,omitempty"`
	XrefAttr          string      `xml:"xref,attr,omitempty"`
	OtherAttr         string      `xml:"other,attr,omitempty"`
	DefinitionURLAttr string      `xml:"definitionURL,attr,omitempty"`
	EncodingAttr      string      `xml:"encoding,attr,omitempty"`
}

// Arccsc ...
type Arccsc *ArccscType

// ArccscType ...
type ArccscType struct {
	XMLName           xml.Name    `xml:"arccsc"`
	XlinkHrefAttr     interface{} `xml:"xlink:href,attr,omitempty"`
	XlinkTypeAttr     string      `xml:"xlink:type,attr,omitempty"`
	ClassAttr         string      `xml:"class,attr,omitempty"`
	StyleAttr         string      `xml:"style,attr,omitempty"`
	IdAttr            string      `xml:"id,attr,omitempty"`
	XrefAttr          string      `xml:"xref,attr,omitempty"`
	OtherAttr         string      `xml:"other,attr,omitempty"`
	DefinitionURLAttr string      `xml:"definitionURL,attr,omitempty"`
	EncodingAttr      string      `xml:"encoding,attr,omitempty"`
}

// Arccsch ...
type Arccsch *ArccschType

// ArccschType ...
type ArccschType struct {
	XMLName           xml.Name    `xml:"arccsch"`
	XlinkHrefAttr     interface{} `xml:"xlink:href,attr,omitempty"`
	XlinkTypeAttr     string      `xml:"xlink:type,attr,omitempty"`
	ClassAttr         string      `xml:"class,attr,omitempty"`
	StyleAttr         string      `xml:"style,attr,omitempty"`
	IdAttr            string      `xml:"id,attr,omitempty"`
	XrefAttr          string      `xml:"xref,attr,omitempty"`
	OtherAttr         string      `xml:"other,attr,omitempty"`
	DefinitionURLAttr string      `xml:"definitionURL,attr,omitempty"`
	EncodingAttr      string      `xml:"encoding,attr,omitempty"`
}

// Arcsec ...
type Arcsec *ArcsecType

// ArcsecType ...
type ArcsecType struct {
	XMLName           xml.Name    `xml:"arcsec"`
	XlinkHrefAttr     interface{} `xml:"xlink:href,attr,omitempty"`
	XlinkTypeAttr     string      `xml:"xlink:type,attr,omitempty"`
	ClassAttr         string      `xml:"class,attr,omitempty"`
	StyleAttr         string      `xml:"style,attr,omitempty"`
	IdAttr            string      `xml:"id,attr,omitempty"`
	XrefAttr          string      `xml:"xref,attr,omitempty"`
	OtherAttr         string      `xml:"other,attr,omitempty"`
	DefinitionURLAttr string      `xml:"definitionURL,attr,omitempty"`
	EncodingAttr      string      `xml:"encoding,attr,omitempty"`
}

// Arcsech ...
type Arcsech *ArcsechType

// ArcsechType ...
type ArcsechType struct {
	XMLName           xml.Name    `xml:"arcsech"`
	XlinkHrefAttr     interface{} `xml:"xlink:href,attr,omitempty"`
	XlinkTypeAttr     string      `xml:"xlink:type,attr,omitempty"`
	ClassAttr         string      `xml:"class,attr,omitempty"`
	StyleAttr         string      `xml:"style,attr,omitempty"`
	IdAttr            string      `xml:"id,attr,omitempty"`
	XrefAttr          string      `xml:"xref,attr,omitempty"`
	OtherAttr         string      `xml:"other,attr,omitempty"`
	DefinitionURLAttr string      `xml:"definitionURL,attr,omitempty"`
	EncodingAttr      string      `xml:"encoding,attr,omitempty"`
}

// Arcsinh ...
type Arcsinh *ArcsinhType

// ArcsinhType ...
type ArcsinhType struct {
	XMLName           xml.Name    `xml:"arcsinh"`
	XlinkHrefAttr     interface{} `xml:"xlink:href,attr,omitempty"`
	XlinkTypeAttr     string      `xml:"xlink:type,attr,omitempty"`
	ClassAttr         string      `xml:"class,attr,omitempty"`
	StyleAttr         string      `xml:"style,attr,omitempty"`
	IdAttr            string      `xml:"id,attr,omitempty"`
	XrefAttr          string      `xml:"xref,attr,omitempty"`
	OtherAttr         string      `xml:"other,attr,omitempty"`
	DefinitionURLAttr string      `xml:"definitionURL,attr,omitempty"`
	EncodingAttr      string      `xml:"encoding,attr,omitempty"`
}

// Arctanh ...
type Arctanh *ArctanhType

// ArctanhType ...
type ArctanhType struct {
	XMLName           xml.Name    `xml:"arctanh"`
	XlinkHrefAttr     interface{} `xml:"xlink:href,attr,omitempty"`
	XlinkTypeAttr     string      `xml:"xlink:type,attr,omitempty"`
	ClassAttr         string      `xml:"class,attr,omitempty"`
	StyleAttr         string      `xml:"style,attr,omitempty"`
	IdAttr            string      `xml:"id,attr,omitempty"`
	XrefAttr          string      `xml:"xref,attr,omitempty"`
	OtherAttr         string      `xml:"other,attr,omitempty"`
	DefinitionURLAttr string      `xml:"definitionURL,attr,omitempty"`
	EncodingAttr      string      `xml:"encoding,attr,omitempty"`
}

// Determinant ...
type Determinant *DeterminantType

// DeterminantType ...
type DeterminantType struct {
	XMLName           xml.Name    `xml:"determinant"`
	XlinkHrefAttr     interface{} `xml:"xlink:href,attr,omitempty"`
	XlinkTypeAttr     string      `xml:"xlink:type,attr,omitempty"`
	ClassAttr         string      `xml:"class,attr,omitempty"`
	StyleAttr         string      `xml:"style,attr,omitempty"`
	IdAttr            string      `xml:"id,attr,omitempty"`
	XrefAttr          string      `xml:"xref,attr,omitempty"`
	OtherAttr         string      `xml:"other,attr,omitempty"`
	DefinitionURLAttr string      `xml:"definitionURL,attr,omitempty"`
	EncodingAttr      string      `xml:"encoding,attr,omitempty"`
}

// Transpose ...
type Transpose *TransposeType

// TransposeType ...
type TransposeType struct {
	XMLName           xml.Name    `xml:"transpose"`
	XlinkHrefAttr     interface{} `xml:"xlink:href,attr,omitempty"`
	XlinkTypeAttr     string      `xml:"xlink:type,attr,omitempty"`
	ClassAttr         string      `xml:"class,attr,omitempty"`
	StyleAttr         string      `xml:"style,attr,omitempty"`
	IdAttr            string      `xml:"id,attr,omitempty"`
	XrefAttr          string      `xml:"xref,attr,omitempty"`
	OtherAttr         string      `xml:"other,attr,omitempty"`
	DefinitionURLAttr string      `xml:"definitionURL,attr,omitempty"`
	EncodingAttr      string      `xml:"encoding,attr,omitempty"`
}

// Card ...
type Card *CardType

// CardType ...
type CardType struct {
	XMLName           xml.Name    `xml:"card"`
	XlinkHrefAttr     interface{} `xml:"xlink:href,attr,omitempty"`
	XlinkTypeAttr     string      `xml:"xlink:type,attr,omitempty"`
	ClassAttr         string      `xml:"class,attr,omitempty"`
	StyleAttr         string      `xml:"style,attr,omitempty"`
	IdAttr            string      `xml:"id,attr,omitempty"`
	XrefAttr          string      `xml:"xref,attr,omitempty"`
	OtherAttr         string      `xml:"other,attr,omitempty"`
	DefinitionURLAttr string      `xml:"definitionURL,attr,omitempty"`
	EncodingAttr      string      `xml:"encoding,attr,omitempty"`
}

// Quotient ...
type Quotient *QuotientType

// QuotientType ...
type QuotientType struct {
	XMLName           xml.Name    `xml:"quotient"`
	XlinkHrefAttr     interface{} `xml:"xlink:href,attr,omitempty"`
	XlinkTypeAttr     string      `xml:"xlink:type,attr,omitempty"`
	ClassAttr         string      `xml:"class,attr,omitempty"`
	StyleAttr         string      `xml:"style,attr,omitempty"`
	IdAttr            string      `xml:"id,attr,omitempty"`
	XrefAttr          string      `xml:"xref,attr,omitempty"`
	OtherAttr         string      `xml:"other,attr,omitempty"`
	DefinitionURLAttr string      `xml:"definitionURL,attr,omitempty"`
	EncodingAttr      string      `xml:"encoding,attr,omitempty"`
}

// Divide ...
type Divide *DivideType

// DivideType ...
type DivideType struct {
	XMLName           xml.Name    `xml:"divide"`
	XlinkHrefAttr     interface{} `xml:"xlink:href,attr,omitempty"`
	XlinkTypeAttr     string      `xml:"xlink:type,attr,omitempty"`
	ClassAttr         string      `xml:"class,attr,omitempty"`
	StyleAttr         string      `xml:"style,attr,omitempty"`
	IdAttr            string      `xml:"id,attr,omitempty"`
	XrefAttr          string      `xml:"xref,attr,omitempty"`
	OtherAttr         string      `xml:"other,attr,omitempty"`
	DefinitionURLAttr string      `xml:"definitionURL,attr,omitempty"`
	EncodingAttr      string      `xml:"encoding,attr,omitempty"`
}

// Power ...
type Power *PowerType

// PowerType ...
type PowerType struct {
	XMLName           xml.Name    `xml:"power"`
	XlinkHrefAttr     interface{} `xml:"xlink:href,attr,omitempty"`
	XlinkTypeAttr     string      `xml:"xlink:type,attr,omitempty"`
	ClassAttr         string      `xml:"class,attr,omitempty"`
	StyleAttr         string      `xml:"style,attr,omitempty"`
	IdAttr            string      `xml:"id,attr,omitempty"`
	XrefAttr          string      `xml:"xref,attr,omitempty"`
	OtherAttr         string      `xml:"other,attr,omitempty"`
	DefinitionURLAttr string      `xml:"definitionURL,attr,omitempty"`
	EncodingAttr      string      `xml:"encoding,attr,omitempty"`
}

// Rem ...
type Rem *RemType

// RemType ...
type RemType struct {
	XMLName           xml.Name    `xml:"rem"`
	XlinkHrefAttr     interface{} `xml:"xlink:href,attr,omitempty"`
	XlinkTypeAttr     string      `xml:"xlink:type,attr,omitempty"`
	ClassAttr         string      `xml:"class,attr,omitempty"`
	StyleAttr         string      `xml:"style,attr,omitempty"`
	IdAttr            string      `xml:"id,attr,omitempty"`
	XrefAttr          string      `xml:"xref,attr,omitempty"`
	OtherAttr         string      `xml:"other,attr,omitempty"`
	DefinitionURLAttr string      `xml:"definitionURL,attr,omitempty"`
	EncodingAttr      string      `xml:"encoding,attr,omitempty"`
}

// Implies ...
type Implies *ImpliesType

// ImpliesType ...
type ImpliesType struct {
	XMLName           xml.Name    `xml:"implies"`
	XlinkHrefAttr     interface{} `xml:"xlink:href,attr,omitempty"`
	XlinkTypeAttr     string      `xml:"xlink:type,attr,omitempty"`
	ClassAttr         string      `xml:"class,attr,omitempty"`
	StyleAttr         string      `xml:"style,attr,omitempty"`
	IdAttr            string      `xml:"id,attr,omitempty"`
	XrefAttr          string      `xml:"xref,attr,omitempty"`
	OtherAttr         string      `xml:"other,attr,omitempty"`
	DefinitionURLAttr string      `xml:"definitionURL,attr,omitempty"`
	EncodingAttr      string      `xml:"encoding,attr,omitempty"`
}

// Vectorproduct ...
type Vectorproduct *VectorproductType

// VectorproductType ...
type VectorproductType struct {
	XMLName           xml.Name    `xml:"vectorproduct"`
	XlinkHrefAttr     interface{} `xml:"xlink:href,attr,omitempty"`
	XlinkTypeAttr     string      `xml:"xlink:type,attr,omitempty"`
	ClassAttr         string      `xml:"class,attr,omitempty"`
	StyleAttr         string      `xml:"style,attr,omitempty"`
	IdAttr            string      `xml:"id,attr,omitempty"`
	XrefAttr          string      `xml:"xref,attr,omitempty"`
	OtherAttr         string      `xml:"other,attr,omitempty"`
	DefinitionURLAttr string      `xml:"definitionURL,attr,omitempty"`
	EncodingAttr      string      `xml:"encoding,attr,omitempty"`
}

// Scalarproduct ...
type Scalarproduct *ScalarproductType

// ScalarproductType ...
type ScalarproductType struct {
	XMLName           xml.Name    `xml:"scalarproduct"`
	XlinkHrefAttr     interface{} `xml:"xlink:href,attr,omitempty"`
	XlinkTypeAttr     string      `xml:"xlink:type,attr,omitempty"`
	ClassAttr         string      `xml:"class,attr,omitempty"`
	StyleAttr         string      `xml:"style,attr,omitempty"`
	IdAttr            string      `xml:"id,attr,omitempty"`
	XrefAttr          string      `xml:"xref,attr,omitempty"`
	OtherAttr         string      `xml:"other,attr,omitempty"`
	DefinitionURLAttr string      `xml:"definitionURL,attr,omitempty"`
	EncodingAttr      string      `xml:"encoding,attr,omitempty"`
}

// Outerproduct ...
type Outerproduct *OuterproductType

// OuterproductType ...
type OuterproductType struct {
	XMLName           xml.Name    `xml:"outerproduct"`
	XlinkHrefAttr     interface{} `xml:"xlink:href,attr,omitempty"`
	XlinkTypeAttr     string      `xml:"xlink:type,attr,omitempty"`
	ClassAttr         string      `xml:"class,attr,omitempty"`
	StyleAttr         string      `xml:"style,attr,omitempty"`
	IdAttr            string      `xml:"id,attr,omitempty"`
	XrefAttr          string      `xml:"xref,attr,omitempty"`
	OtherAttr         string      `xml:"other,attr,omitempty"`
	DefinitionURLAttr string      `xml:"definitionURL,attr,omitempty"`
	EncodingAttr      string      `xml:"encoding,attr,omitempty"`
}

// Setdiff ...
type Setdiff *SetdiffType

// SetdiffType ...
type SetdiffType struct {
	XMLName           xml.Name    `xml:"setdiff"`
	XlinkHrefAttr     interface{} `xml:"xlink:href,attr,omitempty"`
	XlinkTypeAttr     string      `xml:"xlink:type,attr,omitempty"`
	ClassAttr         string      `xml:"class,attr,omitempty"`
	StyleAttr         string      `xml:"style,attr,omitempty"`
	IdAttr            string      `xml:"id,attr,omitempty"`
	XrefAttr          string      `xml:"xref,attr,omitempty"`
	OtherAttr         string      `xml:"other,attr,omitempty"`
	DefinitionURLAttr string      `xml:"definitionURL,attr,omitempty"`
	EncodingAttr      string      `xml:"encoding,attr,omitempty"`
}

// Fn ...
type Fn *FnType

// FnType ...
type FnType struct {
	XMLName               xml.Name    `xml:"fn"`
	XlinkHrefAttr         interface{} `xml:"xlink:href,attr,omitempty"`
	XlinkTypeAttr         string      `xml:"xlink:type,attr,omitempty"`
	ClassAttr             string      `xml:"class,attr,omitempty"`
	StyleAttr             string      `xml:"style,attr,omitempty"`
	IdAttr                string      `xml:"id,attr,omitempty"`
	XrefAttr              string      `xml:"xref,attr,omitempty"`
	OtherAttr             string      `xml:"other,attr,omitempty"`
	DefinitionURLAttr     string      `xml:"definitionURL,attr,omitempty"`
	EncodingAttr          string      `xml:"encoding,attr,omitempty"`
	ExchContentExpression []*ContentExpression
}

// Compose ...
type Compose *ComposeType

// ComposeType ...
type ComposeType struct {
	XMLName           xml.Name    `xml:"compose"`
	XlinkHrefAttr     interface{} `xml:"xlink:href,attr,omitempty"`
	XlinkTypeAttr     string      `xml:"xlink:type,attr,omitempty"`
	ClassAttr         string      `xml:"class,attr,omitempty"`
	StyleAttr         string      `xml:"style,attr,omitempty"`
	IdAttr            string      `xml:"id,attr,omitempty"`
	XrefAttr          string      `xml:"xref,attr,omitempty"`
	OtherAttr         string      `xml:"other,attr,omitempty"`
	DefinitionURLAttr string      `xml:"definitionURL,attr,omitempty"`
	EncodingAttr      string      `xml:"encoding,attr,omitempty"`
}

// Plus ...
type Plus *PlusType

// PlusType ...
type PlusType struct {
	XMLName           xml.Name    `xml:"plus"`
	XlinkHrefAttr     interface{} `xml:"xlink:href,attr,omitempty"`
	XlinkTypeAttr     string      `xml:"xlink:type,attr,omitempty"`
	ClassAttr         string      `xml:"class,attr,omitempty"`
	StyleAttr         string      `xml:"style,attr,omitempty"`
	IdAttr            string      `xml:"id,attr,omitempty"`
	XrefAttr          string      `xml:"xref,attr,omitempty"`
	OtherAttr         string      `xml:"other,attr,omitempty"`
	DefinitionURLAttr string      `xml:"definitionURL,attr,omitempty"`
	EncodingAttr      string      `xml:"encoding,attr,omitempty"`
}

// Times ...
type Times *TimesType

// TimesType ...
type TimesType struct {
	XMLName           xml.Name    `xml:"times"`
	XlinkHrefAttr     interface{} `xml:"xlink:href,attr,omitempty"`
	XlinkTypeAttr     string      `xml:"xlink:type,attr,omitempty"`
	ClassAttr         string      `xml:"class,attr,omitempty"`
	StyleAttr         string      `xml:"style,attr,omitempty"`
	IdAttr            string      `xml:"id,attr,omitempty"`
	XrefAttr          string      `xml:"xref,attr,omitempty"`
	OtherAttr         string      `xml:"other,attr,omitempty"`
	DefinitionURLAttr string      `xml:"definitionURL,attr,omitempty"`
	EncodingAttr      string      `xml:"encoding,attr,omitempty"`
}

// Max ...
type Max *MaxType

// MaxType ...
type MaxType struct {
	XMLName           xml.Name    `xml:"max"`
	XlinkHrefAttr     interface{} `xml:"xlink:href,attr,omitempty"`
	XlinkTypeAttr     string      `xml:"xlink:type,attr,omitempty"`
	ClassAttr         string      `xml:"class,attr,omitempty"`
	StyleAttr         string      `xml:"style,attr,omitempty"`
	IdAttr            string      `xml:"id,attr,omitempty"`
	XrefAttr          string      `xml:"xref,attr,omitempty"`
	OtherAttr         string      `xml:"other,attr,omitempty"`
	DefinitionURLAttr string      `xml:"definitionURL,attr,omitempty"`
	EncodingAttr      string      `xml:"encoding,attr,omitempty"`
}

// Min ...
type Min *MinType

// MinType ...
type MinType struct {
	XMLName           xml.Name    `xml:"min"`
	XlinkHrefAttr     interface{} `xml:"xlink:href,attr,omitempty"`
	XlinkTypeAttr     string      `xml:"xlink:type,attr,omitempty"`
	ClassAttr         string      `xml:"class,attr,omitempty"`
	StyleAttr         string      `xml:"style,attr,omitempty"`
	IdAttr            string      `xml:"id,attr,omitempty"`
	XrefAttr          string      `xml:"xref,attr,omitempty"`
	OtherAttr         string      `xml:"other,attr,omitempty"`
	DefinitionURLAttr string      `xml:"definitionURL,attr,omitempty"`
	EncodingAttr      string      `xml:"encoding,attr,omitempty"`
}

// Gcd ...
type Gcd *GcdType

// GcdType ...
type GcdType struct {
	XMLName           xml.Name    `xml:"gcd"`
	XlinkHrefAttr     interface{} `xml:"xlink:href,attr,omitempty"`
	XlinkTypeAttr     string      `xml:"xlink:type,attr,omitempty"`
	ClassAttr         string      `xml:"class,attr,omitempty"`
	StyleAttr         string      `xml:"style,attr,omitempty"`
	IdAttr            string      `xml:"id,attr,omitempty"`
	XrefAttr          string      `xml:"xref,attr,omitempty"`
	OtherAttr         string      `xml:"other,attr,omitempty"`
	DefinitionURLAttr string      `xml:"definitionURL,attr,omitempty"`
	EncodingAttr      string      `xml:"encoding,attr,omitempty"`
}

// Lcm ...
type Lcm *LcmType

// LcmType ...
type LcmType struct {
	XMLName           xml.Name    `xml:"lcm"`
	XlinkHrefAttr     interface{} `xml:"xlink:href,attr,omitempty"`
	XlinkTypeAttr     string      `xml:"xlink:type,attr,omitempty"`
	ClassAttr         string      `xml:"class,attr,omitempty"`
	StyleAttr         string      `xml:"style,attr,omitempty"`
	IdAttr            string      `xml:"id,attr,omitempty"`
	XrefAttr          string      `xml:"xref,attr,omitempty"`
	OtherAttr         string      `xml:"other,attr,omitempty"`
	DefinitionURLAttr string      `xml:"definitionURL,attr,omitempty"`
	EncodingAttr      string      `xml:"encoding,attr,omitempty"`
}

// And ...
type And *AndType

// AndType ...
type AndType struct {
	XMLName           xml.Name    `xml:"and"`
	XlinkHrefAttr     interface{} `xml:"xlink:href,attr,omitempty"`
	XlinkTypeAttr     string      `xml:"xlink:type,attr,omitempty"`
	ClassAttr         string      `xml:"class,attr,omitempty"`
	StyleAttr         string      `xml:"style,attr,omitempty"`
	IdAttr            string      `xml:"id,attr,omitempty"`
	XrefAttr          string      `xml:"xref,attr,omitempty"`
	OtherAttr         string      `xml:"other,attr,omitempty"`
	DefinitionURLAttr string      `xml:"definitionURL,attr,omitempty"`
	EncodingAttr      string      `xml:"encoding,attr,omitempty"`
}

// Or ...
type Or *OrType

// OrType ...
type OrType struct {
	XMLName           xml.Name    `xml:"or"`
	XlinkHrefAttr     interface{} `xml:"xlink:href,attr,omitempty"`
	XlinkTypeAttr     string      `xml:"xlink:type,attr,omitempty"`
	ClassAttr         string      `xml:"class,attr,omitempty"`
	StyleAttr         string      `xml:"style,attr,omitempty"`
	IdAttr            string      `xml:"id,attr,omitempty"`
	XrefAttr          string      `xml:"xref,attr,omitempty"`
	OtherAttr         string      `xml:"other,attr,omitempty"`
	DefinitionURLAttr string      `xml:"definitionURL,attr,omitempty"`
	EncodingAttr      string      `xml:"encoding,attr,omitempty"`
}

// Xor ...
type Xor *XorType

// XorType ...
type XorType struct {
	XMLName           xml.Name    `xml:"xor"`
	XlinkHrefAttr     interface{} `xml:"xlink:href,attr,omitempty"`
	XlinkTypeAttr     string      `xml:"xlink:type,attr,omitempty"`
	ClassAttr         string      `xml:"class,attr,omitempty"`
	StyleAttr         string      `xml:"style,attr,omitempty"`
	IdAttr            string      `xml:"id,attr,omitempty"`
	XrefAttr          string      `xml:"xref,attr,omitempty"`
	OtherAttr         string      `xml:"other,attr,omitempty"`
	DefinitionURLAttr string      `xml:"definitionURL,attr,omitempty"`
	EncodingAttr      string      `xml:"encoding,attr,omitempty"`
}

// Union ...
type Union *UnionType

// UnionType ...
type UnionType struct {
	XMLName           xml.Name    `xml:"union"`
	XlinkHrefAttr     interface{} `xml:"xlink:href,attr,omitempty"`
	XlinkTypeAttr     string      `xml:"xlink:type,attr,omitempty"`
	ClassAttr         string      `xml:"class,attr,omitempty"`
	StyleAttr         string      `xml:"style,attr,omitempty"`
	IdAttr            string      `xml:"id,attr,omitempty"`
	XrefAttr          string      `xml:"xref,attr,omitempty"`
	OtherAttr         string      `xml:"other,attr,omitempty"`
	DefinitionURLAttr string      `xml:"definitionURL,attr,omitempty"`
	EncodingAttr      string      `xml:"encoding,attr,omitempty"`
}

// Intersect ...
type Intersect *IntersectType

// IntersectType ...
type IntersectType struct {
	XMLName           xml.Name    `xml:"intersect"`
	XlinkHrefAttr     interface{} `xml:"xlink:href,attr,omitempty"`
	XlinkTypeAttr     string      `xml:"xlink:type,attr,omitempty"`
	ClassAttr         string      `xml:"class,attr,omitempty"`
	StyleAttr         string      `xml:"style,attr,omitempty"`
	IdAttr            string      `xml:"id,attr,omitempty"`
	XrefAttr          string      `xml:"xref,attr,omitempty"`
	OtherAttr         string      `xml:"other,attr,omitempty"`
	DefinitionURLAttr string      `xml:"definitionURL,attr,omitempty"`
	EncodingAttr      string      `xml:"encoding,attr,omitempty"`
}

// Cartesianproduct ...
type Cartesianproduct *CartesianproductType

// CartesianproductType ...
type CartesianproductType struct {
	XMLName           xml.Name    `xml:"cartesianproduct"`
	XlinkHrefAttr     interface{} `xml:"xlink:href,attr,omitempty"`
	XlinkTypeAttr     string      `xml:"xlink:type,attr,omitempty"`
	ClassAttr         string      `xml:"class,attr,omitempty"`
	StyleAttr         string      `xml:"style,attr,omitempty"`
	IdAttr            string      `xml:"id,attr,omitempty"`
	XrefAttr          string      `xml:"xref,attr,omitempty"`
	OtherAttr         string      `xml:"other,attr,omitempty"`
	DefinitionURLAttr string      `xml:"definitionURL,attr,omitempty"`
	EncodingAttr      string      `xml:"encoding,attr,omitempty"`
}

// Mean ...
type Mean *MeanType

// MeanType ...
type MeanType struct {
	XMLName           xml.Name    `xml:"mean"`
	XlinkHrefAttr     interface{} `xml:"xlink:href,attr,omitempty"`
	XlinkTypeAttr     string      `xml:"xlink:type,attr,omitempty"`
	ClassAttr         string      `xml:"class,attr,omitempty"`
	StyleAttr         string      `xml:"style,attr,omitempty"`
	IdAttr            string      `xml:"id,attr,omitempty"`
	XrefAttr          string      `xml:"xref,attr,omitempty"`
	OtherAttr         string      `xml:"other,attr,omitempty"`
	DefinitionURLAttr string      `xml:"definitionURL,attr,omitempty"`
	EncodingAttr      string      `xml:"encoding,attr,omitempty"`
}

// Sdev ...
type Sdev *SdevType

// SdevType ...
type SdevType struct {
	XMLName           xml.Name    `xml:"sdev"`
	XlinkHrefAttr     interface{} `xml:"xlink:href,attr,omitempty"`
	XlinkTypeAttr     string      `xml:"xlink:type,attr,omitempty"`
	ClassAttr         string      `xml:"class,attr,omitempty"`
	StyleAttr         string      `xml:"style,attr,omitempty"`
	IdAttr            string      `xml:"id,attr,omitempty"`
	XrefAttr          string      `xml:"xref,attr,omitempty"`
	OtherAttr         string      `xml:"other,attr,omitempty"`
	DefinitionURLAttr string      `xml:"definitionURL,attr,omitempty"`
	EncodingAttr      string      `xml:"encoding,attr,omitempty"`
}

// Variance ...
type Variance *VarianceType

// VarianceType ...
type VarianceType struct {
	XMLName           xml.Name    `xml:"variance"`
	XlinkHrefAttr     interface{} `xml:"xlink:href,attr,omitempty"`
	XlinkTypeAttr     string      `xml:"xlink:type,attr,omitempty"`
	ClassAttr         string      `xml:"class,attr,omitempty"`
	StyleAttr         string      `xml:"style,attr,omitempty"`
	IdAttr            string      `xml:"id,attr,omitempty"`
	XrefAttr          string      `xml:"xref,attr,omitempty"`
	OtherAttr         string      `xml:"other,attr,omitempty"`
	DefinitionURLAttr string      `xml:"definitionURL,attr,omitempty"`
	EncodingAttr      string      `xml:"encoding,attr,omitempty"`
}

// Median ...
type Median *MedianType

// MedianType ...
type MedianType struct {
	XMLName           xml.Name    `xml:"median"`
	XlinkHrefAttr     interface{} `xml:"xlink:href,attr,omitempty"`
	XlinkTypeAttr     string      `xml:"xlink:type,attr,omitempty"`
	ClassAttr         string      `xml:"class,attr,omitempty"`
	StyleAttr         string      `xml:"style,attr,omitempty"`
	IdAttr            string      `xml:"id,attr,omitempty"`
	XrefAttr          string      `xml:"xref,attr,omitempty"`
	OtherAttr         string      `xml:"other,attr,omitempty"`
	DefinitionURLAttr string      `xml:"definitionURL,attr,omitempty"`
	EncodingAttr      string      `xml:"encoding,attr,omitempty"`
}

// Mode ...
type Mode *ModeType

// ModeType ...
type ModeType struct {
	XMLName           xml.Name    `xml:"mode"`
	XlinkHrefAttr     interface{} `xml:"xlink:href,attr,omitempty"`
	XlinkTypeAttr     string      `xml:"xlink:type,attr,omitempty"`
	ClassAttr         string      `xml:"class,attr,omitempty"`
	StyleAttr         string      `xml:"style,attr,omitempty"`
	IdAttr            string      `xml:"id,attr,omitempty"`
	XrefAttr          string      `xml:"xref,attr,omitempty"`
	OtherAttr         string      `xml:"other,attr,omitempty"`
	DefinitionURLAttr string      `xml:"definitionURL,attr,omitempty"`
	EncodingAttr      string      `xml:"encoding,attr,omitempty"`
}

// Selector ...
type Selector *SelectorType

// SelectorType ...
type SelectorType struct {
	XMLName           xml.Name    `xml:"selector"`
	XlinkHrefAttr     interface{} `xml:"xlink:href,attr,omitempty"`
	XlinkTypeAttr     string      `xml:"xlink:type,attr,omitempty"`
	ClassAttr         string      `xml:"class,attr,omitempty"`
	StyleAttr         string      `xml:"style,attr,omitempty"`
	IdAttr            string      `xml:"id,attr,omitempty"`
	XrefAttr          string      `xml:"xref,attr,omitempty"`
	OtherAttr         string      `xml:"other,attr,omitempty"`
	DefinitionURLAttr string      `xml:"definitionURL,attr,omitempty"`
	EncodingAttr      string      `xml:"encoding,attr,omitempty"`
}

// Root ...
type Root *RootType

// RootType ...
type RootType struct {
	XMLName           xml.Name    `xml:"root"`
	XlinkHrefAttr     interface{} `xml:"xlink:href,attr,omitempty"`
	XlinkTypeAttr     string      `xml:"xlink:type,attr,omitempty"`
	ClassAttr         string      `xml:"class,attr,omitempty"`
	StyleAttr         string      `xml:"style,attr,omitempty"`
	IdAttr            string      `xml:"id,attr,omitempty"`
	XrefAttr          string      `xml:"xref,attr,omitempty"`
	OtherAttr         string      `xml:"other,attr,omitempty"`
	DefinitionURLAttr string      `xml:"definitionURL,attr,omitempty"`
	EncodingAttr      string      `xml:"encoding,attr,omitempty"`
}

// Minus ...
type Minus *MinusType

// MinusType ...
type MinusType struct {
	XMLName           xml.Name    `xml:"minus"`
	XlinkHrefAttr     interface{} `xml:"xlink:href,attr,omitempty"`
	XlinkTypeAttr     string      `xml:"xlink:type,attr,omitempty"`
	ClassAttr         string      `xml:"class,attr,omitempty"`
	StyleAttr         string      `xml:"style,attr,omitempty"`
	IdAttr            string      `xml:"id,attr,omitempty"`
	XrefAttr          string      `xml:"xref,attr,omitempty"`
	OtherAttr         string      `xml:"other,attr,omitempty"`
	DefinitionURLAttr string      `xml:"definitionURL,attr,omitempty"`
	EncodingAttr      string      `xml:"encoding,attr,omitempty"`
}

// Log ...
type Log *LogType

// LogType ...
type LogType struct {
	XMLName           xml.Name    `xml:"log"`
	XlinkHrefAttr     interface{} `xml:"xlink:href,attr,omitempty"`
	XlinkTypeAttr     string      `xml:"xlink:type,attr,omitempty"`
	ClassAttr         string      `xml:"class,attr,omitempty"`
	StyleAttr         string      `xml:"style,attr,omitempty"`
	IdAttr            string      `xml:"id,attr,omitempty"`
	XrefAttr          string      `xml:"xref,attr,omitempty"`
	OtherAttr         string      `xml:"other,attr,omitempty"`
	DefinitionURLAttr string      `xml:"definitionURL,attr,omitempty"`
	EncodingAttr      string      `xml:"encoding,attr,omitempty"`
}

// Int ...
type Int *IntType

// IntType ...
type IntType string

// Diff ...
type Diff *DiffType

// DiffType ...
type DiffType struct {
	XMLName           xml.Name    `xml:"diff"`
	XlinkHrefAttr     interface{} `xml:"xlink:href,attr,omitempty"`
	XlinkTypeAttr     string      `xml:"xlink:type,attr,omitempty"`
	ClassAttr         string      `xml:"class,attr,omitempty"`
	StyleAttr         string      `xml:"style,attr,omitempty"`
	IdAttr            string      `xml:"id,attr,omitempty"`
	XrefAttr          string      `xml:"xref,attr,omitempty"`
	OtherAttr         string      `xml:"other,attr,omitempty"`
	DefinitionURLAttr string      `xml:"definitionURL,attr,omitempty"`
	EncodingAttr      string      `xml:"encoding,attr,omitempty"`
}

// Partialdiff ...
type Partialdiff *PartialdiffType

// PartialdiffType ...
type PartialdiffType struct {
	XMLName           xml.Name    `xml:"partialdiff"`
	XlinkHrefAttr     interface{} `xml:"xlink:href,attr,omitempty"`
	XlinkTypeAttr     string      `xml:"xlink:type,attr,omitempty"`
	ClassAttr         string      `xml:"class,attr,omitempty"`
	StyleAttr         string      `xml:"style,attr,omitempty"`
	IdAttr            string      `xml:"id,attr,omitempty"`
	XrefAttr          string      `xml:"xref,attr,omitempty"`
	OtherAttr         string      `xml:"other,attr,omitempty"`
	DefinitionURLAttr string      `xml:"definitionURL,attr,omitempty"`
	EncodingAttr      string      `xml:"encoding,attr,omitempty"`
}

// Divergence ...
type Divergence *DivergenceType

// DivergenceType ...
type DivergenceType struct {
	XMLName           xml.Name    `xml:"divergence"`
	XlinkHrefAttr     interface{} `xml:"xlink:href,attr,omitempty"`
	XlinkTypeAttr     string      `xml:"xlink:type,attr,omitempty"`
	ClassAttr         string      `xml:"class,attr,omitempty"`
	StyleAttr         string      `xml:"style,attr,omitempty"`
	IdAttr            string      `xml:"id,attr,omitempty"`
	XrefAttr          string      `xml:"xref,attr,omitempty"`
	OtherAttr         string      `xml:"other,attr,omitempty"`
	DefinitionURLAttr string      `xml:"definitionURL,attr,omitempty"`
	EncodingAttr      string      `xml:"encoding,attr,omitempty"`
}

// Grad ...
type Grad *GradType

// GradType ...
type GradType struct {
	XMLName           xml.Name    `xml:"grad"`
	XlinkHrefAttr     interface{} `xml:"xlink:href,attr,omitempty"`
	XlinkTypeAttr     string      `xml:"xlink:type,attr,omitempty"`
	ClassAttr         string      `xml:"class,attr,omitempty"`
	StyleAttr         string      `xml:"style,attr,omitempty"`
	IdAttr            string      `xml:"id,attr,omitempty"`
	XrefAttr          string      `xml:"xref,attr,omitempty"`
	OtherAttr         string      `xml:"other,attr,omitempty"`
	DefinitionURLAttr string      `xml:"definitionURL,attr,omitempty"`
	EncodingAttr      string      `xml:"encoding,attr,omitempty"`
}

// Curl ...
type Curl *CurlType

// CurlType ...
type CurlType struct {
	XMLName           xml.Name    `xml:"curl"`
	XlinkHrefAttr     interface{} `xml:"xlink:href,attr,omitempty"`
	XlinkTypeAttr     string      `xml:"xlink:type,attr,omitempty"`
	ClassAttr         string      `xml:"class,attr,omitempty"`
	StyleAttr         string      `xml:"style,attr,omitempty"`
	IdAttr            string      `xml:"id,attr,omitempty"`
	XrefAttr          string      `xml:"xref,attr,omitempty"`
	OtherAttr         string      `xml:"other,attr,omitempty"`
	DefinitionURLAttr string      `xml:"definitionURL,attr,omitempty"`
	EncodingAttr      string      `xml:"encoding,attr,omitempty"`
}

// Laplacian ...
type Laplacian *LaplacianType

// LaplacianType ...
type LaplacianType struct {
	XMLName           xml.Name    `xml:"laplacian"`
	XlinkHrefAttr     interface{} `xml:"xlink:href,attr,omitempty"`
	XlinkTypeAttr     string      `xml:"xlink:type,attr,omitempty"`
	ClassAttr         string      `xml:"class,attr,omitempty"`
	StyleAttr         string      `xml:"style,attr,omitempty"`
	IdAttr            string      `xml:"id,attr,omitempty"`
	XrefAttr          string      `xml:"xref,attr,omitempty"`
	OtherAttr         string      `xml:"other,attr,omitempty"`
	DefinitionURLAttr string      `xml:"definitionURL,attr,omitempty"`
	EncodingAttr      string      `xml:"encoding,attr,omitempty"`
}

// Sum ...
type Sum *SumType

// SumType ...
type SumType struct {
	XMLName           xml.Name    `xml:"sum"`
	XlinkHrefAttr     interface{} `xml:"xlink:href,attr,omitempty"`
	XlinkTypeAttr     string      `xml:"xlink:type,attr,omitempty"`
	ClassAttr         string      `xml:"class,attr,omitempty"`
	StyleAttr         string      `xml:"style,attr,omitempty"`
	IdAttr            string      `xml:"id,attr,omitempty"`
	XrefAttr          string      `xml:"xref,attr,omitempty"`
	OtherAttr         string      `xml:"other,attr,omitempty"`
	DefinitionURLAttr string      `xml:"definitionURL,attr,omitempty"`
	EncodingAttr      string      `xml:"encoding,attr,omitempty"`
}

// Product ...
type Product *ProductType

// ProductType ...
type ProductType struct {
	XMLName           xml.Name    `xml:"product"`
	XlinkHrefAttr     interface{} `xml:"xlink:href,attr,omitempty"`
	XlinkTypeAttr     string      `xml:"xlink:type,attr,omitempty"`
	ClassAttr         string      `xml:"class,attr,omitempty"`
	StyleAttr         string      `xml:"style,attr,omitempty"`
	IdAttr            string      `xml:"id,attr,omitempty"`
	XrefAttr          string      `xml:"xref,attr,omitempty"`
	OtherAttr         string      `xml:"other,attr,omitempty"`
	DefinitionURLAttr string      `xml:"definitionURL,attr,omitempty"`
	EncodingAttr      string      `xml:"encoding,attr,omitempty"`
}

// Limit ...
type Limit *LimitType

// LimitType ...
type LimitType struct {
	XMLName           xml.Name    `xml:"limit"`
	XlinkHrefAttr     interface{} `xml:"xlink:href,attr,omitempty"`
	XlinkTypeAttr     string      `xml:"xlink:type,attr,omitempty"`
	ClassAttr         string      `xml:"class,attr,omitempty"`
	StyleAttr         string      `xml:"style,attr,omitempty"`
	IdAttr            string      `xml:"id,attr,omitempty"`
	XrefAttr          string      `xml:"xref,attr,omitempty"`
	OtherAttr         string      `xml:"other,attr,omitempty"`
	DefinitionURLAttr string      `xml:"definitionURL,attr,omitempty"`
	EncodingAttr      string      `xml:"encoding,attr,omitempty"`
}

// Moment ...
type Moment *MomentType

// MomentType ...
type MomentType struct {
	XMLName           xml.Name    `xml:"moment"`
	XlinkHrefAttr     interface{} `xml:"xlink:href,attr,omitempty"`
	XlinkTypeAttr     string      `xml:"xlink:type,attr,omitempty"`
	ClassAttr         string      `xml:"class,attr,omitempty"`
	StyleAttr         string      `xml:"style,attr,omitempty"`
	IdAttr            string      `xml:"id,attr,omitempty"`
	XrefAttr          string      `xml:"xref,attr,omitempty"`
	OtherAttr         string      `xml:"other,attr,omitempty"`
	DefinitionURLAttr string      `xml:"definitionURL,attr,omitempty"`
	EncodingAttr      string      `xml:"encoding,attr,omitempty"`
}

// Exists ...
type Exists *ExistsType

// ExistsType ...
type ExistsType struct {
	XMLName           xml.Name    `xml:"exists"`
	XlinkHrefAttr     interface{} `xml:"xlink:href,attr,omitempty"`
	XlinkTypeAttr     string      `xml:"xlink:type,attr,omitempty"`
	ClassAttr         string      `xml:"class,attr,omitempty"`
	StyleAttr         string      `xml:"style,attr,omitempty"`
	IdAttr            string      `xml:"id,attr,omitempty"`
	XrefAttr          string      `xml:"xref,attr,omitempty"`
	OtherAttr         string      `xml:"other,attr,omitempty"`
	DefinitionURLAttr string      `xml:"definitionURL,attr,omitempty"`
	EncodingAttr      string      `xml:"encoding,attr,omitempty"`
}

// Forall ...
type Forall *ForallType

// ForallType ...
type ForallType struct {
	XMLName           xml.Name    `xml:"forall"`
	XlinkHrefAttr     interface{} `xml:"xlink:href,attr,omitempty"`
	XlinkTypeAttr     string      `xml:"xlink:type,attr,omitempty"`
	ClassAttr         string      `xml:"class,attr,omitempty"`
	StyleAttr         string      `xml:"style,attr,omitempty"`
	IdAttr            string      `xml:"id,attr,omitempty"`
	XrefAttr          string      `xml:"xref,attr,omitempty"`
	OtherAttr         string      `xml:"other,attr,omitempty"`
	DefinitionURLAttr string      `xml:"definitionURL,attr,omitempty"`
	EncodingAttr      string      `xml:"encoding,attr,omitempty"`
}

// Neq ...
type Neq *NeqType

// NeqType ...
type NeqType struct {
	XMLName           xml.Name    `xml:"neq"`
	XlinkHrefAttr     interface{} `xml:"xlink:href,attr,omitempty"`
	XlinkTypeAttr     string      `xml:"xlink:type,attr,omitempty"`
	ClassAttr         string      `xml:"class,attr,omitempty"`
	StyleAttr         string      `xml:"style,attr,omitempty"`
	IdAttr            string      `xml:"id,attr,omitempty"`
	XrefAttr          string      `xml:"xref,attr,omitempty"`
	OtherAttr         string      `xml:"other,attr,omitempty"`
	DefinitionURLAttr string      `xml:"definitionURL,attr,omitempty"`
	EncodingAttr      string      `xml:"encoding,attr,omitempty"`
}

// Factorof ...
type Factorof *FactorofType

// FactorofType ...
type FactorofType struct {
	XMLName           xml.Name    `xml:"factorof"`
	XlinkHrefAttr     interface{} `xml:"xlink:href,attr,omitempty"`
	XlinkTypeAttr     string      `xml:"xlink:type,attr,omitempty"`
	ClassAttr         string      `xml:"class,attr,omitempty"`
	StyleAttr         string      `xml:"style,attr,omitempty"`
	IdAttr            string      `xml:"id,attr,omitempty"`
	XrefAttr          string      `xml:"xref,attr,omitempty"`
	OtherAttr         string      `xml:"other,attr,omitempty"`
	DefinitionURLAttr string      `xml:"definitionURL,attr,omitempty"`
	EncodingAttr      string      `xml:"encoding,attr,omitempty"`
}

// In ...
type In *InType

// InType ...
type InType struct {
	XMLName           xml.Name    `xml:"in"`
	XlinkHrefAttr     interface{} `xml:"xlink:href,attr,omitempty"`
	XlinkTypeAttr     string      `xml:"xlink:type,attr,omitempty"`
	ClassAttr         string      `xml:"class,attr,omitempty"`
	StyleAttr         string      `xml:"style,attr,omitempty"`
	IdAttr            string      `xml:"id,attr,omitempty"`
	XrefAttr          string      `xml:"xref,attr,omitempty"`
	OtherAttr         string      `xml:"other,attr,omitempty"`
	DefinitionURLAttr string      `xml:"definitionURL,attr,omitempty"`
	EncodingAttr      string      `xml:"encoding,attr,omitempty"`
}

// Notin ...
type Notin *NotinType

// NotinType ...
type NotinType struct {
	XMLName           xml.Name    `xml:"notin"`
	XlinkHrefAttr     interface{} `xml:"xlink:href,attr,omitempty"`
	XlinkTypeAttr     string      `xml:"xlink:type,attr,omitempty"`
	ClassAttr         string      `xml:"class,attr,omitempty"`
	StyleAttr         string      `xml:"style,attr,omitempty"`
	IdAttr            string      `xml:"id,attr,omitempty"`
	XrefAttr          string      `xml:"xref,attr,omitempty"`
	OtherAttr         string      `xml:"other,attr,omitempty"`
	DefinitionURLAttr string      `xml:"definitionURL,attr,omitempty"`
	EncodingAttr      string      `xml:"encoding,attr,omitempty"`
}

// Notsubset ...
type Notsubset *NotsubsetType

// NotsubsetType ...
type NotsubsetType struct {
	XMLName           xml.Name    `xml:"notsubset"`
	XlinkHrefAttr     interface{} `xml:"xlink:href,attr,omitempty"`
	XlinkTypeAttr     string      `xml:"xlink:type,attr,omitempty"`
	ClassAttr         string      `xml:"class,attr,omitempty"`
	StyleAttr         string      `xml:"style,attr,omitempty"`
	IdAttr            string      `xml:"id,attr,omitempty"`
	XrefAttr          string      `xml:"xref,attr,omitempty"`
	OtherAttr         string      `xml:"other,attr,omitempty"`
	DefinitionURLAttr string      `xml:"definitionURL,attr,omitempty"`
	EncodingAttr      string      `xml:"encoding,attr,omitempty"`
}

// Notprsubset ...
type Notprsubset *NotprsubsetType

// NotprsubsetType ...
type NotprsubsetType struct {
	XMLName           xml.Name    `xml:"notprsubset"`
	XlinkHrefAttr     interface{} `xml:"xlink:href,attr,omitempty"`
	XlinkTypeAttr     string      `xml:"xlink:type,attr,omitempty"`
	ClassAttr         string      `xml:"class,attr,omitempty"`
	StyleAttr         string      `xml:"style,attr,omitempty"`
	IdAttr            string      `xml:"id,attr,omitempty"`
	XrefAttr          string      `xml:"xref,attr,omitempty"`
	OtherAttr         string      `xml:"other,attr,omitempty"`
	DefinitionURLAttr string      `xml:"definitionURL,attr,omitempty"`
	EncodingAttr      string      `xml:"encoding,attr,omitempty"`
}

// Tendsto ...
type Tendsto *TendstoType

// TendstoType ...
type TendstoType struct {
	XMLName           xml.Name    `xml:"tendsto"`
	XlinkHrefAttr     interface{} `xml:"xlink:href,attr,omitempty"`
	XlinkTypeAttr     string      `xml:"xlink:type,attr,omitempty"`
	ClassAttr         string      `xml:"class,attr,omitempty"`
	StyleAttr         string      `xml:"style,attr,omitempty"`
	IdAttr            string      `xml:"id,attr,omitempty"`
	XrefAttr          string      `xml:"xref,attr,omitempty"`
	OtherAttr         string      `xml:"other,attr,omitempty"`
	DefinitionURLAttr string      `xml:"definitionURL,attr,omitempty"`
	EncodingAttr      string      `xml:"encoding,attr,omitempty"`
	TypeAttr          string      `xml:"type,attr,omitempty"`
}

// Eq ...
type Eq *EqType

// EqType ...
type EqType struct {
	XMLName           xml.Name    `xml:"eq"`
	XlinkHrefAttr     interface{} `xml:"xlink:href,attr,omitempty"`
	XlinkTypeAttr     string      `xml:"xlink:type,attr,omitempty"`
	ClassAttr         string      `xml:"class,attr,omitempty"`
	StyleAttr         string      `xml:"style,attr,omitempty"`
	IdAttr            string      `xml:"id,attr,omitempty"`
	XrefAttr          string      `xml:"xref,attr,omitempty"`
	OtherAttr         string      `xml:"other,attr,omitempty"`
	DefinitionURLAttr string      `xml:"definitionURL,attr,omitempty"`
	EncodingAttr      string      `xml:"encoding,attr,omitempty"`
}

// Leq ...
type Leq *LeqType

// LeqType ...
type LeqType struct {
	XMLName           xml.Name    `xml:"leq"`
	XlinkHrefAttr     interface{} `xml:"xlink:href,attr,omitempty"`
	XlinkTypeAttr     string      `xml:"xlink:type,attr,omitempty"`
	ClassAttr         string      `xml:"class,attr,omitempty"`
	StyleAttr         string      `xml:"style,attr,omitempty"`
	IdAttr            string      `xml:"id,attr,omitempty"`
	XrefAttr          string      `xml:"xref,attr,omitempty"`
	OtherAttr         string      `xml:"other,attr,omitempty"`
	DefinitionURLAttr string      `xml:"definitionURL,attr,omitempty"`
	EncodingAttr      string      `xml:"encoding,attr,omitempty"`
}

// Lt ...
type Lt *LtType

// LtType ...
type LtType struct {
	XMLName           xml.Name    `xml:"lt"`
	XlinkHrefAttr     interface{} `xml:"xlink:href,attr,omitempty"`
	XlinkTypeAttr     string      `xml:"xlink:type,attr,omitempty"`
	ClassAttr         string      `xml:"class,attr,omitempty"`
	StyleAttr         string      `xml:"style,attr,omitempty"`
	IdAttr            string      `xml:"id,attr,omitempty"`
	XrefAttr          string      `xml:"xref,attr,omitempty"`
	OtherAttr         string      `xml:"other,attr,omitempty"`
	DefinitionURLAttr string      `xml:"definitionURL,attr,omitempty"`
	EncodingAttr      string      `xml:"encoding,attr,omitempty"`
}

// Geq ...
type Geq *GeqType

// GeqType ...
type GeqType struct {
	XMLName           xml.Name    `xml:"geq"`
	XlinkHrefAttr     interface{} `xml:"xlink:href,attr,omitempty"`
	XlinkTypeAttr     string      `xml:"xlink:type,attr,omitempty"`
	ClassAttr         string      `xml:"class,attr,omitempty"`
	StyleAttr         string      `xml:"style,attr,omitempty"`
	IdAttr            string      `xml:"id,attr,omitempty"`
	XrefAttr          string      `xml:"xref,attr,omitempty"`
	OtherAttr         string      `xml:"other,attr,omitempty"`
	DefinitionURLAttr string      `xml:"definitionURL,attr,omitempty"`
	EncodingAttr      string      `xml:"encoding,attr,omitempty"`
}

// Gt ...
type Gt *GtType

// GtType ...
type GtType struct {
	XMLName           xml.Name    `xml:"gt"`
	XlinkHrefAttr     interface{} `xml:"xlink:href,attr,omitempty"`
	XlinkTypeAttr     string      `xml:"xlink:type,attr,omitempty"`
	ClassAttr         string      `xml:"class,attr,omitempty"`
	StyleAttr         string      `xml:"style,attr,omitempty"`
	IdAttr            string      `xml:"id,attr,omitempty"`
	XrefAttr          string      `xml:"xref,attr,omitempty"`
	OtherAttr         string      `xml:"other,attr,omitempty"`
	DefinitionURLAttr string      `xml:"definitionURL,attr,omitempty"`
	EncodingAttr      string      `xml:"encoding,attr,omitempty"`
}

// Equivalent ...
type Equivalent *EquivalentType

// EquivalentType ...
type EquivalentType struct {
	XMLName           xml.Name    `xml:"equivalent"`
	XlinkHrefAttr     interface{} `xml:"xlink:href,attr,omitempty"`
	XlinkTypeAttr     string      `xml:"xlink:type,attr,omitempty"`
	ClassAttr         string      `xml:"class,attr,omitempty"`
	StyleAttr         string      `xml:"style,attr,omitempty"`
	IdAttr            string      `xml:"id,attr,omitempty"`
	XrefAttr          string      `xml:"xref,attr,omitempty"`
	OtherAttr         string      `xml:"other,attr,omitempty"`
	DefinitionURLAttr string      `xml:"definitionURL,attr,omitempty"`
	EncodingAttr      string      `xml:"encoding,attr,omitempty"`
}

// Approx ...
type Approx *ApproxType

// ApproxType ...
type ApproxType struct {
	XMLName           xml.Name    `xml:"approx"`
	XlinkHrefAttr     interface{} `xml:"xlink:href,attr,omitempty"`
	XlinkTypeAttr     string      `xml:"xlink:type,attr,omitempty"`
	ClassAttr         string      `xml:"class,attr,omitempty"`
	StyleAttr         string      `xml:"style,attr,omitempty"`
	IdAttr            string      `xml:"id,attr,omitempty"`
	XrefAttr          string      `xml:"xref,attr,omitempty"`
	OtherAttr         string      `xml:"other,attr,omitempty"`
	DefinitionURLAttr string      `xml:"definitionURL,attr,omitempty"`
	EncodingAttr      string      `xml:"encoding,attr,omitempty"`
}

// Subset ...
type Subset *SubsetType

// SubsetType ...
type SubsetType struct {
	XMLName           xml.Name    `xml:"subset"`
	XlinkHrefAttr     interface{} `xml:"xlink:href,attr,omitempty"`
	XlinkTypeAttr     string      `xml:"xlink:type,attr,omitempty"`
	ClassAttr         string      `xml:"class,attr,omitempty"`
	StyleAttr         string      `xml:"style,attr,omitempty"`
	IdAttr            string      `xml:"id,attr,omitempty"`
	XrefAttr          string      `xml:"xref,attr,omitempty"`
	OtherAttr         string      `xml:"other,attr,omitempty"`
	DefinitionURLAttr string      `xml:"definitionURL,attr,omitempty"`
	EncodingAttr      string      `xml:"encoding,attr,omitempty"`
}

// Prsubset ...
type Prsubset *PrsubsetType

// PrsubsetType ...
type PrsubsetType struct {
	XMLName           xml.Name    `xml:"prsubset"`
	XlinkHrefAttr     interface{} `xml:"xlink:href,attr,omitempty"`
	XlinkTypeAttr     string      `xml:"xlink:type,attr,omitempty"`
	ClassAttr         string      `xml:"class,attr,omitempty"`
	StyleAttr         string      `xml:"style,attr,omitempty"`
	IdAttr            string      `xml:"id,attr,omitempty"`
	XrefAttr          string      `xml:"xref,attr,omitempty"`
	OtherAttr         string      `xml:"other,attr,omitempty"`
	DefinitionURLAttr string      `xml:"definitionURL,attr,omitempty"`
	EncodingAttr      string      `xml:"encoding,attr,omitempty"`
}

// ChemistryType ...
type ChemistryType struct {
	XMLName xml.Name  `xml:"chemistry"`
	IdAttr  string    `xml:"id,attr,omitempty"`
	NumAttr string    `xml:"num,attr"`
	Img     *ImgType  `xml:"img"`
	Chem    *ChemType `xml:"chem"`
}

// Chemistry is *******************************
//
//	CHEMISTRY
//	*******************************
//	Chemical formulae, ring structures, Markush structures, etc.
//
//	EPO required usage:
//	- For now treat as image data.
//	- Depending on industry support we may use, e.g. CML later
//	- For chemistry elements in the main part of the document:
//	id="chem0001".
//	- For chemistry elements in the abstract:id="chema01";
//	- num = 0001, 0002, etc.
type Chemistry *ChemistryType

// ChemType ...
type ChemType struct {
	XMLName      xml.Name `xml:"chem"`
	IdAttr       string   `xml:"id,attr,omitempty"`
	FileAttr     string   `xml:"file,attr"`
	ChemtypeAttr string   `xml:"chem-type,attr,omitempty"`
}

// Chem is This is a pointer to an external DTD for
//
//	chemical markup - to be determined.
//	For EPO probably CML; http://www.xml-cml.org/
//	?**
type Chem *ChemType

// OlType ...
type OlType struct {
	XMLName     xml.Name  `xml:"ol"`
	IdAttr      string    `xml:"id,attr,omitempty"`
	CompactAttr string    `xml:"compact,attr,omitempty"`
	OlstyleAttr string    `xml:"ol-style,attr,omitempty"`
	Li          []*LiType `xml:"li"`
}

// Ol is *******************************
//
//	ORDERED LISTS:
//	*******************************
//
//	EPO required use:
//	- For ol elements in the main part of the document id="ol0001"
//	- If parent element is abstract:id="ola01";BUT contractors
//	should, if possible, not use in abstracts just type in the
//	numbers as text.
//
//	EPO PatXML style ONLY for three levels and ONLY in the description:
//	- level 1 use arablic numbers 1, 2, 3, ...
//	- level 2 use lower alpha a, b, c, ...
//	- level 3 use lower roman i, ii, iii, ...
//
//	Early PatXML files <ol> is nested as above.
//
//	Example (from PatXML version 1.4) :
//	<ol id="ol0001" ol-style="1.">
//	<ol id="ol0001" ol-style="a.">
//	<ol id="ol0001" ol-style="i.">
//
//	Contractors: For all other cases (ie non-PatXML) leave the style
//	empty and insert the actual numbering in the text after <li>:
//
//	EPO style: indent whole list 6mm from left margin
//
//	Example:
//	<ol id="ol0001" ol-style="">
//	<li>1.1 List item 1.1</li>
//	</ol>
type Ol *OlType

// ImgType ...
type ImgType struct {
	XMLName         xml.Name `xml:"img"`
	IdAttr          string   `xml:"id,attr,omitempty"`
	FileAttr        string   `xml:"file,attr"`
	WiAttr          string   `xml:"wi,attr"`
	HeAttr          string   `xml:"he,attr"`
	PgnumAttr       string   `xml:"pgnum,attr,omitempty"`
	FrnumAttr       string   `xml:"frnum,attr,omitempty"`
	ImgcontentAttr  string   `xml:"img-content,attr,omitempty"`
	ImgformatAttr   string   `xml:"img-format,attr"`
	OrientationAttr string   `xml:"orientation,attr,omitempty"`
	InlineAttr      string   `xml:"inline,attr,omitempty"`
	AltAttr         string   `xml:"alt,attr,omitempty"`
}

// Img is *******************************
//
//	IMAGE DATA
//	*******************************
//	Image is used for any kind of image: drawings, art work,
//	figures, complex work units (math, tables, chemistry), etc.
//
//	EPO Required usage:
//	the following attributes must be used in this order:
//	- id
//	- file
//	- wi (in mm) - note wi and he can be in any order (old Datimtex files are he and wi)
//	- he (in mm)
//	- img-content="drawing" (default - may be other - see below)
//	- img-format="tif" (default - no other)
//	- orientation="portrait" (default for PATXML files - may be landscape)
//	- inline may be used
//	- alt is NOT used
//
//	- id and file values:
//	- For figures within the DRAWINGS section:
//	id="if0001", etc.
//	file="imgf0001.tif" (where f = figure)
//	- For images within the DESCRIPTION and CLAIMS section:
//	id="ib0001", etc.
//	file ="imgb0001.tif" (where b = body)
//	- For images within the BODY of the ABSTRACT section eg a chemical formula
//	id="ia01", etc.
//	file ="imga0001.tif" (where a = abstract)
//	- For the figure to accompany the ABSTRACT section (abstract drawing): Taken from
//	the drawings section NOT in PatXML files.
//	id="iaf01", etc.
//	file ="imgaf001.tif" (where af = abstract figure)
//
//	Example:
//
//	<img id="if0001" file="imgf0001.tif" wi="155" he="230" img-content="drawing" img-format="tif"/>
//
//	Note: where images occur, possibly, in other sections, eg. search report data use similar logic.
type Img *ImgType

// FigrefType ...
type FigrefType struct {
	XMLName   xml.Name         `xml:"figref"`
	IdrefAttr []string         `xml:"idref,attr,omitempty"`
	NumAttr   string           `xml:"num,attr,omitempty"`
	B         []*BType         `xml:"b"`
	I         []*IType         `xml:"i"`
	U         []*UType         `xml:"u"`
	O         []*OType         `xml:"o"`
	Sup       []*SupType       `xml:"sup"`
	Sub       []*SubType       `xml:"sub"`
	Smallcaps []*SmallcapsType `xml:"smallcaps"`
}

// Figref is *******************************
//
//	REFERENCES:
//	*******************************
//	A reference to a figure. May be in PatXML files.
//	For discussion with contractor ?**
//
//	Example:"...as shown in <figref idref='f0001'>Fig.1</figref>..."
type Figref *FigrefType

// CrossrefType ...
type CrossrefType struct {
	XMLName   xml.Name         `xml:"crossref"`
	IdrefAttr string           `xml:"idref,attr"`
	B         []*BType         `xml:"b"`
	I         []*IType         `xml:"i"`
	U         []*UType         `xml:"u"`
	O         []*OType         `xml:"o"`
	Sup       []*SupType       `xml:"sup"`
	Sub       []*SubType       `xml:"sub"`
	Smallcaps []*SmallcapsType `xml:"smallcaps"`
}

// Crossref is Cross reference to any other element with an identifier (id)
//
//	In PatXML files can be to a table only.
type Crossref *CrossrefType

// BiodepositType ...
type BiodepositType struct {
	XMLName    xml.Name        `xml:"bio-deposit"`
	IdAttr     string          `xml:"id,attr,omitempty"`
	NumAttr    string          `xml:"num,attr"`
	UrlAttr    string          `xml:"url,attr,omitempty"`
	DnumAttr   string          `xml:"dnum,attr,omitempty"`
	Depositary *DepositaryType `xml:"depositary"`
	Bioaccno   *BioaccnoType   `xml:"bio-accno"`
	Date       int             `xml:"date"`
	Term       *TermType       `xml:"term"`
	Dtext      *DtextType      `xml:"dtext"`
}

// Biodeposit is *******************************
//
//	BIO-DEPOSIT
//	*******************************.
//	Biological deposit citation
//	(INID 83, ST.32:B830)
//	According to PCT Rule 13bis, EPC Rule 28
//	This covers all bio data references long and short within
//	the description and/or claims
//
//	Recommended id=biod0001, biod0002, etc.
//
//	Used in PatXML files
type Biodeposit *BiodepositType

// SourceDocType ...
type SourceDocType struct {
	XMLName    xml.Name        `xml:"sourceDoc"`
	Documentid *DocumentidType `xml:"document-id"`
}

// NplcitType ...
type NplcitType struct {
	XMLName         xml.Name          `xml:"nplcit"`
	IdAttr          string            `xml:"id,attr,omitempty"`
	NumAttr         string            `xml:"num,attr,omitempty"`
	LangAttr        string            `xml:"lang,attr,omitempty"`
	FileAttr        string            `xml:"file,attr,omitempty"`
	NpltypeAttr     string            `xml:"npl-type,attr,omitempty"`
	MediumAttr      string            `xml:"medium,attr,omitempty"`
	UrlAttr         string            `xml:"url,attr,omitempty"`
	ExtractedxpAttr string            `xml:"extracted-xp,attr,omitempty"`
	Text            *TextType         `xml:"text"`
	Article         *ArticleType      `xml:"article"`
	Book            *BookType         `xml:"book"`
	Online          *OnlineType       `xml:"online"`
	Othercit        *OthercitType     `xml:"othercit"`
	Sourcedoc       *SourceDocType    `xml:"source-doc"`
	Relpassage      []*RelpassageType `xml:"rel-passage"`
}

// Nplcit is *******************************
//
//	NPLCIT
//	*******************************
//	Non-Patent Literature (NPL) CITation;
//
//	Notes:
//	This can be free text data without any structure -<text>(#PCDATA) which is NOT
//	recommended or it can be highly structured data which is marked up
//	(generally) according to ST.14 and ISO 690 layout. This is one of the most
//	diffcult areas to standardise as there is no concensus regarding the best way to
//	layout a bibliographic citation. We generally adopt to WIPO ST.14 and AACR2
//
//	This part of the DTD has used many different sources for element names and DTD
//	structure and reference:
//	AACR2 / MARC
//	ISO 12083 - Electronic manuscript prep. and markup. DTD
//	Association of American Publishers (AAP) Z39.59 DTD
//	European Working Group for SGML (EWS) MAJOUR DTD
//	SuperJournal Full Article DTD
//	www.superjournal.ac.uk/sj
//	Elsevier DTD
//	Medline DTD (NLM)
//
//	Attributes (recommended):
//	id - ncit0001, ncit0002, etc for the SR: sr-ncit0001
//	num - 0001, 0002
//	npl-type - The TYPE of citation is office specific (recommended):;
//	a - Abstract citation of no specific kind
//	b - Book citation
//	i - Bilogical abstract citation
//	c - Chemical abstracts citation
//	e - Database citation
//	d - Derwent citation
//	p - Patent cited within NPL group
//	j - Patent Abstracts of Japan citation (REC 067)
//	s - Serial / Journal / Periodical citation
//	w - World Wide Web / Internet search citation
//	medium - the type of medium
//	e.g., online, dvd, cd (CD-ROM), mt (magnetic tape), disk,
//	file - file name on local systems eg. XP number in EPO
//	url - where possible give full web link to document
//
//	EPO and PatXML usage:
//
//	id="ncit0001" for the SR: id="sr-ncit0001"
//	num="0001"
//	npl-type="s" etc
type Nplcit *NplcitType

// RefnoType ...
type RefnoType struct {
	XMLName xml.Name `xml:"refno"`
	IdAttr  string   `xml:"id,attr,omitempty"`
	Value   string   `xml:",chardata"`
}

// Refno is Reference number (general); for the EPO this is the XP number
type Refno *RefnoType

// ClassType ...
type ClassType struct {
	XMLName       xml.Name `xml:"class"`
	ClasstypeAttr string   `xml:"class-type,attr,omitempty"`
	Value         string   `xml:",chardata"`
}

// SubnameType ...
type SubnameType struct {
	XMLName          xml.Name              `xml:"subname"`
	SubnametypeAttr  string                `xml:"subname-type,attr,omitempty"`
	Name             *NameType             `xml:"name"`
	Prefix           *PrefixType           `xml:"prefix"`
	Lastname         *LastnameType         `xml:"last-name"`
	Orgname          *OrgnameType          `xml:"orgname"`
	Firstname        *FirstnameType        `xml:"first-name"`
	Middlename       *MiddlenameType       `xml:"middle-name"`
	Suffix           *SuffixType           `xml:"suffix"`
	Iid              *IidType              `xml:"iid"`
	Role             *RoleType             `xml:"role"`
	Department       *DepartmentType       `xml:"department"`
	Synonym          []*SynonymType        `xml:"synonym"`
	Registerednumber *RegisterednumberType `xml:"registered-number"`
	Addressbook      *AddressbookType      `xml:"addressbook"`
}

// Subname is Subordinate responsibility; e.g., editor, translator, etc.
type Subname *SubnameType

// AuthorType ...
type AuthorType struct {
	XMLName          xml.Name              `xml:"author"`
	IdAttr           string                `xml:"id,attr,omitempty"`
	Name             *NameType             `xml:"name"`
	Prefix           *PrefixType           `xml:"prefix"`
	Lastname         *LastnameType         `xml:"last-name"`
	Orgname          *OrgnameType          `xml:"orgname"`
	Firstname        *FirstnameType        `xml:"first-name"`
	Middlename       *MiddlenameType       `xml:"middle-name"`
	Suffix           *SuffixType           `xml:"suffix"`
	Iid              *IidType              `xml:"iid"`
	Role             *RoleType             `xml:"role"`
	Department       *DepartmentType       `xml:"department"`
	Synonym          []*SynonymType        `xml:"synonym"`
	Registerednumber *RegisterednumberType `xml:"registered-number"`
	Addressbook      *AddressbookType      `xml:"addressbook"`
}

// Author is Author
//
//	author: Person or corporate body responsible for the
//	intellectual or artistic content of a document. [ISO 690:1987]
//
//	There is no distinguishing between personal and corporate authors
//	<author> followed by name or addressbook information
//	use the ID attribute if, for example, there is a need to distinguish between
//	multiple authors.
//	Can also include affiliation details
//
//	Recommended id="auth01", etc.
type Author *AuthorType

// AddressbookType ...
type AddressbookType struct {
	XMLName        xml.Name `xml:"addressbook"`
	IdAttr         string   `xml:"id,attr,omitempty"`
	LangAttr       string   `xml:"lang,attr,omitempty"`
	DataformatAttr string   `xml:"data-format,attr,omitempty"`
	ExchNameGroup  *NameGroup
	Address        *AddressType `xml:"address"`
	Phone          []*PhoneType `xml:"phone"`
	Fax            []*FaxType   `xml:"fax"`
	Email          []*EmailType `xml:"email"`
	Url            []*UrlType   `xml:"url"`
	Ead            []*EadType   `xml:"ead"`
	Dtext          *DtextType   `xml:"dtext"`
	Text           *TextType    `xml:"text"`
}

// Addressbook is ADDRESSBOOK GROUP:
//
//	Holds name and contact information for individuals/organizations
//
//	The LANG attribute is REQUIRED for certain document types,
//	e.g., the JPO PCT Request where names and addresses may be repeated in two
//	different languages. If no structure possible use text.
type Addressbook *AddressbookType

// PatcitType ...
type PatcitType struct {
	XMLName      xml.Name          `xml:"patcit"`
	IdAttr       string            `xml:"id,attr,omitempty"`
	NumAttr      string            `xml:"num,attr,omitempty"`
	DnumAttr     string            `xml:"dnum,attr,omitempty"`
	DnumtypeAttr string            `xml:"dnum-type,attr,omitempty"`
	FileAttr     string            `xml:"file,attr,omitempty"`
	UrlAttr      string            `xml:"url,attr,omitempty"`
	Text         *TextType         `xml:"text"`
	Documentid   *DocumentidType   `xml:"document-id"`
	Relpassage   []*RelpassageType `xml:"rel-passage"`
}

// Patcit is *******************************
//
//	PATCIT
//	*******************************
//	PATENT CITATIONS:
//	(ST.32:see B561 for B documents only)
//
//	Patent Citation within paragraph and SR
//
//	Notes:
//	Tags arranged according to WIPO ST.14 order.
//	This can be free text data without any structure (text).
//
//	Attributes (recommended):
//	id - pcit0001, pcit0002, etc. for the SR: sr-pcit0001
//	num - 0001, 0002, etc.
//	dnum - use full number as one string, eg, "US5401234A";
//	file - file name eg. if actual file is stored on local systems
//	dnum-type - type of document number
//	(e.g., application number, publication number)
//	url - where possible give full web link to patent eg to espacenet
//
//	EPO and PatXML usage:
//	id - pcit0001, pcit0002, etc. for the SR: sr-pcit0001
//	num - 0001, 0002, etc.
//	dnum - use full number as one string, eg, "US5401234A";
//	dnum-type - type of document number; only used if NOT publication
//	number; otherwise values are (in PatXML): appno and pctno
//	url - for the SR generate link to espacenet
//
//	Examples:
//
//	<patcit id='pcit0001' num="0001" dnum='US4793675A' dnum-type='appno'>
//	<document-id>
//	<country>US</country>
//	<doc-number>4793675</doc-number>
//	<kind>A</kind>
//	<name>Handa</name>
//	<date>19881227</date>
//	</document-id>
//	</patcit>
//
//	For the SR:
//	<srep-citations>
//	<citation>
//	<patcit id='sr-pcit0001' num="0001" dnum='US6089831A' url="http://v3.espacenet.com/textdoc?DB=EPODOC&IDX=US6089831&CY=ep">
//	<document-id>
//	<country>US</country>
//	<doc-number>6089831</doc-number>
//	<kind>A</kind>
//	<name>ALT MATHIAS ET AL</name>
//	<date>20000718</date>
//	</document-id>
//	</patcit>
//	<rel-passage>
//	<passage>
//	column 3, line 66 - column 6, line 35; figure 2
//	</passage>
//	</rel-passage>
//	<category>A</category>
//	<rel-claims>1,4,8,15,16,20,29, 30</rel-claims>
//	</citation>
//	<srep-citations>
//
//	EPO style:
//	- <country>, <doc-number>: bold
//	- <name>: uppercase, brackets eg. (SMITH)
//	- reformat date to: dd.mm.yyyy eg. 27.12.1988
//
//	Notes:
//	- It is NOT expected that the applicant will create the tagged data
//	unless using PatXML.
//	- Contractor should capture as specified here
type Patcit *PatcitType

// DocumentidType ...
type DocumentidType struct {
	XMLName   xml.Name       `xml:"document-id"`
	LangAttr  string         `xml:"lang,attr,omitempty"`
	DocidAttr int            `xml:"doc-id,attr,omitempty"`
	Country   string         `xml:"country"`
	Docnumber *DocnumberType `xml:"doc-number"`
	Kind      *KindType      `xml:"kind"`
	Name      *NameType      `xml:"name"`
	Date      int            `xml:"date"`
}

// DocumentidPrintType ...
type DocumentidPrintType struct {
	XMLName   xml.Name       `xml:"document-id"`
	LangAttr  string         `xml:"lang,attr,omitempty"`
	Country   string         `xml:"country"`
	Docnumber *DocnumberType `xml:"doc-number"`
	Kind      *KindType      `xml:"kind"`
	Name      *NameType      `xml:"name"`
	Date      int            `xml:"date"`
}

// Documentid is Document identification refers to patents (and patent applications) only. See WIPO ST.14
type Documentid *DocumentidType

// NameType ...
type NameType struct {
	XMLName      xml.Name `xml:"name"`
	NametypeAttr string   `xml:"name-type,attr,omitempty"`
	Value        string   `xml:",chardata"`
}

// Name is Name:
//
//	If no distinction or detail can be given.
//	Also to be used for: personal (natural person) and corporate (legal entity) names
type Name *NameType

// DtType ...
type DtType struct {
	XMLName   xml.Name         `xml:"dt"`
	IdAttr    string           `xml:"id,attr,omitempty"`
	B         []*BType         `xml:"b"`
	I         []*IType         `xml:"i"`
	U         []*UType         `xml:"u"`
	O         []*OType         `xml:"o"`
	Sup       []*SupType       `xml:"sup"`
	Sub       []*SubType       `xml:"sub"`
	Smallcaps []*SmallcapsType `xml:"smallcaps"`
}

// Dt is Term to be defined
//
//	Recommended id="dt0001",etc NOT USED IN EPO.
type Dt *DtType

// OType ...
type OType struct {
	XMLName   xml.Name         `xml:"o"`
	PosAttr   string           `xml:"pos,attr,omitempty"`
	StyleAttr string           `xml:"style,attr,omitempty"`
	B         []*BType         `xml:"b"`
	I         []*IType         `xml:"i"`
	Sub       []*SubType       `xml:"sub"`
	Sup       []*SupType       `xml:"sup"`
	Smallcaps []*SmallcapsType `xml:"smallcaps"`
}

// O is Underscore: style - single is default
type O *OType

// UType ...
type UType struct {
	XMLName   xml.Name         `xml:"u"`
	StyleAttr string           `xml:"style,attr,omitempty"`
	B         []*BType         `xml:"b"`
	I         []*IType         `xml:"i"`
	O         []*OType         `xml:"o"`
	Sup       []*SupType       `xml:"sup"`
	Sub       []*SubType       `xml:"sub"`
	Smallcaps []*SmallcapsType `xml:"smallcaps"`
}

// U is Underscore: style - single is default
type U *UType

// DocpageType ...
type DocpageType struct {
	XMLName         xml.Name `xml:"doc-page"`
	AltAttr         string   `xml:"alt,attr,omitempty"`
	ColorAttr       string   `xml:"color,attr,omitempty"`
	FileAttr        string   `xml:"file,attr"`
	HeAttr          string   `xml:"he,attr"`
	IdAttr          string   `xml:"id,attr,omitempty"`
	OcrAttr         string   `xml:"ocr,attr,omitempty"`
	OrientationAttr string   `xml:"orientation,attr,omitempty"`
	PpAttr          string   `xml:"pp,attr,omitempty"`
	PpfAttr         string   `xml:"ppf,attr,omitempty"`
	PplAttr         string   `xml:"ppl,attr,omitempty"`
	TypeAttr        string   `xml:"type,attr"`
	WiAttr          string   `xml:"wi,attr"`
}

// Docpage is doc-page - DOCument or PAGE
//
//	This is primarily to be used when data for the whole or
//	major sections of an application are in image format
//	OR other formats such as pdf. Page range attributes are
//	given when required pp- page range ppf - first page
//	ppl - last page (for pdf). The 'img' may also be used
//	for complete pages, eg. in drawings
//
//	Recommended id = docp01, docp02, etc.
type Docpage *DocpageType

// SrepwrittenopinionType ...
type SrepwrittenopinionType struct {
	XMLName                   xml.Name                       `xml:"srep-written-opinion"`
	Docpage                   []*DocpageType                 `xml:"doc-page"`
	Basisofsrepopinion        *BasisofsrepopinionType        `xml:"basis-of-srep-opinion"`
	Priorityopinion           *PriorityopinionType           `xml:"priority-opinion"`
	Nonestablishmentofopinion *NonestablishmentofopinionType `xml:"non-establishment-of-opinion"`
	Unityofinvention          *UnityofinventionType          `xml:"unity-of-invention"`
	ExchPctrule43bisstatement *Pctrule43bisstatementType     `xml:"pct-rule43bis-statement"`
	ExchOpinioncitations      *OpinioncitationsType          `xml:"opinion-citations"`
	Defectinapplication       *DefectinapplicationType       `xml:"defect-in-application"`
	Observationonapplication  *ObservationonapplicationType  `xml:"observation-on-application"`
	Text                      []*TextType                    `xml:"text"`
}

// Srepwrittenopinion ...
type Srepwrittenopinion *SrepwrittenopinionType

// ObservationonapplicationType ...
type ObservationonapplicationType struct {
	XMLName xml.Name `xml:"observation-on-application"`
	P       []*PType `xml:"p"`
}

// Observationonapplication is Certain observations on the international application (Section VIII).
//
//	The following observations on the clarity of the claims, description, and
//	drawings or on the question whether the claims are fully supported by the
//	description, are made:
type Observationonapplication *ObservationonapplicationType

// DefectinapplicationType ...
type DefectinapplicationType struct {
	XMLName xml.Name `xml:"defect-in-application"`
	P       []*PType `xml:"p"`
}

// Defectinapplication is Certain defects in the international application (Section Vii).
//
//	The following defects in the form or contents of the international application
//	have been noted:
type Defectinapplication *DefectinapplicationType

// OpinioncitationsType ...
type OpinioncitationsType struct {
	XMLName                       xml.Name                         `xml:"opinion-citations"`
	ExchCertainpublisheddocuments []*CertainpublisheddocumentsType `xml:"certain-published-documents"`
	Nonwrittendisclosures         []*NonwrittendisclosuresType     `xml:"non-written-disclosures"`
}

// Opinioncitations is (PCT/IPEA/408 - Box No. VI Certain documents cited)
type Opinioncitations *OpinioncitationsType

// NonwrittendisclosuresType ...
type NonwrittendisclosuresType struct {
	XMLName                 xml.Name                     `xml:"non-written-disclosures"`
	Kindofdisclosure        *KindofdisclosureType        `xml:"kind-of-disclosure"`
	Date                    int                          `xml:"date"`
	Dateofwrittendisclosure *DateofwrittendisclosureType `xml:"date-of-written-disclosure"`
}

// Nonwrittendisclosures is (PCT/ISA/237 )
//
//  2. Non-written disclosures (Rules 43bis.1 and 70.9)
//
//     (PCT/IPEA/409 and PCT/IPEA/408 )
//
//  2. Non-written disclosures (Rule 70.9)
type Nonwrittendisclosures *NonwrittendisclosuresType

// DateofwrittendisclosureType ...
type DateofwrittendisclosureType struct {
	XMLName xml.Name `xml:"date-of-written-disclosure"`
	Date    int      `xml:"date"`
}

// Dateofwrittendisclosure is Date of written disclosure
//
//	Referring to non-written disclosure (day/month/year)
type Dateofwrittendisclosure *DateofwrittendisclosureType

// KindofdisclosureType ...
type KindofdisclosureType struct {
	XMLName xml.Name `xml:"kind-of-disclosure"`
	Value   string   `xml:",chardata"`
}

// Kindofdisclosure is Kind of non-written disclosure
type Kindofdisclosure *KindofdisclosureType

// CertainpublisheddocumentsType ...
type CertainpublisheddocumentsType struct {
	XMLName      xml.Name          `xml:"certain-published-documents"`
	ExchCitation []*CitationType   `xml:"citation"`
	Filingdate   *FilingdateType   `xml:"filing-date"`
	Prioritydate *PrioritydateType `xml:"priority-date"`
	Text         *TextType         `xml:"text"`
}

// Certainpublisheddocuments is (PCT/ISA/237 )
//
//  1. Certain published documents (Rules 43bis.1 and 70.10)
//
//     (PCT/IPEA/409 and PCT/IPEA/408 )
//
//  1. Certain published documents (Rule 70.10)
type Certainpublisheddocuments *CertainpublisheddocumentsType

// Pctrule43bisstatementType ...
type Pctrule43bisstatementType struct {
	XMLName                   xml.Name                   `xml:"pct-rule43bis-statement"`
	Noveltyvalid              *NoveltyvalidType          `xml:"novelty-valid"`
	Noveltynotvalid           *NoveltynotvalidType       `xml:"novelty-not-valid"`
	Inventivestepvalid        *InventivestepvalidType    `xml:"inventive-step-valid"`
	Inventivestepnotvalid     *InventivestepnotvalidType `xml:"inventive-step-not-valid"`
	Applicabilityvalid        *ApplicabilityvalidType    `xml:"applicability-valid"`
	Applicabilitynotvalid     *ApplicabilitynotvalidType `xml:"applicability-not-valid"`
	ExchCitationsexplanations *CitationsexplanationsType `xml:"citations-explanations"`
}

// Pctrule43bisstatement is (PCT/ISA/237 - Box V)
//
//	Reasoned statement under Rule 43bis.1(a)(i) with regard to novelty, inventive
//	step or industrial applicability;
//	citations and explanations supporting such statement.
type Pctrule43bisstatement *Pctrule43bisstatementType

// CitationsexplanationsType ...
type CitationsexplanationsType struct {
	XMLName      xml.Name          `xml:"citations-explanations"`
	ExchCitation []*CitationType   `xml:"citation"`
	Filingdate   *FilingdateType   `xml:"filing-date"`
	Prioritydate *PrioritydateType `xml:"priority-date"`
	Text         *TextType         `xml:"text"`
}

// Citationsexplanations is Citations and explanations:
type Citationsexplanations *CitationsexplanationsType

// FilingdateType ...
type FilingdateType struct {
	XMLName xml.Name `xml:"filing-date"`
	Date    int      `xml:"date"`
}

// Filingdate ...
type Filingdate *FilingdateType

// ApplicabilitynotvalidType ...
type ApplicabilitynotvalidType struct {
	XMLName  xml.Name        `xml:"applicability-not-valid"`
	Claimnum []*ClaimnumType `xml:"claim-num"`
}

// Applicabilitynotvalid ...
type Applicabilitynotvalid *ApplicabilitynotvalidType

// ApplicabilityvalidType ...
type ApplicabilityvalidType struct {
	XMLName  xml.Name        `xml:"applicability-valid"`
	Claimnum []*ClaimnumType `xml:"claim-num"`
}

// Applicabilityvalid ...
type Applicabilityvalid *ApplicabilityvalidType

// InventivestepnotvalidType ...
type InventivestepnotvalidType struct {
	XMLName  xml.Name        `xml:"inventive-step-not-valid"`
	Claimnum []*ClaimnumType `xml:"claim-num"`
}

// Inventivestepnotvalid ...
type Inventivestepnotvalid *InventivestepnotvalidType

// InventivestepvalidType ...
type InventivestepvalidType struct {
	XMLName  xml.Name        `xml:"inventive-step-valid"`
	Claimnum []*ClaimnumType `xml:"claim-num"`
}

// Inventivestepvalid ...
type Inventivestepvalid *InventivestepvalidType

// NoveltynotvalidType ...
type NoveltynotvalidType struct {
	XMLName  xml.Name        `xml:"novelty-not-valid"`
	Claimnum []*ClaimnumType `xml:"claim-num"`
}

// Noveltynotvalid ...
type Noveltynotvalid *NoveltynotvalidType

// NoveltyvalidType ...
type NoveltyvalidType struct {
	XMLName  xml.Name        `xml:"novelty-valid"`
	Claimnum []*ClaimnumType `xml:"claim-num"`
}

// Noveltyvalid ...
type Noveltyvalid *NoveltyvalidType

// UnityofinventionType ...
type UnityofinventionType struct {
	XMLName                     xml.Name                         `xml:"unity-of-invention"`
	Invitationpayadditionalfees *InvitationpayadditionalfeesType `xml:"invitation-pay-additional-fees"`
	Notunityofinvention         *NotunityofinventionType         `xml:"not-unity-of-invention"`
	Complianceunityinvention    *ComplianceunityinventionType    `xml:"compliance-unity-invention"`
	Opinionestablishedregarding *OpinionestablishedregardingType `xml:"opinion-established-regarding"`
}

// Unityofinvention is (PCT/IPEA/408 - Box No. IV Lack of unity of invention)
type Unityofinvention *UnityofinventionType

// OpinionestablishedregardingType ...
type OpinionestablishedregardingType struct {
	XMLName           xml.Name               `xml:"opinion-established-regarding"`
	Entireapplication *EntireapplicationType `xml:"entire-application"`
	Claimnum          []*ClaimnumType        `xml:"claim-num"`
}

// Opinionestablishedregarding is (PCT/ISA/237 ) - Box No. IV Lack of unity of invention Consequently,
//
//	this opinion has been established in respect of the following parts of the
//	international application: all parts the parts relating to claims Nos.
type Opinionestablishedregarding *OpinionestablishedregardingType

// NotunityofinventionType ...
type NotunityofinventionType struct {
	XMLName xml.Name `xml:"not-unity-of-invention"`
}

// Notunityofinvention is (PCT/ISA/237 ) - Box No. IV Lack of unity of invention (2)
//
//	This Authority found that the requirement of unity of invention is not complied
//	with and chose not to invite the applicant to pay additional fees.
//
//	(PCT/IPEA/409 )
//	This Authority found that the requirement of unity of invention is not complied
//	with and chose, according to Rule 68.1, not to invite the applicant to restrict
//	or pay additional fees.
type Notunityofinvention *NotunityofinventionType

// NonestablishmentofopinionType ...
type NonestablishmentofopinionType struct {
	XMLName              xml.Name                  `xml:"non-establishment-of-opinion"`
	Inventionnotexamined *InventionnotexaminedType `xml:"invention-not-examined"`
	Notannexccompliant   *NotannexccompliantType   `xml:"not-annex-c-compliant"`
}

// Nonestablishmentofopinion is (PCT/ISA/237 - Box III)
//
//	Non-establishment of opinion with regard to novelty, inventive step and
//	industrial applicability.
type Nonestablishmentofopinion *NonestablishmentofopinionType

// NotannexccompliantType ...
type NotannexccompliantType struct {
	XMLName        xml.Name            `xml:"not-annex-c-compliant"`
	Annexc         *AnnexcType         `xml:"annex-c"`
	Annexcbis      *AnnexcbisType      `xml:"annex-c-bis"`
	Additionalinfo *AdditionalinfoType `xml:"additional-info"`
}

// Notannexccompliant is (PCT/ISA/237 - Box III)
type Notannexccompliant *NotannexccompliantType

// AnnexcbisType ...
type AnnexcbisType struct {
	XMLName xml.Name `xml:"annex-c-bis"`
}

// Annexcbis is (PCT/ISA/237 and PCT/IPEA/408 )
//
//	The tables related to the nucleotide and/or amino acid sequence listing, if in
//	computer readable form only, do not comply with the technical requirements
//	provided for in Annex C-bis of the Administrative Instructions.
//
//	(PCT/IPEA/409 )
//	The tables related to the nucleotide and/or amino acid sequence listing do not
//	comply with the technical requirements provided for in Annex C-bis of the
//	Administrative Instructions in that the computer readable form:
type Annexcbis *AnnexcbisType

// AnnexcType ...
type AnnexcType struct {
	XMLName                             xml.Name                                 `xml:"annex-c"`
	Sequencelistingwrittenform          *SequencelistingwrittenformType          `xml:"sequence-listing-written-form"`
	Sequencelistingcomputerreadableform *SequencelistingcomputerreadableformType `xml:"sequence-listing-computer-readable-form"`
}

// Annexc is The nucleotide and/or amino acid sequence listing does not comply with the
//
//	standard provided for in Annex C of the Administrative Instructions in that:
type Annexc *AnnexcType

// InventionnotexaminedType ...
type InventionnotexaminedType struct {
	XMLName           xml.Name               `xml:"invention-not-examined"`
	Entireapplication *EntireapplicationType `xml:"entire-application"`
	Claimnum          []*ClaimnumType        `xml:"claim-num"`
	Nonestabreason1   *Nonestabreason1Type   `xml:"non-estab-reason-1"`
	Nonestabreason2   *Nonestabreason2Type   `xml:"non-estab-reason-2"`
	Nonestabreason3   *Nonestabreason3Type   `xml:"non-estab-reason-3"`
	Nonestabreason4   *Nonestabreason4Type   `xml:"non-estab-reason-4"`
}

// Inventionnotexamined is The questions whether the claimed invention appears to be novel, to involve
//
//	an inventive step (to be non obvious), or to be industrially applicable have not
//	been examined in respect of:
type Inventionnotexamined *InventionnotexaminedType

// Nonestabreason4Type ...
type Nonestabreason4Type struct {
	XMLName  xml.Name        `xml:"non-estab-reason-4"`
	Claimnum []*ClaimnumType `xml:"claim-num"`
}

// Nonestabreason4 is No international search report has been established for said claims Nos.
//
//	(rel-claims)
type Nonestabreason4 *Nonestabreason4Type

// Nonestabreason3Type ...
type Nonestabreason3Type struct {
	XMLName  xml.Name        `xml:"non-estab-reason-3"`
	Claimnum []*ClaimnumType `xml:"claim-num"`
}

// Nonestabreason3 is The claims, or said claims Nos. (claim nos) are so inadequately supported by the
//
//	description that no meaningful opinion could be formed.
type Nonestabreason3 *Nonestabreason3Type

// Nonestabreason2Type ...
type Nonestabreason2Type struct {
	XMLName  xml.Name        `xml:"non-estab-reason-2"`
	Claimnum []*ClaimnumType `xml:"claim-num"`
	P        []*PType        `xml:"p"`
}

// Nonestabreason2 is The description, claims or drawings (indicate particular elements below) or said
//
//	claims Nos are so unclear that no meaningful opinion could be formed (specify):
type Nonestabreason2 *Nonestabreason2Type

// Nonestabreason1Type ...
type Nonestabreason1Type struct {
	XMLName  xml.Name        `xml:"non-estab-reason-1"`
	Claimnum []*ClaimnumType `xml:"claim-num"`
	P        []*PType        `xml:"p"`
}

// Nonestabreason1 is The said international application, or the said claims Nos. "rel-claims" relate
//
//	to the following subject matter which does not require an international
//	preliminary examination
type Nonestabreason1 *Nonestabreason1Type

// EntireapplicationType ...
type EntireapplicationType struct {
	XMLName xml.Name `xml:"entire-application"`
}

// Entireapplication is The entire international application.
type Entireapplication *EntireapplicationType

// ClaiminvalidType ...
type ClaiminvalidType struct {
	XMLName xml.Name `xml:"claim-invalid"`
}

// Claiminvalid is This opinion has been established as if no priority had been claimed due to
//
//	the fact that the priority claim has been found invalid (Rules 43bis.1 and 64.1).
//
//	Thus for the purposes of this opinion, the international filing date indicated
//	above is considered to be the relevant date.
type Claiminvalid *ClaiminvalidType

// BasisofsrepopinionType ...
type BasisofsrepopinionType struct {
	XMLName           xml.Name               `xml:"basis-of-srep-opinion"`
	Translationofappl *TranslationofapplType `xml:"translation-of-appl"`
	Sequencelistbasis *SequencelistbasisType `xml:"sequence-list-basis"`
}

// Basisofsrepopinion is Form PCT/ISA/237 (Box No. I) (January 2004)
//
//	Basis of this opinion
type Basisofsrepopinion *BasisofsrepopinionType

// SrepforpubType ...
type SrepforpubType struct {
	XMLName                    xml.Name                    `xml:"srep-for-pub"`
	Docpage                    []*DocpageType              `xml:"doc-page"`
	ExchClassificationipc      *ClassificationipcType      `xml:"classification-ipc"`
	ExchClassificationsipcr    *ClassificationsipcrType    `xml:"classifications-ipcr"`
	ExchClassificationnational *ClassificationnationalType `xml:"classification-national"`
	ExchSrepfieldssearched     *SrepfieldssearchedType     `xml:"srep-fields-searched"`
	ExchSrepcitations          *SrepcitationsType          `xml:"srep-citations"`
	ExchIncompletesearch       *IncompletesearchType       `xml:"incomplete-search"`
	Srepadmin                  *SrepadminType              `xml:"srep-admin"`
	ExchSreppatentfamilies     *SreppatentfamiliesType     `xml:"srep-patent-families"`
}

// Srepforpub ...
type Srepforpub *SrepforpubType

// SreppatentfamiliesType ...
type SreppatentfamiliesType struct {
	XMLName              xml.Name                `xml:"srep-patent-families"`
	Text                 *TextType               `xml:"text"`
	ExchSreppatentfamily []*SreppatentfamilyType `xml:"srep-patent-family"`
}

// Sreppatentfamilies is PATENT FAMILY INFORMATION
//
//	This section lists the patent family members relating to the patent documents cited above.
//	The European Patent Office is in no way liable for these particulars
//	which are merely given for the purpose of information.
type Sreppatentfamilies *SreppatentfamiliesType

// SrepfamilymemberType ...
type SrepfamilymemberType struct {
	XMLName    xml.Name        `xml:"srep-family-member"`
	Documentid *DocumentidType `xml:"document-id"`
}

// Srepfamilymember is Patent family.
//
//	(ST.32:B345)
type Srepfamilymember *SrepfamilymemberType

// PriorityapplicationType ...
type PriorityapplicationType struct {
	XMLName    xml.Name        `xml:"priority-application"`
	Documentid *DocumentidType `xml:"document-id"`
}

// Priorityapplication is Priority application number.
//
//	(INID 31, ST.32:B310)
type Priorityapplication *PriorityapplicationType

// SrepadminType ...
type SrepadminType struct {
	XMLName                xml.Name                    `xml:"srep-admin"`
	Examiners              *ExaminersType              `xml:"examiners"`
	Srepoffice             *SrepofficeType             `xml:"srep-office"`
	Datesearchcompleted    *DatesearchcompletedType    `xml:"date-search-completed"`
	Datesearchreportmailed *DatesearchreportmailedType `xml:"date-search-report-mailed"`
}

// Srepadmin is srep-admin
//
//	*******************************
//	SR - ADMINISTRATIVE DETAILS
//	*******************************
//	+++++++++++++++++++++++++++++++++++++++
//	** EPO layout:
//	Examiner: Gourier. P, The Hague Date of completion of the search: 15.02.2000
//
//	** END OF SEARCH REPORT **
//
//	OR after Patent family info. ??
//	+++++++++++++++++++++++++++++++++++++++
//
//	Example
//	<srep-admin>
//	<examiners>
//	<primary-examiner>
//	<name>Schroeder, R</name>
//	</primary-examiner>
//	</examiners>
//	<srep-office>
//	<addressbook>
//	<text>The Hague</text>
//	</addressbook>
//	</srep-office>
//	<date-search-completed><date>20050309</date></date-search-completed>
//	</srep-admin>
//	+++++++++++++++++++++++++++++++++++++++
//	PCT example layout:
//
//	ISA/Examiner: EPO
//	DE LAERE, Ann
//	PB 5818, Patentlaan 2
//	NL 2280 HV Rijswijk
//	Tel. +31 - 70 340 2040
//	Fax. +31 - 70 340 3016
//	Search completed: 10 August 1992
//	ISR mailed: 24 August 1992
type Srepadmin *SrepadminType

// DatesearchcompletedType ...
type DatesearchcompletedType struct {
	XMLName xml.Name `xml:"date-search-completed"`
	Date    int      `xml:"date"`
}

// Datesearchcompleted is Date of completion of search report.
//
//	This is mandatory for EP SRs
type Datesearchcompleted *DatesearchcompletedType

// ExaminersType ...
type ExaminersType struct {
	XMLName           xml.Name               `xml:"examiners"`
	Primaryexaminer   *PrimaryexaminerType   `xml:"primary-examiner"`
	Assistantexaminer *AssistantexaminerType `xml:"assistant-examiner"`
	Authorizedofficer *AuthorizedofficerType `xml:"authorized-officer"`
}

// Examiners is Persons acting on the document.
//
//	(ST.32:B745)
type Examiners *ExaminersType

// AssistantexaminerType ...
type AssistantexaminerType struct {
	XMLName             xml.Name                 `xml:"assistant-examiner"`
	Name                *NameType                `xml:"name"`
	Prefix              *PrefixType              `xml:"prefix"`
	Lastname            *LastnameType            `xml:"last-name"`
	Orgname             *OrgnameType             `xml:"orgname"`
	Firstname           *FirstnameType           `xml:"first-name"`
	Middlename          *MiddlenameType          `xml:"middle-name"`
	Suffix              *SuffixType              `xml:"suffix"`
	Iid                 *IidType                 `xml:"iid"`
	Role                *RoleType                `xml:"role"`
	Department          *DepartmentType          `xml:"department"`
	Synonym             []*SynonymType           `xml:"synonym"`
	Registerednumber    *RegisterednumberType    `xml:"registered-number"`
	Electronicsignature *ElectronicsignatureType `xml:"electronic-signature"`
}

// Assistantexaminer is Assistant Examiner.
//
//	(ST.32:B747)
type Assistantexaminer *AssistantexaminerType

// PrimaryexaminerType ...
type PrimaryexaminerType struct {
	XMLName             xml.Name                 `xml:"primary-examiner"`
	Name                *NameType                `xml:"name"`
	Prefix              *PrefixType              `xml:"prefix"`
	Lastname            *LastnameType            `xml:"last-name"`
	Orgname             *OrgnameType             `xml:"orgname"`
	Firstname           *FirstnameType           `xml:"first-name"`
	Middlename          *MiddlenameType          `xml:"middle-name"`
	Suffix              *SuffixType              `xml:"suffix"`
	Iid                 *IidType                 `xml:"iid"`
	Role                *RoleType                `xml:"role"`
	Department          *DepartmentType          `xml:"department"`
	Synonym             []*SynonymType           `xml:"synonym"`
	Registerednumber    *RegisterednumberType    `xml:"registered-number"`
	Electronicsignature *ElectronicsignatureType `xml:"electronic-signature"`
}

// Primaryexaminer is Primary Examiner.
//
//	(ST.32:B746)
type Primaryexaminer *PrimaryexaminerType

// IncompletesearchType ...
type IncompletesearchType struct {
	XMLName                    xml.Name                        `xml:"incomplete-search"`
	Text                       *TextType                       `xml:"text"`
	Claimssearched             *ClaimssearchedType             `xml:"claims-searched"`
	Claimssearchedincompletely *ClaimssearchedincompletelyType `xml:"claims-searched-incompletely"`
	Claimsnotsearched          *ClaimsnotsearchedType          `xml:"claims-not-searched"`
	Reasonlimitedsearch        *ReasonlimitedsearchType        `xml:"reason-limited-search"`
}

// Incompletesearch ...
type Incompletesearch *IncompletesearchType

// ReasonlimitedsearchType ...
type ReasonlimitedsearchType struct {
	XMLName xml.Name `xml:"reason-limited-search"`
	P       []*PType `xml:"p"`
}

// Reasonlimitedsearch ...
type Reasonlimitedsearch *ReasonlimitedsearchType

// ClaimsnotsearchedType ...
type ClaimsnotsearchedType struct {
	XMLName xml.Name `xml:"claims-not-searched"`
	Value   string   `xml:",chardata"`
}

// Claimsnotsearched ...
type Claimsnotsearched *ClaimsnotsearchedType

// ClaimssearchedincompletelyType ...
type ClaimssearchedincompletelyType struct {
	XMLName xml.Name `xml:"claims-searched-incompletely"`
	Value   string   `xml:",chardata"`
}

// Claimssearchedincompletely ...
type Claimssearchedincompletely *ClaimssearchedincompletelyType

// ClaimssearchedType ...
type ClaimssearchedType struct {
	XMLName xml.Name `xml:"claims-searched"`
	Value   string   `xml:",chardata"`
}

// Claimssearched ...
type Claimssearched *ClaimssearchedType

// SrepcitationsType ...
type SrepcitationsType struct {
	XMLName      xml.Name        `xml:"srep-citations"`
	Text         *TextType       `xml:"text"`
	ExchCitation []*CitationType `xml:"citation"`
}

// Srepcitations ...
type Srepcitations *SrepcitationsType

// SrepfieldssearchedType ...
type SrepfieldssearchedType struct {
	XMLName                  xml.Name                  `xml:"srep-fields-searched"`
	ExchMinimumdocumentation *MinimumdocumentationType `xml:"minimum-documentation"`
	Otherdocumentation       []*OtherdocumentationType `xml:"other-documentation"`
	Databasesearched         *DatabasesearchedType     `xml:"database-searched"`
}

// Srepfieldssearched is - Technical fields searched
//   - Note: new IPCR from 2006
type Srepfieldssearched *SrepfieldssearchedType

// DatabasesearchedType ...
type DatabasesearchedType struct {
	XMLName xml.Name    `xml:"database-searched"`
	Text    *TextType   `xml:"text"`
	Nplcit  *NplcitType `xml:"nplcit"`
}

// Databasesearched is Database(s) searched
//
//	** Not used by EPO
type Databasesearched *DatabasesearchedType

// OtherdocumentationType ...
type OtherdocumentationType struct {
	XMLName xml.Name `xml:"other-documentation"`
	Value   string   `xml:",chardata"`
}

// Otherdocumentation is Documentation searched other than minimum documentation
//
//	** Not used by EPO
type Otherdocumentation *OtherdocumentationType

// MinimumdocumentationType ...
type MinimumdocumentationType struct {
	XMLName                    xml.Name                    `xml:"minimum-documentation"`
	ExchClassificationipc      *ClassificationipcType      `xml:"classification-ipc"`
	ExchClassificationsipcr    *ClassificationsipcrType    `xml:"classifications-ipcr"`
	ExchClassificationnational *ClassificationnationalType `xml:"classification-national"`
}

// Minimumdocumentation is Minimum documentation searched
type Minimumdocumentation *MinimumdocumentationType

// Srepinfo ...
type Srepinfo *SrepinfoType

// Srepabstract is *********************************
//
//	SR ABSTRACT
//	*********************************
//
//	srep-abstract
//	+++++++++++++++++++++++++++++++++++++++
//	** EPO:
//
//	The European Patent Office herewith transmits the European search
//	report for the above-mentioned European patent application.
//
//	If applicable, the documents cited in the European search report can be
//	viewed and/or downloaded by clicking on the citations listed.
//
//
//	yes = The abstract was not modified by the Search Division
//	no = The ABSTRACT was modified by the Search Division and
//	the definitive text is as follows:
//	[Retrieve/insert text from DATIMTEX]
//
//	+++++++++++++++++++++++++++++++++++++++
//	PCT ISR
//	PCT/ISA/210. Old 5.
//	Search Report Abstract - will be different from
//	abstract and will replace it.
//	(followed by:)
//
//	The text is approved as submitted by the applicant [attribute] "yes" (default)]
//	(or)
//	The text has been established according to Rule 38.2(b), ]by this ISA as it
//	appears below. The applicant may, within one month from the date of mailing of
//	this ISR, submit comments to this ISA.
//
//	a revised abstract if present [attribute "no"]
//	+++++++++++++++++++++++++++++++++++++++
type Srepabstract *SrepabstractType

// Srepinventiontitle is Attribute "title-approval" :
//
//	yes = The TITLE given by the applicant has been approved by the Search Division
//	no = The TITLE was modified by the Search Division and is as follows:
type Srepinventiontitle *SrepinventiontitleType

// SrepotherinfoType ...
type SrepotherinfoType struct {
	XMLName         xml.Name               `xml:"srep-other-info"`
	Srepinformation []*SrepinformationType `xml:"srep-information"`
}

// Srepotherinfo is This is a place marker since there may be other information added at a later
//
//	stage which has not been forseen.
type Srepotherinfo *SrepotherinfoType

// SrepinfoadminType ...
type SrepinfoadminType struct {
	XMLName                xml.Name                    `xml:"srep-info-admin"`
	Authorizedofficer      *AuthorizedofficerType      `xml:"authorized-officer"`
	Srepoffice             *SrepofficeType             `xml:"srep-office"`
	Datesearchreportmailed *DatesearchreportmailedType `xml:"date-search-report-mailed"`
}

// Srepinfoadmin is Date mailed
//
//	+++++++++++++++++++++++++++++++++++++++
//	** EPO - Old Form 1507; new layout:
//	Date or Datum
type Srepinfoadmin *SrepinfoadminType

// DatesearchreportmailedType ...
type DatesearchreportmailedType struct {
	XMLName xml.Name `xml:"date-search-report-mailed"`
	Date    int      `xml:"date"`
}

// Datesearchreportmailed is Date of mailing of search report.
//
//	(ST.32:B566)
type Datesearchreportmailed *DatesearchreportmailedType

// SrepofficeType ...
type SrepofficeType struct {
	XMLName     xml.Name         `xml:"srep-office"`
	Addressbook *AddressbookType `xml:"addressbook"`
}

// Srepoffice is International Search Authority; international search to be carried out by
type Srepoffice *SrepofficeType

// AuthorizedofficerType ...
type AuthorizedofficerType struct {
	XMLName             xml.Name                 `xml:"authorized-officer"`
	Name                *NameType                `xml:"name"`
	Prefix              *PrefixType              `xml:"prefix"`
	Lastname            *LastnameType            `xml:"last-name"`
	Orgname             *OrgnameType             `xml:"orgname"`
	Firstname           *FirstnameType           `xml:"first-name"`
	Middlename          *MiddlenameType          `xml:"middle-name"`
	Suffix              *SuffixType              `xml:"suffix"`
	Iid                 *IidType                 `xml:"iid"`
	Role                *RoleType                `xml:"role"`
	Department          *DepartmentType          `xml:"department"`
	Synonym             []*SynonymType           `xml:"synonym"`
	Registerednumber    *RegisterednumberType    `xml:"registered-number"`
	Phone               *PhoneType               `xml:"phone"`
	Fax                 *FaxType                 `xml:"fax"`
	Email               *EmailType               `xml:"email"`
	Electronicsignature *ElectronicsignatureType `xml:"electronic-signature"`
}

// Authorizedofficer is Authorized Officer.
type Authorizedofficer *AuthorizedofficerType

// EnhancedsignatureType ...
type EnhancedsignatureType struct {
	XMLName xml.Name   `xml:"enhanced-signature"`
	Pkcs7   *Pkcs7Type `xml:"pkcs7"`
}

// Enhancedsignature is A PKI / PKCS #7 digital signature data type
type Enhancedsignature *EnhancedsignatureType

// Pkcs7Type ...
type Pkcs7Type struct {
	XMLName xml.Name `xml:"pkcs7"`
}

// Pkcs7 is PKCS7 digital signature
type Pkcs7 *Pkcs7Type

// BasicsignatureType ...
type BasicsignatureType struct {
	XMLName    xml.Name        `xml:"basic-signature"`
	Faximage   *FaximageType   `xml:"fax-image"`
	Textstring *TextstringType `xml:"text-string"`
	Clickwrap  *ClickwrapType  `xml:"click-wrap"`
}

// Basicsignature is A non-PKI electronic signature
type Basicsignature *BasicsignatureType

// ClickwrapType ...
type ClickwrapType struct {
	XMLName xml.Name `xml:"click-wrap"`
}

// Clickwrap is A simple 'signature';
//
//	e.g., clicking a button labeled 'accept' or 'I agree'
type Clickwrap *ClickwrapType

// TextstringType ...
type TextstringType struct {
	XMLName xml.Name `xml:"text-string"`
	Value   string   `xml:",chardata"`
}

// Textstring is A simple text string is to be used as the basic electronic signature;
//
//	e.g., John Doe <text-string>/jd/</text-string>
type Textstring *TextstringType

// FiguretopublishType ...
type FiguretopublishType struct {
	XMLName   xml.Name         `xml:"figure-to-publish"`
	Fignumber []*FignumberType `xml:"fig-number"`
}

// Figuretopublish is Figure of the drawings which should accompany the abstract
//
//	Also used in bib. data.
type Figuretopublish *FiguretopublishType

// FignumberType ...
type FignumberType struct {
	XMLName xml.Name `xml:"fig-number"`
	Value   string   `xml:",chardata"`
}

// Fignumber is Also at EP: <B598>
//
//	PCT/RO/101 Box IX: the number of the figure which should accompany the abstract.
type Fignumber *FignumberType

// SrepunityofinventionType ...
type SrepunityofinventionType struct {
	XMLName          xml.Name              `xml:"srep-unity-of-invention"`
	P                []*PType              `xml:"p"`
	Srepsearchfees   *SrepsearchfeesType   `xml:"srep-search-fees"`
	Searchfeeprotest *SearchfeeprotestType `xml:"search-fee-protest"`
}

// Srepunityofinvention is Observations where unity of invention is lacking
type Srepunityofinvention *SrepunityofinventionType

// SrepsearchfeesType ...
type SrepsearchfeesType struct {
	XMLName  xml.Name      `xml:"srep-search-fees"`
	Srepfee1 *Srepfee1Type `xml:"srep-fee-1"`
	Srepfee2 *Srepfee2Type `xml:"srep-fee-2"`
	Srepfee3 *Srepfee3Type `xml:"srep-fee-3"`
	Srepfee4 *Srepfee4Type `xml:"srep-fee-4"`
}

// Srepsearchfees ...
type Srepsearchfees *SrepsearchfeesType

// Srepfee4Type ...
type Srepfee4Type struct {
	XMLName  xml.Name        `xml:"srep-fee-4"`
	Claimnum []*ClaimnumType `xml:"claim-num"`
}

// Srepfee4 is No required additional search fees were timely paid by the applicant.
//
//	Consequently, this ISR is restricted to the invention first mentioned in the
//	claims; it is covered by claim number(s):
type Srepfee4 *Srepfee4Type

// Srepfee3Type ...
type Srepfee3Type struct {
	XMLName  xml.Name        `xml:"srep-fee-3"`
	Claimnum []*ClaimnumType `xml:"claim-num"`
}

// Srepfee3 is As only some of the required additional search fees were timely paid by the
//
//	applicant, this ISR covers only those claims for which fees were paid,
//	specifically claim number(s):
type Srepfee3 *Srepfee3Type

// Srepfee2Type ...
type Srepfee2Type struct {
	XMLName xml.Name `xml:"srep-fee-2"`
}

// Srepfee2 is As all searchable claims could be searched without effort justifying an
//
//	additional fee, this ISA did not invite payment of any additional fees.
type Srepfee2 *Srepfee2Type

// Srepfee1Type ...
type Srepfee1Type struct {
	XMLName xml.Name `xml:"srep-fee-1"`
}

// Srepfee1 is As all required additional search fees were timely paid by the applicant,
//
//	this ISR covers all searchable claims.
type Srepfee1 *Srepfee1Type

// SrepclaimsinfoType ...
type SrepclaimsinfoType struct {
	XMLName     xml.Name         `xml:"srep-claims-info"`
	Clmsreason1 *Clmsreason1Type `xml:"clms-reason-1"`
	Clmsreason2 *Clmsreason2Type `xml:"clms-reason-2"`
	Clmsreason3 *Clmsreason3Type `xml:"clms-reason-3"`
}

// Srepclaimsinfo is (Old PCT/ISA/210 - Box No. II)
//
//	Observations where certain claims were found unsearchable
//
//	This ISR has not been established in respect of certain claims
//	under Article 17(2)(a) for the following reasons:
//
//	(followed by one of the following three reasons:)
type Srepclaimsinfo *SrepclaimsinfoType

// Clmsreason3Type ...
type Clmsreason3Type struct {
	XMLName  xml.Name        `xml:"clms-reason-3"`
	Claimnum []*ClaimnumType `xml:"claim-num"`
}

// Clmsreason3 is Claim number(s) (insert value from cliaim-no)
//
//	because they are dependent claims and are not drafted in accordance with the
//	second and third sentences of PCT Rule 6.4(a)
type Clmsreason3 *Clmsreason3Type

// Clmsreason2Type ...
type Clmsreason2Type struct {
	XMLName     xml.Name         `xml:"clms-reason-2"`
	Claimnum    []*ClaimnumType  `xml:"claim-num"`
	Claimremark *ClaimremarkType `xml:"claim-remark"`
}

// Clmsreason2 is Claims Nos.: (insert value from claim-no)
//
//	because they relate to parts of the international application that do not comply
//	with the prescribed requirements to such an extent that no meaningful
//	international search can be carried out, specifically:
type Clmsreason2 *Clmsreason2Type

// Clmsreason1Type ...
type Clmsreason1Type struct {
	XMLName     xml.Name         `xml:"clms-reason-1"`
	Claimnum    []*ClaimnumType  `xml:"claim-num"`
	Claimremark *ClaimremarkType `xml:"claim-remark"`
}

// Clmsreason1 is Claims Nos.: (insert value from cliaim-no)
//
//	because they relate to subject matter not required to be searched by this
//	Authority, namely:
type Clmsreason1 *Clmsreason1Type

// ClaimremarkType ...
type ClaimremarkType struct {
	XMLName xml.Name `xml:"claim-remark"`
	P       []*PType `xml:"p"`
}

// Claimremark is Remarks on these claims
type Claimremark *ClaimremarkType

// ClaimnumType ...
type ClaimnumType struct {
	XMLName xml.Name `xml:"claim-num"`
	Value   string   `xml:",chardata"`
}

// Claimnum is Claim numbers
type Claimnum *ClaimnumType

// SrepbasisType ...
type SrepbasisType struct {
	XMLName                xml.Name                    `xml:"srep-basis"`
	Basislanguageforsearch *BasislanguageforsearchType `xml:"basis-language-for-search"`
	Sequencelistbasis      *SequencelistbasisType      `xml:"sequence-list-basis"`
}

// Srepbasis is +++++++++++++++++++++++++++++++++++++++
//
//	PCT ISR
//	PCT/ISA/210
//	Box 1::Basis of the Report
//	+++++++++++++++++++++++++++++++++++++++
type Srepbasis *SrepbasisType

// SequencelistbasisType ...
type SequencelistbasisType struct {
	XMLName                  xml.Name                      `xml:"sequence-list-basis"`
	Materialofsequencelist   *MaterialofsequencelistType   `xml:"material-of-sequence-list"`
	Presentationofstatements *PresentationofstatementsType `xml:"presentation-of-statements"`
	Additionalinfo           *AdditionalinfoType           `xml:"additional-info"`
}

// Sequencelistbasis is A sequence listing and/or any related table(s) - see Supplemental Box Relating
//
//	to Sequence Listing.
type Sequencelistbasis *SequencelistbasisType

// PresentationofstatementsType ...
type PresentationofstatementsType struct {
	XMLName xml.Name `xml:"presentation-of-statements"`
}

// Presentationofstatements is (PCT/ISA/210 and PCT/ISA/237 )
//
//	In addition, in the case that more than one version or copy of a sequence
//	listing and/or table relating thereto has been filed or furnished,
//	the required statements that the information in the subsequent or additional
//	copies is identical to that in the application as filed or does not go beyond
//	the application as filed, as appropriate, were furnished.
//
//	(PCT/IPEA/409 and PCT/IPEA/408 )
//	In addition, in the case that more than one version or copy of a sequence
//	listing and/or table(s) relating thereto has been filed or furnished,
//	the required statements that the information in the subsequent or additional
//	copies is identical to that in the application as filed or does not go beyon
//	the application as filed, as appropriate, were furnished.
//	+++++++++++++++++++++++++++++++++++++++
type Presentationofstatements *PresentationofstatementsType

// MaterialofsequencelistType ...
type MaterialofsequencelistType struct {
	XMLName                       xml.Name                           `xml:"material-of-sequence-list"`
	Sequencelistingmaterialtype   *SequencelistingmaterialtypeType   `xml:"sequence-listing-material-type"`
	Sequencelistingmaterialformat *SequencelistingmaterialformatType `xml:"sequence-listing-material-format"`
	Sequencelistingfilingtime     *SequencelistingfilingtimeType     `xml:"sequence-listing-filing-time"`
}

// Materialofsequencelist is (PCT/ISA/210 Box No. I Nucleotide and/or amino acid sequence(s)
//
//	(Continuation of item1.b of the first sheet))
//	1. With regard to any nucleotide and/or amino acid sequence disclosed in the
//	international application and necessary to the claimed invention,
//	the international search was carried out on the basis of:
//
//	(PCT/ISA/237 Box No. I Basis of this opinion)
//	2. With regard to any nucleotide and/or amino acid sequence disclosed in the
//	international application and necessary to the claimed invention,
//	this opinion has been established on the basis of:
//
//	(PCT/IPEA/409 Supplemental Box Relating to Sequence Listing)
//	1. With regard to any nucleotide and/or amino acid sequence disclosed in the
//	international application and necessary to the claimed invention,
//	this report was established on the basis of:
//
//	(PCT/IPEA/408 Supplemental Box Relating to Sequence Listing)
//	1. With regard to any nucleotide and/or amino acid sequence disclosed in the
//	international application and necessary to the claimed invention,
//	this opinion was established on the basis of:
//	+++++++++++++++++++++++++++++++++++++++
type Materialofsequencelist *MaterialofsequencelistType

// SreprequestnumberType ...
type SreprequestnumberType struct {
	XMLName xml.Name `xml:"srep-request-number"`
	Value   string   `xml:",chardata"`
}

// Sreprequestnumber is Search request number eg. on PCT Form 201.
type Sreprequestnumber *SreprequestnumberType

// SreprequestdateType ...
type SreprequestdateType struct {
	XMLName xml.Name `xml:"srep-request-date"`
	Date    int      `xml:"date"`
}

// Sreprequestdate is Date of request for search eg. on PCT Form 201
type Sreprequestdate *SreprequestdateType

// DateofearliestpriorityType ...
type DateofearliestpriorityType struct {
	XMLName xml.Name `xml:"date-of-earliest-priority"`
	Date    int      `xml:"date"`
}

// Dateofearliestpriority is Where the international application claims the priority of several earlier
//
//	applications, the filing date of the earliest application whose priority is
//	claimed must be indicated as the priority date.
type Dateofearliestpriority *DateofearliestpriorityType

// FilereferenceidType ...
type FilereferenceidType struct {
	XMLName xml.Name `xml:"file-reference-id"`
	Value   string   `xml:",chardata"`
}

// Filereferenceid is Applicant's or agent's file reference, if desired,
type Filereferenceid *FilereferenceidType

// PatentfamilyType ...
type PatentfamilyType struct {
	XMLName          xml.Name            `xml:"patent-family"`
	ExchFamilymember []*FamilymemberType `xml:"family-member"`
	ExchAbstract     *AbstractType       `xml:"abstract"`
}

// Patentfamily is DOCDB simple patent family consists of all publications that claim EXACTLY the same ACTIVE priorities as
//
//	the "exchange-document";
//	Physically the DOCDB simple patent family is identified by a 9 digit unique key; this key is represented
//	in attribute "id";
//	Functionally the DOCDB simple patent family is identified by the picture of the ACTIVE priorities as
//	identified in the priority-claims of "exchange-document";
//
//	Element "abstract" contains the best quality English language abstract available in the family;
//	Element "abstract" will not be supported in "patent family" when there is an English language abstract
//	available for "exchange-document";
//
//	application and publication-numbers in "patent family" are represented in both data-format="docdb" and
//	data-format="epodoc";
type Patentfamily *PatentfamilyType

// FamilymemberType ...
type FamilymemberType struct {
	XMLName                  xml.Name                    `xml:"family-member"`
	ExchApplicationreference []*ApplicationreferenceType `xml:"application-reference"`
	ExchPublicationreference []*PublicationreferenceType `xml:"publication-reference"`
}

// Familymember is Element "family member" contains :
//
//	"application-reference"
//	"publication-reference" - one or more - all publication-levels of the application
type Familymember *FamilymemberType

// CorrectionnoticeType ...
type CorrectionnoticeType struct {
	XMLName              xml.Name                      `xml:"correction-notice"`
	Date                 int                           `xml:"date"`
	ExchGazettereference *ExchangegazettereferenceType `xml:"gazette-reference"`
}

// Correctionnotice is (ST.32:B480)
type Correctionnotice *CorrectionnoticeType

// RepublicationnotesType ...
type RepublicationnotesType struct {
	XMLName           xml.Name                 `xml:"republication-notes"`
	Republicationnote []*RepublicationnoteType `xml:"republication-note"`
}

// Republicationnotes is Notes on the correction information (ST.32 : B154EP)
type Republicationnotes *RepublicationnotesType

// ModificationsType ...
type ModificationsType struct {
	XMLName              xml.Name                  `xml:"modifications"`
	Modifiedbibliography *ModifiedbibliographyType `xml:"modified-bibliography"`
	Modifiedpart         []*ModifiedpartType       `xml:"modified-part"`
}

// Modifications is Information on the modifications in the document (ST.32 : B153 and B155EP)
type Modifications *ModificationsType

// ModifiedpartnameType ...
type ModifiedpartnameType struct {
	XMLName xml.Name `xml:"modified-part-name"`
	Value   string   `xml:",chardata"`
}

// Modifiedpartname is Name of the affected part (ST.32 : B1552EP)
type Modifiedpartname *ModifiedpartnameType

// ModifiedbibliographyType ...
type ModifiedbibliographyType struct {
	XMLName  xml.Name        `xml:"modified-bibliography"`
	Inidcode []*InidcodeType `xml:"inid-code"`
}

// Modifiedbibliography is INID-codes affected by the correction information (ST.32 : B153)
type Modifiedbibliography *ModifiedbibliographyType

// CancellationdateType ...
type CancellationdateType struct {
	XMLName xml.Name `xml:"cancellation-date"`
	Value   string   `xml:",chardata"`
}

// Cancellationdate is Issue date of announced correction being cancelled B152EP
type Cancellationdate *CancellationdateType

// RepublicationcodeType ...
type RepublicationcodeType struct {
	XMLName xml.Name `xml:"republication-code"`
	Value   string   `xml:",chardata"`
}

// Republicationcode is Correction information B151EP
type Republicationcode *RepublicationcodeType

// TypeofcorrectionType ...
type TypeofcorrectionType struct {
	XMLName xml.Name `xml:"type-of-correction"`
	Value   string   `xml:",chardata"`
}

// Typeofcorrection is type-of-correction [ for WIPO only ]
type Typeofcorrection *TypeofcorrectionType

// CorrespondingdocsType ...
type CorrespondingdocsType struct {
	XMLName    xml.Name          `xml:"corresponding-docs"`
	Patcit     []*PatcitType     `xml:"patcit"`
	Nplcit     []*NplcitType     `xml:"nplcit"`
	Relpassage []*RelpassageType `xml:"rel-passage"`
	Category   []*CategoryType   `xml:"category"`
	Relclaims  []*RelclaimsType  `xml:"rel-claims"`
}

// Correspondingdocs is Patent family and corresponding-docs - see example above
//
//	These are also "&" cases.
type Correspondingdocs *CorrespondingdocsType

// Priorityclaims is DOCDB may have added one additional priority to the set as printed on the published document.
//
//	For internal EPO business purposes a so-called "self-claim" may have been generated.
//	In a "self-claim" the priority-reference = the application-reference
type Priorityclaims *PriorityclaimsType

// PriorityclaimsType ...
type PriorityclaimsType struct {
	XMLName           xml.Name             `xml:"priority-claims"`
	ExchPriorityclaim []*PriorityclaimType `xml:"priority-claim"`
}

// Priorityactiveindicator ...
type Priorityactiveindicator string

// Prioritylinkagetype ...
type Prioritylinkagetype string

// PrioritydocattachedType ...
type PrioritydocattachedType struct {
	XMLName xml.Name `xml:"priority-doc-attached"`
	Value   string   `xml:",chardata"`
}

// Prioritydocattached is The priority document is attached to the application
type Prioritydocattached *PrioritydocattachedType

// PrioritydocrequestedType ...
type PrioritydocrequestedType struct {
	XMLName xml.Name `xml:"priority-doc-requested"`
	Value   string   `xml:",chardata"`
}

// Prioritydocrequested is The receiving office is requested to prepare and transmit to the IB a certified
//
//	copy of the earlier application
type Prioritydocrequested *PrioritydocrequestedType

// OfficeoffilingType ...
type OfficeoffilingType struct {
	XMLName xml.Name    `xml:"office-of-filing"`
	Region  *RegionType `xml:"region"`
	Country string      `xml:"country"`
}

// Officeoffiling is Where the earlier application is an ARIPO application,indicate at least one
//
//	country party to the PARIS convention for the protection of industrial property
//	or one member of the WTO for which that earlier application was filed.
type Officeoffiling *OfficeoffilingType

// Parties ...
type Parties *PartiesType

// PartiesType ...
type PartiesType struct {
	XMLName               xml.Name                   `xml:"parties"`
	ExchApplicants        *ApplicantsType            `xml:"applicants"`
	ExchInventors         *InventorsType             `xml:"inventors"`
	Correspondenceaddress *CorrespondenceaddressType `xml:"correspondence-address"`
	Agents                *AgentsType                `xml:"agents"`
}

// AgentsType ...
type AgentsType struct {
	XMLName        xml.Name            `xml:"agents"`
	Customernumber *CustomernumberType `xml:"customer-number"`
	Agent          []*AgentType        `xml:"agent"`
}

// Agents is Information regarding Agents or common representatives
type Agents *AgentsType

// CorrespondenceaddressType ...
type CorrespondenceaddressType struct {
	XMLName        xml.Name            `xml:"correspondence-address"`
	Customernumber *CustomernumberType `xml:"customer-number"`
	Addressbook    []*AddressbookType  `xml:"addressbook"`
}

// Correspondenceaddress is Address used for general correspondence
type Correspondenceaddress *CorrespondenceaddressType

// CustomernumberType ...
type CustomernumberType struct {
	XMLName xml.Name `xml:"customer-number"`
	Value   string   `xml:",chardata"`
}

// Customernumber is Customer number for agents by office
type Customernumber *CustomernumberType

// Inventors is Inventors information:
//
//	if the US is designated, all of the inventors must also be named as applicants
//	Contains inventors in different data-formats
//	1. all data-format="docdb"
//	2. all data-format="docdba"
//	3. all data-format="original"
type Inventors *InventorsType

// InventorsType ...
type InventorsType struct {
	XMLName              xml.Name                `xml:"inventors"`
	ExchInventor         []*InventorType         `xml:"inventor"`
	ExchDeceasedinventor []*DeceasedinventorType `xml:"deceased-inventor"`
}

// Inventor is DOCDB only keeps a record of inventor-name and country of residence; address is only available
//
//	sporadically
//	address is included in applicant data-format="docdba"
//	country of residence in applicant data-format="docdb"
//	DOCDB exchanges inventor-name in "name", address in "text";
//	Attributes used on "inventor" level
//	sequence = sequence as printed on the published document;
//	Attributes used on "inventor-name" level
//	data-format = "docdb", standardised following DOCDB primary standardisation rules;
//	data-format = "docdba", standardised following DOCDB secondary rules (translation upper-case);
//	data-format = "original", as supplied by the provider, converted to UTF8;
//	IFD tags, inventor :
//	111 = name "docdb";
//	110 = name "docdba";
//	972 = name "original";
//	113 = address;
//	112 = residence;
//	ST.30 tags, inventor :
//	720 = name;
//	722 = residence;
type Inventor *InventorType

// ApplicantsType ...
type ApplicantsType struct {
	XMLName       xml.Name         `xml:"applicants"`
	ExchApplicant []*ApplicantType `xml:"applicant"`
}

// Applicants ...
type Applicants *ApplicantsType

// DesignatedstatesasinventorType ...
type DesignatedstatesasinventorType struct {
	XMLName xml.Name    `xml:"designated-states-as-inventor"`
	Country []string    `xml:"country"`
	Region  *RegionType `xml:"region"`
}

// Designatedstatesasinventor is Rule 4.6(c):
//
//	"The request may, for different designated states, indicate different persons
//	as inventors where, in this respect, the requirements of the national laws of
//	the designated States are not the same. In such a case, the request shall
//	contain a separate statement for each designated State or group of States in
//	which a particular person, or the same person, is to be considered the
//	inventor, or in which particular persons, or the same persons, are to be
//	considered the inventors."
type Designatedstatesasinventor *DesignatedstatesasinventorType

// DesignatedstatesType ...
type DesignatedstatesType struct {
	XMLName xml.Name    `xml:"designated-states"`
	Country []string    `xml:"country"`
	Region  *RegionType `xml:"region"`
}

// Designatedstates is Indication of specific Contracting States in or for which the applicant is
//
//	seeking protection for his invention (Rule 4.9(a))
type Designatedstates *DesignatedstatesType

// ResidenceType ...
type ResidenceType struct {
	XMLName xml.Name `xml:"residence"`
	Country string   `xml:"country"`
}

// Residence is Country of residence
type Residence *ResidenceType

// NationalityType ...
type NationalityType struct {
	XMLName xml.Name `xml:"nationality"`
	Country string   `xml:"country"`
}

// Nationality is Country of nationality
type Nationality *NationalityType

// DesignationepcType ...
type DesignationepcType struct {
	XMLName                   xml.Name                     `xml:"designation-epc"`
	ExchContractingstates     []*ContractingstatesType     `xml:"contracting-states"`
	ExchExtensionstates       []*ExtensionstatesType       `xml:"extension-states"`
	ExchValidationstates      []*ValidationstatesType      `xml:"validation-states"`
	ExchUpparticipatingstates []*UpparticipatingstatesType `xml:"up-participating-states"`
}

// Designationepc is EPO member states in which protection is desired.
type Designationepc *DesignationepcType

// ExtensionstatesType ...
type ExtensionstatesType struct {
	XMLName xml.Name `xml:"extension-states"`
	Country string   `xml:"country"`
}

// Extensionstates is Recognising EP patent applications and patents on their territory
type Extensionstates *ExtensionstatesType

// ContractingstatesType ...
type ContractingstatesType struct {
	XMLName xml.Name `xml:"contracting-states"`
	Country string   `xml:"country"`
}

// Contractingstates is The EPO member States for which protection (depending upon context) is desired
type Contractingstates *ContractingstatesType

// ValidationstatesType ...
type ValidationstatesType struct {
	XMLName xml.Name `xml:"validation-states"`
	Country string   `xml:"country"`
}

// Validationstates is Recognising EP patent applications and patents on their territory
type Validationstates *ValidationstatesType

// UpparticipatingstatesType ...
type UpparticipatingstatesType struct {
	XMLName xml.Name `xml:"up-participating-states"`
	Country string   `xml:"country"`
}

// Upparticipatingstates is EPO member states participating in the Unitary Patent
type Upparticipatingstates *UpparticipatingstatesType

// ExclusionfromdesignationType ...
type ExclusionfromdesignationType struct {
	XMLName      xml.Name        `xml:"exclusion-from-designation"`
	ExchRegional []*RegionalType `xml:"regional"`
	ExchNational *NationalType   `xml:"national"`
}

// Exclusionfromdesignation is State(s) excluded from precautionary designations under Rule 4.9(b)
type Exclusionfromdesignation *ExclusionfromdesignationType

// PrecautionarydesignationstatementType ...
type PrecautionarydesignationstatementType struct {
	XMLName xml.Name `xml:"precautionary-designation-statement"`
	Value   string   `xml:",chardata"`
}

// Precautionarydesignationstatement is Rule 4.9(b),(c)
//
//	In addition to the designations made above [i.e, designation-of states], the
//	applicant also makes under Rule 4.9(b) all other designations which would be
//	permitted under the PCT except any designation(s) indicated in the Supplemental
//	Box [i.e., exclusion-from-designation] as being excluded form the scope of this
//	statement. The applicant declares that those additional designations are
//	subject to confirmation and that any designation which is not confirmed before
//	the expiration of 15 months from the priority date is to be regarded as
//	withdrawn by the applicant at the expiration of that time limit.
type Precautionarydesignationstatement *PrecautionarydesignationstatementType

// DesignationpctType ...
type DesignationpctType struct {
	XMLName               xml.Name                     `xml:"designation-pct"`
	ExchRegional          []*RegionalType              `xml:"regional"`
	ExchNational          *NationalType                `xml:"national"`
	Newdesignationcountry []*NewdesignationcountryType `xml:"new-designation-country"`
}

// Designationpct is The Contracting States in which protection is desired
//
//	(Rules 4.1(a)(iv) and 4.9(a))
type Designationpct *DesignationpctType

// NewdesignationcountryType ...
type NewdesignationcountryType struct {
	XMLName xml.Name `xml:"new-designation-country"`
	Value   string   `xml:",chardata"`
}

// Newdesignationcountry is New PCT member country states (e.g., not yet published in WIPO ST.3, joined after
//
//	PCT electronic filing software published)
type Newdesignationcountry *NewdesignationcountryType

// NationalType ...
type NationalType struct {
	XMLName           xml.Name                 `xml:"national"`
	Country           string                   `xml:"country"`
	Protectionrequest []*ProtectionrequestType `xml:"protection-request"`
}

// National is The States for which protection or exclusion (depending upon context) is desired
type National *NationalType

// RegionalType ...
type RegionalType struct {
	XMLName           xml.Name                 `xml:"regional"`
	Region            *RegionType              `xml:"region"`
	Country           string                   `xml:"country"`
	Protectionrequest []*ProtectionrequestType `xml:"protection-request"`
	Anyotherstate     *AnyotherstateType       `xml:"any-other-state"`
}

// Regional is Regional (as opposed to national) protection being sought
type Regional *RegionalType

// AnyotherstateType ...
type AnyotherstateType struct {
	XMLName xml.Name `xml:"any-other-state"`
}

// Anyotherstate is Any other state in which protection is being sought
type Anyotherstate *AnyotherstateType

// ProtectionrequestType ...
type ProtectionrequestType struct {
	XMLName          xml.Name              `xml:"protection-request"`
	Kindofprotection *KindofprotectionType `xml:"kind-of-protection"`
	Documentid       *DocumentidType       `xml:"document-id"`
}

// Protectionrequest is Protection request for the designated office.
type Protectionrequest *ProtectionrequestType

// KindofprotectionType ...
type KindofprotectionType struct {
	XMLName xml.Name `xml:"kind-of-protection"`
	Value   string   `xml:",chardata"`
}

// Kindofprotection is Kind of protection; e.g., patent, utility model
type Kindofprotection *KindofprotectionType

// RegionType ...
type RegionType struct {
	XMLName xml.Name `xml:"region"`
	Country string   `xml:"country"`
}

// Region is The region for which protection or
//
//	exclusion (depending upon context) is desired.
type Region *RegionType

// Gazettepubannouncement ...
type Gazettepubannouncement struct {
	XMLName        xml.Name        `xml:"gazette-pub-announcement"`
	ExchGazettenum *GazettenumType `xml:"gazette-num"`
	ExchDate       string          `xml:"date"`
	ExchText       *TextType       `xml:"text"`
}

// Supplementalsreppub ...
type Supplementalsreppub struct {
	XMLName     xml.Name `xml:"supplemental-srep-pub"`
	ExchSrepnum string   `xml:"srep-num"`
	ExchDate    string   `xml:"date"`
}

// Srepnum ...
type Srepnum string

// Abstractreference is Separate publication of an abstract.
//
//	Tag A42 from EPO ST.30 / DOCDB Exchange Tape Format Technical Specification v6.3
type Abstractreference *AbstractreferenceType

// Modifiedcompletespecpub is Separate publication of a modified complete specification
type Modifiedcompletespecpub *ModifiedcompletespecpubType

// Modifiedfirstpagepub is Separate publication of a modified first page report
//
//	Tag A45 from EPO ST.30 / DOCDB Exchange Tape Format Technical Specification v6.3
type Modifiedfirstpagepub *ModifiedfirstpagepubType

// PrintedasamendedType ...
type PrintedasamendedType struct {
	XMLName    xml.Name             `xml:"printed-as-amended"`
	Documentid *DocumentidPrintType `xml:"document-id"`
	Text       *TextType            `xml:"text"`
}

// Printedasamended is Document printed as amended, (eg. EPO B2).
//
//	(ST.32:B477)
type Printedasamended *PrintedasamendedType

// InvalidationofpatentType ...
type InvalidationofpatentType struct {
	XMLName    xml.Name        `xml:"invalidation-of-patent"`
	Documentid *DocumentidType `xml:"document-id"`
	Text       *TextType       `xml:"text"`
}

// Invalidationofpatent is Invalidation of patent.
//
//	(ST.32:B476)
type Invalidationofpatent *InvalidationofpatentType

// TermofgrantType ...
type TermofgrantType struct {
	XMLName       xml.Name             `xml:"term-of-grant"`
	Text          []*TextType          `xml:"text"`
	Disclaimer    []*DisclaimerType    `xml:"disclaimer"`
	Lengthofgrant []*LengthofgrantType `xml:"length-of-grant"`
	Lapseofpatent []*LapseofpatentType `xml:"lapse-of-patent"`
}

// Termofgrant is Term of grant.
//
//	(ST.32:B472)
type Termofgrant *TermofgrantType

// LapseofpatentType ...
type LapseofpatentType struct {
	XMLName    xml.Name        `xml:"lapse-of-patent"`
	Documentid *DocumentidType `xml:"document-id"`
	Text       *TextType       `xml:"text"`
}

// Lapseofpatent is Lapse of patent.
//
//	(ST.32:B475)
type Lapseofpatent *LapseofpatentType

// LengthofgrantType ...
type LengthofgrantType struct {
	XMLName xml.Name `xml:"length-of-grant"`
	Value   string   `xml:",chardata"`
}

// Lengthofgrant is Length of Grant.
//
//	(ST.32:B474)
type Lengthofgrant *LengthofgrantType

// DisclaimerType ...
type DisclaimerType struct {
	XMLName xml.Name  `xml:"disclaimer"`
	Date    int       `xml:"date"`
	Text    *TextType `xml:"text"`
}

// Disclaimer is Disclaimer date.
//
//	(ST.32:B473)
type Disclaimer *DisclaimerType

// GazettenumType ...
type GazettenumType struct {
	XMLName xml.Name `xml:"gazette-num"`
	Value   string   `xml:",chardata"`
}

// Gazettenum ...
type Gazettenum *GazettenumType

// CombinationrankType ...
type CombinationrankType struct {
	XMLName              xml.Name                  `xml:"combination-rank"`
	Ranknumber           string                    `xml:"rank-number"`
	Patentclassification *PatentclassificationType `xml:"patent-classification"`
}

// Combinationrank ...
type Combinationrank *CombinationrankType

// UnlinkedindexingcodeType ...
type UnlinkedindexingcodeType struct {
	XMLName xml.Name `xml:"unlinked-indexing-code"`
	Value   string   `xml:",chardata"`
}

// Unlinkedindexingcode is Unlinked indexing code.
//
//	(ST.32:B515/B525)
type Unlinkedindexingcode *UnlinkedindexingcodeType

// LinkedindexingcodegroupType ...
type LinkedindexingcodegroupType struct {
	XMLName                xml.Name                     `xml:"linked-indexing-code-group"`
	Mainlinkedindexingcode *MainlinkedindexingcodeType  `xml:"main-linked-indexing-code"`
	Sublinkedindexingcode  []*SublinkedindexingcodeType `xml:"sub-linked-indexing-code"`
}

// Linkedindexingcodegroup is Linked indexing code.
//
//	(ST.32:B514/B524)
type Linkedindexingcodegroup *LinkedindexingcodegroupType

// SublinkedindexingcodeType ...
type SublinkedindexingcodeType struct {
	XMLName xml.Name `xml:"sub-linked-indexing-code"`
	Value   string   `xml:",chardata"`
}

// Sublinkedindexingcode is Sub/further Linked Indexing Code.
type Sublinkedindexingcode *SublinkedindexingcodeType

// MainlinkedindexingcodeType ...
type MainlinkedindexingcodeType struct {
	XMLName xml.Name `xml:"main-linked-indexing-code"`
	Value   string   `xml:",chardata"`
}

// Mainlinkedindexingcode is Main Linked Indexing Code.
type Mainlinkedindexingcode *MainlinkedindexingcodeType

// AdditionalinfoType ...
type AdditionalinfoType struct {
	XMLName xml.Name `xml:"additional-info"`
	Value   string   `xml:",chardata"`
}

// Additionalinfo is Additional information. ST.32 equivalency = B513
type Additionalinfo *AdditionalinfoType

// MainclassificationType ...
type MainclassificationType struct {
	XMLName xml.Name `xml:"main-classification"`
	Value   string   `xml:",chardata"`
}

// Mainclassification is Main classification.
//
//	(ST.32:B511/B521)
type Mainclassification *MainclassificationType

// GeneratingofficeType ...
type GeneratingofficeType struct {
	XMLName xml.Name `xml:"generating-office"`
	Country string   `xml:"country"`
}

// Generatingoffice is Positions 41-42: Generating Office
//
//	Since part of the original data in the advanced level and
//	the reclassified data can be delivered by offices other than the
//	publishing office, the information source of such data is
//	recorded by a field of two characters. The country or office
//	code CC, as defined by WIPO Standard ST.3, must be used.
type Generatingoffice *GeneratingofficeType

// ClassificationdatasourceType ...
type ClassificationdatasourceType struct {
	XMLName xml.Name `xml:"classification-data-source"`
	Value   string   `xml:",chardata"`
}

// Classificationdatasource is Position 40: Source of classification data
//
//	The following sources of classification data are foreseen:
//	- Intellectual classification by persons,
//	value H for human generated data.
//	- Machine classification by the propagation of earlier
//	intellectual classification through the use of common
//	priorities in the patent application.
//	The value M is used in this case and will facilitate later corrections.
//	- Classification symbols generated by software using automatic
//	analysis of the content of the patent document.
//	The letter G is used to indicate this source of generated data.
type Classificationdatasource *ClassificationdatasourceType

// ClassificationstatusType ...
type ClassificationstatusType struct {
	XMLName xml.Name `xml:"classification-status"`
	Value   string   `xml:",chardata"`
}

// Classificationstatus is Position 39: Original and reclassified data
//
//	Original data is the first data assigned to the document.
//	In case of a publishing office assigning classification symbols at
//	the core level, another office may also assign symbols at
//	the advanced level as original data.
//	Reclassified data is data changed due to a change in the classification schemes.
//	Various data is data changed due to an incidental reclassification
//	of an individual document, such as the correction of a mistake.
//	Deleted data is data which has to be deleted from the
//	Master Classification Database, due to a change in assigning of
//	classification symbols to a document.
//
//	The indication of the different types of data is marked by the letters B for the basic or original data,
//	R for reclassified data, V for various incidental changes, and D for data to be deleted.
//	Possible status: original-classification, reclassified, various-classification, deleted-classification
type Classificationstatus *ClassificationstatusType

// ActiondateType ...
type ActiondateType struct {
	XMLName xml.Name `xml:"action-date"`
	Date    int      `xml:"date"`
}

// ClassificationvalueType ...
type ClassificationvalueType struct {
	XMLName xml.Name `xml:"classification-value"`
	Value   string   `xml:",chardata"`
}

// Classificationvalue is Position 30: Classification value (inventive or non-inventive)
//
//	The difference between invention information and other information
//	is important for the retrieval of the information. The
//	letters I and N are used for the invention and non-invention
//	information, respectively.
type Classificationvalue *ClassificationvalueType

// SymbolpositionType ...
type SymbolpositionType struct {
	XMLName xml.Name `xml:"symbol-position"`
	Value   string   `xml:",chardata"`
}

// Symbolposition is Position 29: First or later position of symbols
//
//	The position of the first invention information classification
//	can be recognized by this field. The letters F and L are used
//	for first and later position, respectively.
type Symbolposition *SymbolpositionType

// ClassificationlevelType ...
type ClassificationlevelType struct {
	XMLName xml.Name `xml:"classification-level"`
	Value   string   `xml:",chardata"`
}

// Classificationlevel is Position 28 : Classification level
//
//	Offices are expected to classify each subject matter only in one level (core or advanced). However, both
//	levels need to
//	be completely represented in the master classification database and thus a level indicator is needed.
//	The level indicator
//	is also useful for indicating situations where an office does not classify in either the core or the
//	advanced level
//	classification, i.e., when an office only assigns classifications to the subclass level. The level
//	indicator enables to make the difference between core, advanced and subclass levels. The letters C
//	(Core), A (Advanced) and S (Subclass) are
//	used for this one-digit field.
//
//	Levels: ipcr-advanced, ipcr-core
type Classificationlevel *ClassificationlevelType

// IpcversionindicatorType ...
type IpcversionindicatorType struct {
	XMLName xml.Name `xml:"ipc-version-indicator"`
	Date    int      `xml:"date"`
}

// Ipcversionindicator is Positions 20 to 27: Version indicator
//
//	Although in the paper publications a version indicator may contain
//	four or six digits, the version indicator in machinereadable
//	records contains eight digits, namely YYYYMMDD with Y for year, M for month and D for day.
type Ipcversionindicator *IpcversionindicatorType

// SubgroupType ...
type SubgroupType struct {
	XMLName xml.Name `xml:"subgroup"`
	Value   string   `xml:",chardata"`
}

// Subgroup ...
type Subgroup *SubgroupType

// MaingroupType ...
type MaingroupType struct {
	XMLName xml.Name `xml:"main-group"`
	Value   string   `xml:",chardata"`
}

// Maingroup ...
type Maingroup *MaingroupType

// SubclassType ...
type SubclassType struct {
	XMLName xml.Name `xml:"subclass"`
	Value   string   `xml:",chardata"`
}

// Subclass ...
type Subclass *SubclassType

// SectionType ...
type SectionType struct {
	XMLName xml.Name `xml:"section"`
	Value   string   `xml:",chardata"`
}

// Section is Positions 1 to 19: Recording of the parts of the IPC symbols
//
//	IPC symbols are defined in Part 5 of the WIPO Handbook on
//	Industrial Property Information and Documentation and in
//	the latest version of the Guide to the IPC.
type Section *SectionType

// P is *******************************
//
//	PARAGRAPH
//	*******************************
//
//	EPO Required usage:
//	- In case of standard paragraphs in the description: id="p0001", "p0002", etc.
//	- In case of abstracts: id="pa01", "pa02", etc. (more than three is rare)
//	- In case of amended-claims-statement: id="pc0001", "pc0002", etc.
//	- In case of search reports: id="ps0001", "ps0002", etc.
//	- num = 0001, 0002, etc.
//
//	EPO style: - always left justified
//	- precede by para. number in bold as so: [0001]
//	- para. text indented 7mm from [0001]
//	- see espacenet for examples
type P *ExchpType

// Abstsolution is abst-solution
//
//	The solution to the alleged problem that the invention purports to solve.
//
//	Recommended id="abss"
//
//	Unlikely to be used by the EPO
type Abstsolution *AbstsolutionType

// Abstproblem is abst-problem
//
//	The alleged problem that the invention purports to solve
//
//	Recommended id="absp"
//
//	Unlikely to be used by the EPO
type Abstproblem *AbstproblemType

// EntryAtt ...
type EntryAtt struct {
	XMLName xml.Name `xml:"entry.att"`
}

// RowAtt ...
type RowAtt struct {
	XMLName xml.Name `xml:"row.att"`
}

// TbodyAtt ...
type TbodyAtt struct {
	XMLName xml.Name `xml:"tbody.att"`
}

// TheadAtt ...
type TheadAtt struct {
	XMLName xml.Name `xml:"thead.att"`
}

// ColspecAtt ...
type ColspecAtt struct {
	XMLName xml.Name `xml:"colspec.att"`
}

// TgroupAtt ...
type TgroupAtt struct {
	XMLName xml.Name `xml:"tgroup.att"`
}

// TableAtt ...
type TableAtt struct {
	XMLName xml.Name `xml:"table.att"`
}

// DdType ...
type DdType struct {
	XMLName    xml.Name          `xml:"dd"`
	B          []*BType          `xml:"b"`
	I          []*IType          `xml:"i"`
	U          []*UType          `xml:"u"`
	O          []*OType          `xml:"o"`
	Sup        []*SupType        `xml:"sup"`
	Sub        []*SubType        `xml:"sub"`
	Smallcaps  []*SmallcapsType  `xml:"smallcaps"`
	Br         []*BrType         `xml:"br"`
	Pre        []*PreType        `xml:"pre"`
	Patcit     []*PatcitType     `xml:"patcit"`
	Nplcit     []*NplcitType     `xml:"nplcit"`
	Biodeposit []*BiodepositType `xml:"bio-deposit"`
	Crossref   []*CrossrefType   `xml:"crossref"`
	Figref     []*FigrefType     `xml:"figref"`
	Img        []*ImgType        `xml:"img"`
	Ul         []*UlType         `xml:"ul"`
	Ol         []*OlType         `xml:"ol"`
	Chemistry  []*ChemistryType  `xml:"chemistry"`
	Maths      []*MathsType      `xml:"maths"`
}

// Dd is Definition description
type Dd *DdType

// SemanticsContentExpression ...
type SemanticsContentExpression struct {
	XMLName             xml.Name `xml:"semanticsContentExpression"`
	Csymbol             *CsymbolType
	Ci                  *CiType
	Cn                  *CnType
	Apply               *ApplyType
	Reln                *RelnType
	Lambda              *LambdaType
	Condition           *ConditionType
	Declare             *DeclareType
	Sep                 *SepType
	Semantics           *SemanticsType
	Annotation          *AnnotationType
	Annotationxml       *AnnotationxmlType
	Integers            *IntegersType
	Reals               *RealsType
	Rationals           *RationalsType
	Naturalnumbers      *NaturalnumbersType
	Complexes           *ComplexesType
	Primes              *PrimesType
	Exponentiale        *ExponentialeType
	Imaginaryi          *ImaginaryiType
	Notanumber          *NotanumberType
	True                *TrueType
	False               *FalseType
	Emptyset            *EmptysetType
	Pi                  *PiType
	Eulergamma          *EulergammaType
	Infinity            *InfinityType
	Interval            *IntervalType
	List                *ListType
	Matrix              *MatrixType
	Matrixrow           *MatrixrowType
	Set                 *SetType
	Vector              *VectorType
	Piecewise           *PiecewiseType
	Lowlimit            *LowlimitType
	Uplimit             *UplimitType
	Bvar                *BvarType
	Degree              *DegreeType
	Logbase             *LogbaseType
	Momentabout         *MomentaboutType
	Domainofapplication *DomainofapplicationType
	Inverse             *InverseType
	Ident               *IdentType
	Domain              *DomainType
	Codomain            *CodomainType
	Image               *ImageType
	Abs                 *AbsType
	Conjugate           *ConjugateType
	Exp                 *ExpType
	Factorial           *FactorialType
	Arg                 *ArgType
	Real                *RealType
	Imaginary           *ImaginaryType
	Floor               *FloorType
	Ceiling             *CeilingType
	Not                 *NotType
	Ln                  *LnType
	Sin                 *SinType
	Cos                 *CosType
	Tan                 *TanType
	Sec                 *SecType
	Csc                 *CscType
	Cot                 *CotType
	Sinh                *SinhType
	Cosh                *CoshType
	Tanh                *TanhType
	Sech                *SechType
	Csch                *CschType
	Coth                *CothType
	Arcsin              *ArcsinType
	Arccos              *ArccosType
	Arctan              *ArctanType
	Arccosh             *ArccoshType
	Arccot              *ArccotType
	Arccoth             *ArccothType
	Arccsc              *ArccscType
	Arccsch             *ArccschType
	Arcsec              *ArcsecType
	Arcsech             *ArcsechType
	Arcsinh             *ArcsinhType
	Arctanh             *ArctanhType
	Determinant         *DeterminantType
	Transpose           *TransposeType
	Card                *CardType
	Quotient            *QuotientType
	Divide              *DivideType
	Power               *PowerType
	Rem                 *RemType
	Implies             *ImpliesType
	Vectorproduct       *VectorproductType
	Scalarproduct       *ScalarproductType
	Outerproduct        *OuterproductType
	Setdiff             *SetdiffType
	Fn                  *FnType
	Compose             *ComposeType
	Plus                *PlusType
	Times               *TimesType
	Max                 *MaxType
	Min                 *MinType
	Gcd                 *GcdType
	Lcm                 *LcmType
	And                 *AndType
	Or                  *OrType
	Xor                 *XorType
	Union               *UnionType
	Intersect           *IntersectType
	Cartesianproduct    *CartesianproductType
	Mean                *MeanType
	Sdev                *SdevType
	Variance            *VarianceType
	Median              *MedianType
	Mode                *ModeType
	Selector            *SelectorType
	Root                *RootType
	Minus               *MinusType
	Log                 *LogType
	Int                 *IntType
	Diff                *DiffType
	Partialdiff         *PartialdiffType
	Divergence          *DivergenceType
	Grad                *GradType
	Curl                *CurlType
	Laplacian           *LaplacianType
	Sum                 *SumType
	Product             *ProductType
	Limit               *LimitType
	Moment              *MomentType
	Exists              *ExistsType
	Forall              *ForallType
	Neq                 *NeqType
	Factorof            *FactorofType
	In                  *InType
	Notin               *NotinType
	Notsubset           *NotsubsetType
	Notprsubset         *NotprsubsetType
	Tendsto             *TendstoType
	Eq                  *EqType
	Leq                 *LeqType
	Lt                  *LtType
	Geq                 *GeqType
	Gt                  *GtType
	Equivalent          *EquivalentType
	Approx              *ApproxType
	Subset              *SubsetType
	Prsubset            *PrsubsetType
	Mi                  *MiType
	Mn                  *MnType
	Mo                  *MoType
	Mtext               *MtextType
	Ms                  *MsType
	Mspace              *MspaceType
	Mrow                *MrowType
	Mfrac               *MfracType
	Msqrt               *MsqrtType
	Mroot               *MrootType
	Menclose            *MencloseType
	Mstyle              *MstyleType
	Merror              *MerrorType
	Mpadded             *MpaddedType
	Mphantom            *MphantomType
	Mfenced             *MfencedType
	Msub                *MsubType
	Msup                *MsupType
	Msubsup             *MsubsupType
	Munder              *MunderType
	Mover               *MoverType
	Munderover          *MunderoverType
	Mmultiscripts       *MmultiscriptsType
	Mtable              *MtableType
	Mtr                 *MtrType
	Mlabeledtr          *MlabeledtrType
	Mtd                 *MtdType
	Maligngroup         *MaligngroupType
	Malignmark          *MalignmarkType
	Maction             *MactionType
}

// ContentExpression ...
type ContentExpression struct {
	Csymbol             *CsymbolType
	Ci                  *CiType
	Cn                  *CnType
	Apply               *ApplyType
	Reln                *RelnType
	Lambda              *LambdaType
	Condition           *ConditionType
	Declare             *DeclareType
	Sep                 *SepType
	Semantics           *SemanticsType
	Annotation          *AnnotationType
	Annotationxml       *AnnotationxmlType
	Integers            *IntegersType
	Reals               *RealsType
	Rationals           *RationalsType
	Naturalnumbers      *NaturalnumbersType
	Complexes           *ComplexesType
	Primes              *PrimesType
	Exponentiale        *ExponentialeType
	Imaginaryi          *ImaginaryiType
	Notanumber          *NotanumberType
	True                *TrueType
	False               *FalseType
	Emptyset            *EmptysetType
	Pi                  *PiType
	Eulergamma          *EulergammaType
	Infinity            *InfinityType
	Interval            *IntervalType
	List                *ListType
	Matrix              *MatrixType
	Matrixrow           *MatrixrowType
	Set                 *SetType
	Vector              *VectorType
	Piecewise           *PiecewiseType
	Lowlimit            *LowlimitType
	Uplimit             *UplimitType
	Bvar                *BvarType
	Degree              *DegreeType
	Logbase             *LogbaseType
	Momentabout         *MomentaboutType
	Domainofapplication *DomainofapplicationType
	Inverse             *InverseType
	Ident               *IdentType
	Domain              *DomainType
	Codomain            *CodomainType
	Image               *ImageType
	Abs                 *AbsType
	Conjugate           *ConjugateType
	Exp                 *ExpType
	Factorial           *FactorialType
	Arg                 *ArgType
	Real                *RealType
	Imaginary           *ImaginaryType
	Floor               *FloorType
	Ceiling             *CeilingType
	Not                 *NotType
	Ln                  *LnType
	Sin                 *SinType
	Cos                 *CosType
	Tan                 *TanType
	Sec                 *SecType
	Csc                 *CscType
	Cot                 *CotType
	Sinh                *SinhType
	Cosh                *CoshType
	Tanh                *TanhType
	Sech                *SechType
	Csch                *CschType
	Coth                *CothType
	Arcsin              *ArcsinType
	Arccos              *ArccosType
	Arctan              *ArctanType
	Arccosh             *ArccoshType
	Arccot              *ArccotType
	Arccoth             *ArccothType
	Arccsc              *ArccscType
	Arccsch             *ArccschType
	Arcsec              *ArcsecType
	Arcsech             *ArcsechType
	Arcsinh             *ArcsinhType
	Arctanh             *ArctanhType
	Determinant         *DeterminantType
	Transpose           *TransposeType
	Card                *CardType
	Quotient            *QuotientType
	Divide              *DivideType
	Power               *PowerType
	Rem                 *RemType
	Implies             *ImpliesType
	Vectorproduct       *VectorproductType
	Scalarproduct       *ScalarproductType
	Outerproduct        *OuterproductType
	Setdiff             *SetdiffType
	Fn                  *FnType
	Compose             *ComposeType
	Plus                *PlusType
	Times               *TimesType
	Max                 *MaxType
	Min                 *MinType
	Gcd                 *GcdType
	Lcm                 *LcmType
	And                 *AndType
	Or                  *OrType
	Xor                 *XorType
	Union               *UnionType
	Intersect           *IntersectType
	Cartesianproduct    *CartesianproductType
	Mean                *MeanType
	Sdev                *SdevType
	Variance            *VarianceType
	Median              *MedianType
	Mode                *ModeType
	Selector            *SelectorType
	Root                *RootType
	Minus               *MinusType
	Log                 *LogType
	Int                 *IntType
	Diff                *DiffType
	Partialdiff         *PartialdiffType
	Divergence          *DivergenceType
	Grad                *GradType
	Curl                *CurlType
	Laplacian           *LaplacianType
	Sum                 *SumType
	Product             *ProductType
	Limit               *LimitType
	Moment              *MomentType
	Exists              *ExistsType
	Forall              *ForallType
	Neq                 *NeqType
	Factorof            *FactorofType
	In                  *InType
	Notin               *NotinType
	Notsubset           *NotsubsetType
	Notprsubset         *NotprsubsetType
	Tendsto             *TendstoType
	Eq                  *EqType
	Leq                 *LeqType
	Lt                  *LtType
	Geq                 *GeqType
	Gt                  *GtType
	Equivalent          *EquivalentType
	Approx              *ApproxType
	Subset              *SubsetType
	Prsubset            *PrsubsetType
	Mi                  *MiType
	Mn                  *MnType
	Mo                  *MoType
	Mtext               *MtextType
	Ms                  *MsType
	Mspace              *MspaceType
	Mrow                *MrowType
	Mfrac               *MfracType
	Msqrt               *MsqrtType
	Mroot               *MrootType
	Menclose            *MencloseType
	Mstyle              *MstyleType
	Merror              *MerrorType
	Mpadded             *MpaddedType
	Mphantom            *MphantomType
	Mfenced             *MfencedType
	Msub                *MsubType
	Msup                *MsupType
	Msubsup             *MsubsupType
	Munder              *MunderType
	Mover               *MoverType
	Munderover          *MunderoverType
	Mmultiscripts       *MmultiscriptsType
	Mtable              *MtableType
	Mtr                 *MtrType
	Mlabeledtr          *MlabeledtrType
	Mtd                 *MtdType
	Maligngroup         *MaligngroupType
	Malignmark          *MalignmarkType
	Maction             *MactionType
}

// MtdPresExpression ...
type MtdPresExpression struct {
	XMLName        xml.Name `xml:"mtdPresExpression"`
	Mi             *MiType
	Mn             *MnType
	Mo             *MoType
	Mtext          *MtextType
	Ms             *MsType
	Mspace         *MspaceType
	Mprescripts    *MprescriptsType
	None           *NoneType
	Mrow           *MrowType
	Mfrac          *MfracType
	Msqrt          *MsqrtType
	Mroot          *MrootType
	Menclose       *MencloseType
	Mstyle         *MstyleType
	Merror         *MerrorType
	Mpadded        *MpaddedType
	Mphantom       *MphantomType
	Mfenced        *MfencedType
	Msub           *MsubType
	Msup           *MsupType
	Msubsup        *MsubsupType
	Munder         *MunderType
	Mover          *MoverType
	Munderover     *MunderoverType
	Mmultiscripts  *MmultiscriptsType
	Mtable         *MtableType
	Mtr            *MtrType
	Mlabeledtr     *MlabeledtrType
	Mtd            *MtdType
	Maligngroup    *MaligngroupType
	Malignmark     *MalignmarkType
	Maction        *MactionType
	Ci             *CiType
	Csymbol        *CsymbolType
	Cn             *CnType
	Integers       *IntegersType
	Reals          *RealsType
	Rationals      *RationalsType
	Naturalnumbers *NaturalnumbersType
	Complexes      *ComplexesType
	Primes         *PrimesType
	Exponentiale   *ExponentialeType
	Imaginaryi     *ImaginaryiType
	Notanumber     *NotanumberType
	True           *TrueType
	False          *FalseType
	Emptyset       *EmptysetType
	Pi             *PiType
	Eulergamma     *EulergammaType
	Infinity       *InfinityType
	Apply          *ApplyType
	Fn             *FnType
	Lambda         *LambdaType
	Reln           *RelnType
	Interval       *IntervalType
	List           *ListType
	Matrix         *MatrixType
	Matrixrow      *MatrixrowType
	Set            *SetType
	Vector         *VectorType
	Piecewise      *PiecewiseType
	Semantics      *SemanticsType
	Declare        *DeclareType
}

// MtrPresExpression ...
type MtrPresExpression struct {
	XMLName        xml.Name `xml:"mtrPresExpression"`
	Mi             *MiType
	Mn             *MnType
	Mo             *MoType
	Mtext          *MtextType
	Ms             *MsType
	Mspace         *MspaceType
	Mprescripts    *MprescriptsType
	None           *NoneType
	Mrow           *MrowType
	Mfrac          *MfracType
	Msqrt          *MsqrtType
	Mroot          *MrootType
	Menclose       *MencloseType
	Mstyle         *MstyleType
	Merror         *MerrorType
	Mpadded        *MpaddedType
	Mphantom       *MphantomType
	Mfenced        *MfencedType
	Msub           *MsubType
	Msup           *MsupType
	Msubsup        *MsubsupType
	Munder         *MunderType
	Mover          *MoverType
	Munderover     *MunderoverType
	Mmultiscripts  *MmultiscriptsType
	Mtable         *MtableType
	Mtr            *MtrType
	Mlabeledtr     *MlabeledtrType
	Mtd            *MtdType
	Maligngroup    *MaligngroupType
	Malignmark     *MalignmarkType
	Maction        *MactionType
	Ci             *CiType
	Csymbol        *CsymbolType
	Cn             *CnType
	Integers       *IntegersType
	Reals          *RealsType
	Rationals      *RationalsType
	Naturalnumbers *NaturalnumbersType
	Complexes      *ComplexesType
	Primes         *PrimesType
	Exponentiale   *ExponentialeType
	Imaginaryi     *ImaginaryiType
	Notanumber     *NotanumberType
	True           *TrueType
	False          *FalseType
	Emptyset       *EmptysetType
	Pi             *PiType
	Eulergamma     *EulergammaType
	Infinity       *InfinityType
	Apply          *ApplyType
	Fn             *FnType
	Lambda         *LambdaType
	Reln           *RelnType
	Interval       *IntervalType
	List           *ListType
	Matrix         *MatrixType
	Matrixrow      *MatrixrowType
	Set            *SetType
	Vector         *VectorType
	Piecewise      *PiecewiseType
	Semantics      *SemanticsType
	Declare        *DeclareType
}

// PrscrPresExpression ...
type PrscrPresExpression struct {
	XMLName        xml.Name `xml:"prscrPresExpression"`
	Mi             *MiType
	Mn             *MnType
	Mo             *MoType
	Mtext          *MtextType
	Ms             *MsType
	Mspace         *MspaceType
	Mprescripts    *MprescriptsType
	None           *NoneType
	Mrow           *MrowType
	Mfrac          *MfracType
	Msqrt          *MsqrtType
	Mroot          *MrootType
	Menclose       *MencloseType
	Mstyle         *MstyleType
	Merror         *MerrorType
	Mpadded        *MpaddedType
	Mphantom       *MphantomType
	Mfenced        *MfencedType
	Msub           *MsubType
	Msup           *MsupType
	Msubsup        *MsubsupType
	Munder         *MunderType
	Mover          *MoverType
	Munderover     *MunderoverType
	Mmultiscripts  *MmultiscriptsType
	Mtable         *MtableType
	Mtr            *MtrType
	Mlabeledtr     *MlabeledtrType
	Mtd            *MtdType
	Maligngroup    *MaligngroupType
	Malignmark     *MalignmarkType
	Maction        *MactionType
	Ci             *CiType
	Csymbol        *CsymbolType
	Cn             *CnType
	Integers       *IntegersType
	Reals          *RealsType
	Rationals      *RationalsType
	Naturalnumbers *NaturalnumbersType
	Complexes      *ComplexesType
	Primes         *PrimesType
	Exponentiale   *ExponentialeType
	Imaginaryi     *ImaginaryiType
	Notanumber     *NotanumberType
	True           *TrueType
	False          *FalseType
	Emptyset       *EmptysetType
	Pi             *PiType
	Eulergamma     *EulergammaType
	Infinity       *InfinityType
	Apply          *ApplyType
	Fn             *FnType
	Lambda         *LambdaType
	Reln           *RelnType
	Interval       *IntervalType
	List           *ListType
	Matrix         *MatrixType
	Matrixrow      *MatrixrowType
	Set            *SetType
	Vector         *VectorType
	Piecewise      *PiecewiseType
	Semantics      *SemanticsType
	Declare        *DeclareType
}

// ThreePresExpression ...
type ThreePresExpression struct {
	XMLName        xml.Name `xml:"threePresExpression"`
	Mi             *MiType
	Mn             *MnType
	Mo             *MoType
	Mtext          *MtextType
	Ms             *MsType
	Mspace         *MspaceType
	Mprescripts    *MprescriptsType
	None           *NoneType
	Mrow           *MrowType
	Mfrac          *MfracType
	Msqrt          *MsqrtType
	Mroot          *MrootType
	Menclose       *MencloseType
	Mstyle         *MstyleType
	Merror         *MerrorType
	Mpadded        *MpaddedType
	Mphantom       *MphantomType
	Mfenced        *MfencedType
	Msub           *MsubType
	Msup           *MsupType
	Msubsup        *MsubsupType
	Munder         *MunderType
	Mover          *MoverType
	Munderover     *MunderoverType
	Mmultiscripts  *MmultiscriptsType
	Mtable         *MtableType
	Mtr            *MtrType
	Mlabeledtr     *MlabeledtrType
	Mtd            *MtdType
	Maligngroup    *MaligngroupType
	Malignmark     *MalignmarkType
	Maction        *MactionType
	Ci             *CiType
	Csymbol        *CsymbolType
	Cn             *CnType
	Integers       *IntegersType
	Reals          *RealsType
	Rationals      *RationalsType
	Naturalnumbers *NaturalnumbersType
	Complexes      *ComplexesType
	Primes         *PrimesType
	Exponentiale   *ExponentialeType
	Imaginaryi     *ImaginaryiType
	Notanumber     *NotanumberType
	True           *TrueType
	False          *FalseType
	Emptyset       *EmptysetType
	Pi             *PiType
	Eulergamma     *EulergammaType
	Infinity       *InfinityType
	Apply          *ApplyType
	Fn             *FnType
	Lambda         *LambdaType
	Reln           *RelnType
	Interval       *IntervalType
	List           *ListType
	Matrix         *MatrixType
	Matrixrow      *MatrixrowType
	Set            *SetType
	Vector         *VectorType
	Piecewise      *PiecewiseType
	Semantics      *SemanticsType
	Declare        *DeclareType
}

// TwoPresExpression ...
type TwoPresExpression struct {
	XMLName        xml.Name `xml:"twoPresExpression"`
	Mi             *MiType
	Mn             *MnType
	Mo             *MoType
	Mtext          *MtextType
	Ms             *MsType
	Mspace         *MspaceType
	Mprescripts    *MprescriptsType
	None           *NoneType
	Mrow           *MrowType
	Mfrac          *MfracType
	Msqrt          *MsqrtType
	Mroot          *MrootType
	Menclose       *MencloseType
	Mstyle         *MstyleType
	Merror         *MerrorType
	Mpadded        *MpaddedType
	Mphantom       *MphantomType
	Mfenced        *MfencedType
	Msub           *MsubType
	Msup           *MsupType
	Msubsup        *MsubsupType
	Munder         *MunderType
	Mover          *MoverType
	Munderover     *MunderoverType
	Mmultiscripts  *MmultiscriptsType
	Mtable         *MtableType
	Mtr            *MtrType
	Mlabeledtr     *MlabeledtrType
	Mtd            *MtdType
	Maligngroup    *MaligngroupType
	Malignmark     *MalignmarkType
	Maction        *MactionType
	Ci             *CiType
	Csymbol        *CsymbolType
	Cn             *CnType
	Integers       *IntegersType
	Reals          *RealsType
	Rationals      *RationalsType
	Naturalnumbers *NaturalnumbersType
	Complexes      *ComplexesType
	Primes         *PrimesType
	Exponentiale   *ExponentialeType
	Imaginaryi     *ImaginaryiType
	Notanumber     *NotanumberType
	True           *TrueType
	False          *FalseType
	Emptyset       *EmptysetType
	Pi             *PiType
	Eulergamma     *EulergammaType
	Infinity       *InfinityType
	Apply          *ApplyType
	Fn             *FnType
	Lambda         *LambdaType
	Reln           *RelnType
	Interval       *IntervalType
	List           *ListType
	Matrix         *MatrixType
	Matrixrow      *MatrixrowType
	Set            *SetType
	Vector         *VectorType
	Piecewise      *PiecewiseType
	Semantics      *SemanticsType
	Declare        *DeclareType
}

// PresExpression ...
type PresExpression struct {
	Mi             *MiType
	Mn             *MnType
	Mo             *MoType
	Mtext          *MtextType
	Ms             *MsType
	Mspace         *MspaceType
	Mprescripts    *MprescriptsType
	None           *NoneType
	Mrow           *MrowType
	Mfrac          *MfracType
	Msqrt          *MsqrtType
	Mroot          *MrootType
	Menclose       *MencloseType
	Mstyle         *MstyleType
	Merror         *MerrorType
	Mpadded        *MpaddedType
	Mphantom       *MphantomType
	Mfenced        *MfencedType
	Msub           *MsubType
	Msup           *MsupType
	Msubsup        *MsubsupType
	Munder         *MunderType
	Mover          *MoverType
	Munderover     *MunderoverType
	Mmultiscripts  *MmultiscriptsType
	Mtable         *MtableType
	Mtr            *MtrType
	Mlabeledtr     *MlabeledtrType
	Mtd            *MtdType
	Maligngroup    *MaligngroupType
	Malignmark     *MalignmarkType
	Maction        *MactionType
	Ci             *CiType
	Csymbol        *CsymbolType
	Cn             *CnType
	Integers       *IntegersType
	Reals          *RealsType
	Rationals      *RationalsType
	Naturalnumbers *NaturalnumbersType
	Complexes      *ComplexesType
	Primes         *PrimesType
	Exponentiale   *ExponentialeType
	Imaginaryi     *ImaginaryiType
	Notanumber     *NotanumberType
	True           *TrueType
	False          *FalseType
	Emptyset       *EmptysetType
	Pi             *PiType
	Eulergamma     *EulergammaType
	Infinity       *InfinityType
	Apply          *ApplyType
	Fn             *FnType
	Lambda         *LambdaType
	Reln           *RelnType
	Interval       *IntervalType
	List           *ListType
	Matrix         *MatrixType
	Matrixrow      *MatrixrowType
	Set            *SetType
	Vector         *VectorType
	Piecewise      *PiecewiseType
	Semantics      *SemanticsType
	Declare        *DeclareType
}

// MathExpression ...
type MathExpression struct {
	Mi             *MiType
	Mn             *MnType
	Mo             *MoType
	Mtext          *MtextType
	Ms             *MsType
	Mspace         *MspaceType
	Mrow           *MrowType
	Mfrac          *MfracType
	Msqrt          *MsqrtType
	Mroot          *MrootType
	Menclose       *MencloseType
	Mstyle         *MstyleType
	Merror         *MerrorType
	Mpadded        *MpaddedType
	Mphantom       *MphantomType
	Mfenced        *MfencedType
	Msub           *MsubType
	Msup           *MsupType
	Msubsup        *MsubsupType
	Munder         *MunderType
	Mover          *MoverType
	Munderover     *MunderoverType
	Mmultiscripts  *MmultiscriptsType
	Mtable         *MtableType
	Mtr            *MtrType
	Mlabeledtr     *MlabeledtrType
	Mtd            *MtdType
	Maligngroup    *MaligngroupType
	Malignmark     *MalignmarkType
	Maction        *MactionType
	Ci             *CiType
	Csymbol        *CsymbolType
	Cn             *CnType
	Integers       *IntegersType
	Reals          *RealsType
	Rationals      *RationalsType
	Naturalnumbers *NaturalnumbersType
	Complexes      *ComplexesType
	Primes         *PrimesType
	Exponentiale   *ExponentialeType
	Imaginaryi     *ImaginaryiType
	Notanumber     *NotanumberType
	True           *TrueType
	False          *FalseType
	Emptyset       *EmptysetType
	Pi             *PiType
	Eulergamma     *EulergammaType
	Infinity       *InfinityType
	Apply          *ApplyType
	Fn             *FnType
	Lambda         *LambdaType
	Reln           *RelnType
	Interval       *IntervalType
	List           *ListType
	Matrix         *MatrixType
	Matrixrow      *MatrixrowType
	Set            *SetType
	Vector         *VectorType
	Piecewise      *PiecewiseType
	Semantics      *SemanticsType
	Declare        *DeclareType
}

// Math ...
type Math *MathType

// TermType ...
type TermType struct {
	XMLName xml.Name `xml:"term"`
	Value   string   `xml:",chardata"`
}

// Term is Identifies the period of time during which the depository must be able to furnish
//
//	samples of the biological material.
type Term *TermType

// BioaccnoType ...
type BioaccnoType struct {
	XMLName xml.Name `xml:"bio-accno"`
	Value   string   `xml:",chardata"`
}

// Bioaccno is Biological accession number:
//
//	(ST.32:B831)
//	The identification assigned to the biological material by the depository
type Bioaccno *BioaccnoType

// DepositaryType ...
type DepositaryType struct {
	XMLName xml.Name       `xml:"depositary"`
	Address []*AddressType `xml:"address"`
}

// Depositary is Information regarding the facility storing the biological deposit.
//
//	(ST.32:B832)
type Depositary *DepositaryType

// OthercitType ...
type OthercitType struct {
	XMLName xml.Name   `xml:"othercit"`
	B       []*BType   `xml:"b"`
	I       []*IType   `xml:"i"`
	U       []*UType   `xml:"u"`
	Sup     []*SupType `xml:"sup"`
	Sub     []*SubType `xml:"sub"`
}

// Othercit is *******************************
//
//	OTHER CITATIONS
//	*******************************
//	Other citations - free form
type Othercit *OthercitType

// OnlineType ...
type OnlineType struct {
	XMLName     xml.Name           `xml:"online"`
	Text        *TextType          `xml:"text"`
	Author      []*AuthorType      `xml:"author"`
	Onlinetitle []*OnlinetitleType `xml:"online-title"`
	Hosttitle   *HosttitleType     `xml:"hosttitle"`
	Subname     []*SubnameType     `xml:"subname"`
	Edition     *EditionType       `xml:"edition"`
	Serial      *SerialType        `xml:"serial"`
	Book        *BookType          `xml:"book"`
	Imprint     *ImprintType       `xml:"imprint"`
	Pubdate     *PubdateType       `xml:"pubdate"`
	Vid         *VidType           `xml:"vid"`
	Ino         *InoType           `xml:"ino"`
	History     *HistoryType       `xml:"history"`
	Series      *SeriesType        `xml:"series"`
	Hostno      *HostnoType        `xml:"hostno"`
	Absno       *AbsnoType         `xml:"absno"`
	Location    *LocationType      `xml:"location"`
	Notes       *NotesType         `xml:"notes"`
	Avail       []*AvailType       `xml:"avail"`
	Class       []*ClassType       `xml:"class"`
	Keyword     []*KeywordType     `xml:"keyword"`
	Cpyrt       *CpyrtType         `xml:"cpyrt"`
	Doi         *DoiType           `xml:"doi"`
	Issn        *IssnType          `xml:"issn"`
	Isbn        *IsbnType          `xml:"isbn"`
	Datecit     *DatecitType       `xml:"datecit"`
	Srchterm    []*SrchtermType    `xml:"srchterm"`
	Srchdate    *SrchdateType      `xml:"srchdate"`
	Refno       []*RefnoType       `xml:"refno"`
}

// Online is *******************************
//
//	ONLINE CITATION
//	*******************************
//
//	Online citations
//	Revised according to ISO-690-2 - Electronic documents and parts thereof.
//	Please refer to this standard for definitions and examples.
//	See: http://www.nlc-bnc.ca/iso/tc46sc9/standard/690-2e.htm#Contents
//
//	The tagging in fact is a mixture of article and book tags together with
//	specific electronic source tags.
//	'online' is taken to mean ANY kind of electronic documentation:
//	databases, internet, CD-Roms, DVD, email, etc
//
//	EXAMPLES:;
//
//	* Complete monograph
//	Kirk-Othmer Encyclopedia of Chemical Technology [online].
//	3rd ed. New York : John Wiley, 1984 [cited 3 January 1990].
//	Available from: DIALOG Information Services, Palo Alto (Calif.).
//
//	<nplcit id='ncit0001' num='0001' type="e" medium='online'>
//	<online>
//	<online-title>Kirk-Othmer Encyclopedia of Chemical Technology
//	</online-title>
//	<edition>3rd ed.</edition>
//	<imprint>
//	<address>
//	<text>New York</text>
//	</address>
//	<name>John Wiley</name>
//	<pubdate>19840000</pubdate>
//	</imprint>
//	<avail>DIALOG Information Services, Palo Alto (Calif.).</avail>
//	<datecit>
//	<date>19900103</date>
//	</datecit>
//	</online>
//	</nplcit>
//
//	* Article on the Internet:
//	Clark, Carol. On the Threshold of a Brave New World.
//	In Blueprint of the Body [online].
//	CNN.com, 2000. [cited 24 August 2000;10:25 EST]. In-depth specials.
//	Available from: [http://www.cnn.com/SPECIALS/2000/genome/story/overview/]
//
//	<nplcit id='ncit0002' num='0002' type='e' medium='online'>
//	<online>
//	<author>
//	<name>Clark, Carol</name>
//	</author>
//	<online-title>On the Threshold of a Brave New World</online-title>
//	<imprint>
//	<name>CNN.com, </name>
//	<pubdate>2000</pubdate>
//	</imprint>
//	<series>
//	<text>In-depth specials</text>
//	</series>
//	<avail>Available from: [http://www.cnn.com/SPECIALS/2000/genome/story/overview/]</avail>
//	<datecit>
//	<date>[cited 24 August 2000;10:25 EST]</date>
//	</datecit>
//	</online>
//	</nplcit>
//
//	* Personal communication (e-mail)
//
//	Thacker, Jane. MPEG-21 project stream on digital item identification
//	[online].
//	Message to: [iso.tc46.sc9@nlc-bnc.ca]. 3 October 2000; 13:33 EST [cited 6
//	October 2000; 13:10 EST].
//	Message-ID: [002f01c02d60$051a64a0$22a2580c@vaio]. Personal communication.
//
//	<nplcit id='ncit0003' num='0003' type='e' medium='online'>
//	<online>
//	<author>
//	<name>Thacker, Jane</name>
//	</author>
//	<online-title>MPEG-21 project stream on digital item identification
//	</online-title>
//	<subname>
//	<name>Message to: <iso.tc46.sc9@nlc-bnc.ca></name>
//	</subname>
//	<pubdate>3 October 2000; 13:33 EST</pubdate>
//	<notes>Personal communication</notes>
//	<avail>Message-ID: <002f01c02d60$051a64a0$22a2580c@vaio></avail>
//	<datecit><date>6 October 2000; 13:10 EST</date></datecit>
//	</online>
//	</nplcit>
//
//	Note: not covered in current version of PatXML
type Online *OnlineType

// SrchdateType ...
type SrchdateType struct {
	XMLName xml.Name `xml:"srchdate"`
	Date    int      `xml:"date"`
}

// Srchdate is Date of search/retrieval YYYYMMDD
type Srchdate *SrchdateType

// Srchterm is Search terms
type Srchterm *SrchtermType

// SrchtermType ...
type SrchtermType struct {
	XMLName xml.Name `xml:"srchterm"`
	Value   string   `xml:",chardata"`
}

// DatecitType ...
type DatecitType struct {
	XMLName xml.Name `xml:"datecit"`
	Date    int      `xml:"date"`
}

// Datecit is Date cited - date on which the citation was cited.
//
//	May be different from srchdate below
type Datecit *DatecitType

// AvailType ...
type AvailType struct {
	XMLName xml.Name `xml:"avail"`
	Value   string   `xml:",chardata"`
}

// Avail is Availability and access - REQUIRED use for URL, online database, ftp address,
//
//	email, etc.;
//	Examples:
//	- Available from Internet: http://www.epoline.org
//	- Available from DIALOG Information Systems, Palo Alto (Calif.)
//	- Available from: <http://www.ejb.org/content/vol2/issue3/full/3/index.html>.
//	- Available from Bell and Howell Information and Learning via e-mail to:
//	<umi@ppp.nasionet.net>.
type Avail *AvailType

// HostnoType ...
type HostnoType struct {
	XMLName xml.Name `xml:"hostno"`
	Value   string   `xml:",chardata"`
}

// Hostno is Numeration within host document
type Hostno *HostnoType

// HistoryType ...
type HistoryType struct {
	XMLName  xml.Name      `xml:"history"`
	Text     *TextType     `xml:"text"`
	Received *ReceivedType `xml:"received"`
	Accepted *AcceptedType `xml:"accepted"`
	Revised  *RevisedType  `xml:"revised"`
	Misc     *MiscType     `xml:"misc"`
}

// History is History of the article (not serial)
type History *HistoryType

// MiscType ...
type MiscType struct {
	XMLName xml.Name `xml:"misc"`
	Date    []int    `xml:"date"`
}

// Misc is Miscellaneous information relating to the history of the article; see ISO 12083
type Misc *MiscType

// RevisedType ...
type RevisedType struct {
	XMLName xml.Name `xml:"revised"`
	Date    int      `xml:"date"`
}

// Revised is Date article was revised
type Revised *RevisedType

// Accepted is Date article was accepted
type Accepted *AcceptedType

// AcceptedType ...
type AcceptedType struct {
	XMLName xml.Name `xml:"accepted"`
	Date    int      `xml:"date"`
}

// ReceivedType ...
type ReceivedType struct {
	XMLName xml.Name `xml:"received"`
	Date    int      `xml:"date"`
}

// Received is Date article was received
type Received *ReceivedType

// HosttitleType ...
type HosttitleType struct {
	XMLName xml.Name `xml:"hosttitle"`
	Value   string   `xml:",chardata"`
}

// Hosttitle is Title of the host document/database
type Hosttitle *HosttitleType

// OnlinetitleType ...
type OnlinetitleType struct {
	XMLName xml.Name `xml:"online-title"`
	Value   string   `xml:",chardata"`
}

// Onlinetitle is The title within the electronic resource,
//
//	equal to <atl> and <book-title>
type Onlinetitle *OnlinetitleType

// ArticleType ...
type ArticleType struct {
	XMLName  xml.Name       `xml:"article"`
	Text     *TextType      `xml:"text"`
	Author   []*AuthorType  `xml:"author"`
	Atl      *AtlType       `xml:"atl"`
	Subname  []*SubnameType `xml:"subname"`
	Serial   *SerialType    `xml:"serial"`
	Book     *BookType      `xml:"book"`
	Absno    *AbsnoType     `xml:"absno"`
	Location *LocationType  `xml:"location"`
	Class    []*ClassType   `xml:"class"`
	Keyword  []*KeywordType `xml:"keyword"`
	Cpyrt    *CpyrtType     `xml:"cpyrt"`
	Artid    *ArtidType     `xml:"artid"`
	Srchdate *SrchdateType  `xml:"srchdate"`
	Refno    []*RefnoType   `xml:"refno"`
}

// Article is *******************************
//
//	ARTICLE CITATION
//	*******************************
//
//	Article citations within a 'host' document
//
//	After patent citations the most common citations are articles within serials
//	(periodicals, magazines), books and electronic (eg. internet) sources).
//	This is a very complex and varied area to standardise. The tag set below is drawn
//	from a number of sources as is the order of the tags (which in any case can be
//	changed depending on the stylesheet used).
//
//	EPO and PatXML usage:
//
//	id="ncit0001" or id="sr-ncit0001"
//	num="0001"
//	npl-type="s"
//
//	The order of tags is (generally) that of WIPO ST.14 / ISO 690 layout:
//
//	Examples:
//
//	DROP, J.G. Integrated Circuit Personalization at the Module Level. IBM tech. dis. bull.
//	October 1974, Vol.17, No.5, pages 1344 and 1345, ISSN 2345-6789.
//	[XPnnnnnnnnnnn].
//
//	As a *Search Report* citation the markup is:
//
//	<citation>
//	<nplcit id='ncit0012' num='0012' npl-type='s' file='XP1234456'>
//	<article>
//	<author>
//	<name>DROP, J.G.</name>
//	</author>
//	<atl>Integrated Circuit Personalization at the Module Level</atl>
//	<serial>
//	<sertitle>IBM Tech. Dis. Bull.</sertitle>
//	<pubdate>October 1974</pubdate>
//	<vid>17</vid>
//	<ino>5</ino>
//	<issn>2345-6789</issn>
//	</serial>
//	<refno id='XP1'>XP1234456</refno>
//	</article>
//	<rel-passage>
//	<passage>p. 1344 and 1345</passage>
//	</rel-passage>
//	</nplcit>
//	</citation>
//
//	Outside the SR it would be (after </serial>):
//	<location>
//	<pp>p. 1344 and 1345</pp>
//	</location>
//
//	BIOLOGICAL ABSTRACTS, vol. 1, 1996 Philadelphia, PA, US; abstract no. 193987,
//	SEVENIER, ROBERT ET AL: "Ethylene production and involvement during the first
//	steps of durum wheat (Triticum durum) anther culture." XP002133847
//
//	<citation>
//	<nplcit id="sr-ncit0001" num="0001" npl-type"i">
//	<article>
//	<author><name>SEVENIER, ROBERT ET AL</name><author>
//	<atl>"Ethylene production and involvement during the first
//	steps of durum wheat (Triticum durum) anther culture."</atl>
//	<serial>
//	<sertitle>BIOLOGICAL ABSTRACTS</sertitle>
//	<imprint><text>Philadelphia, PA, US</text></imprint>
//	<pubdate>1996</pubdate>
//	<vid>vol. 1</vid>
//	</serial>
//	<absno>abstract no. 193987</absno>
//	<refno>XP002133847</refno>
//	</article>
//	</nplcit>
//	</citation>
//
//	Note: it is NOT expected that the applicant will create the tagged data
//	- it can be generated from a 'pull down' data entry form (eg. in Word) or
//	generated from internal SR databases or use PatXML.
//
//	In the EPO for the SR we extract from SDMS. .
type Article *ArticleType

// ArtidType ...
type ArtidType struct {
	XMLName xml.Name `xml:"artid"`
	Value   string   `xml:",chardata"`
}

// Artid is Article unique ID - assigned by a eg. publisher to an article
type Artid *ArtidType

// BookType ...
type BookType struct {
	XMLName    xml.Name         `xml:"book"`
	Text       *TextType        `xml:"text"`
	Author     []*AuthorType    `xml:"author"`
	Booktitle  []*BooktitleType `xml:"book-title"`
	Conference *ConferenceType  `xml:"conference"`
	Subtitle   *SubtitleType    `xml:"subtitle"`
	Subname    []*SubnameType   `xml:"subname"`
	Edition    *EditionType     `xml:"edition"`
	Imprint    *ImprintType     `xml:"imprint"`
	Vid        *VidType         `xml:"vid"`
	Ino        *InoType         `xml:"ino"`
	Descrip    *DescripType     `xml:"descrip"`
	Series     *SeriesType      `xml:"series"`
	Notes      *NotesType       `xml:"notes"`
	Absno      *AbsnoType       `xml:"absno"`
	Location   []*LocationType  `xml:"location"`
	Pubid      *PubidType       `xml:"pubid"`
	Bookno     *BooknoType      `xml:"bookno"`
	Class      []*ClassType     `xml:"class"`
	Keyword    []*KeywordType   `xml:"keyword"`
	Cpyrt      *CpyrtType       `xml:"cpyrt"`
	Doi        *DoiType         `xml:"doi"`
	Issn       []*IssnType      `xml:"issn"`
	Isbn       []*IsbnType      `xml:"isbn"`
	Refno      []*RefnoType     `xml:"refno"`
}

// Book is *******************************
//
//	BOOK (MONOGRAPH) CITATION
//	*******************************
//
//	Non-serial bibliographic item, i.e. an item either complete in
//	one part or complete (or intended to be completed) in a
//	finite number of separate parts. [ISO 690:1987]
//
//	As mentioned the style and manner of actual display/printing varies greatly
//	(even between standards!). Generally in the order specified by
//	WIPO ST.14 and ISO 690 and AACR2 rules for layout
//
//	EPO and PatXML usage:
//
//	id="ncit0001"
//	num="0001"
//	npl-type="b"
//
//	Example:
//
//	(citation from ST.14).
//
//	WALTON, Herrmann. Microwave Quantum Theory.
//	London: Sweet and Maxwell, 1973, Vol.2,
//	ISBN 5-1234-5678-9,
//	pages 138 to 192, especially pages 146 to 148.
//
//	As a *Search Report* citation the markup is:
//
//	<srep-citations>
//	<citation>
//	<nplcit id='ncit0013' num='0013' type='b'>
//	<book>
//	<author>
//	<name>WALTON, Herrman</name>
//	</author>
//	<book-title>Microwave quantum theory</book-title>
//	<imprint>
//	<address>
//	<text>London</text>
//	</address>
//	<name>Sweet and Maxwell</name>
//	<pubdate>1973</pubdate>
//	</imprint>
//	<vid>Vol. 2</vid>
//	<isbn>ISBN 5-1234-5678-9</isbn>
//	</book>
//	</nplcit>
//	<rel-passage>pages 138 to 192, especially pages 146 to 148</rel-passage>
//	</citation>
//	</srep-citations>
//
//	In other citations the <rel-passage> would be replaced by the <location> tag
//	after <vid>.
type Book *BookType

// KeywordType ...
type KeywordType struct {
	XMLName xml.Name `xml:"keyword"`
	Value   string   `xml:",chardata"`
}

// Keyword is Keyword; e.g., from a Thesaurus or class. scheme
//
//	(ST.32:B550)
type Keyword *KeywordType

// BooknoType ...
type BooknoType struct {
	XMLName xml.Name `xml:"bookno"`
	Value   string   `xml:",chardata"`
}

// Bookno is *******************************
//
//	Book number
type Bookno *BooknoType

// LocationType ...
type LocationType struct {
	XMLName xml.Name     `xml:"location"`
	Text    *TextType    `xml:"text"`
	Serpart *SerpartType `xml:"serpart"`
	Sersect *SersectType `xml:"sersect"`
	Chapter *ChapterType `xml:"chapter"`
	Pp      *PpType      `xml:"pp"`
	Column  *ColumnType  `xml:"column"`
	Para    *ParaType    `xml:"para"`
	Line    *LineType    `xml:"line"`
}

// Location is *******************************
//
//	LOCATION
//	*******************************
//	Location of the reference within the cited work
type Location *LocationType

// LineType ...
type LineType struct {
	XMLName xml.Name     `xml:"line"`
	Linef   []*LinefType `xml:"linef"`
	Linel   []*LinelType `xml:"linel"`
}

// Line is Referenced line within cited work
type Line *LineType

// LinelType ...
type LinelType struct {
	XMLName xml.Name `xml:"linel"`
	Value   string   `xml:",chardata"`
}

// Linel is Cited document line last
type Linel *LinelType

// LinefType ...
type LinefType struct {
	XMLName xml.Name `xml:"linef"`
	Value   string   `xml:",chardata"`
}

// Linef is Cited document line first
type Linef *LinefType

// ParaType ...
type ParaType struct {
	XMLName xml.Name     `xml:"para"`
	Paraf   []*ParafType `xml:"paraf"`
	Paral   []*ParalType `xml:"paral"`
}

// Para is Referenced paragraph within cited work
type Para *ParaType

// ParalType ...
type ParalType struct {
	XMLName xml.Name `xml:"paral"`
	Value   string   `xml:",chardata"`
}

// Paral is Cited paragraph last
type Paral *ParalType

// ParafType ...
type ParafType struct {
	XMLName xml.Name `xml:"paraf"`
	Value   string   `xml:",chardata"`
}

// Paraf is Cited paragraph first
type Paraf *ParafType

// ColumnType ...
type ColumnType struct {
	XMLName xml.Name    `xml:"column"`
	Colf    []*ColfType `xml:"colf"`
	Coll    []*CollType `xml:"coll"`
}

// Column is Cited document column numbers
type Column *ColumnType

// CollType ...
type CollType struct {
	XMLName xml.Name `xml:"coll"`
	Value   string   `xml:",chardata"`
}

// Coll is Cited document column last
type Coll *CollType

// ColfType ...
type ColfType struct {
	XMLName xml.Name `xml:"colf"`
	Value   string   `xml:",chardata"`
}

// Colf is Cited document column first
type Colf *ColfType

// PpType ...
type PpType struct {
	XMLName xml.Name   `xml:"pp"`
	Ppf     []*PpfType `xml:"ppf"`
	Ppl     []*PplType `xml:"ppl"`
}

// Pp is Cited document page numbers
type Pp *PpType

// PplType ...
type PplType struct {
	XMLName xml.Name `xml:"ppl"`
	Value   string   `xml:",chardata"`
}

// Ppl is Cited document page last
type Ppl *PplType

// PpfType ...
type PpfType struct {
	XMLName xml.Name `xml:"ppf"`
	Value   string   `xml:",chardata"`
}

// Ppf is Cited document page first
type Ppf *PpfType

// ChapterType ...
type ChapterType struct {
	XMLName xml.Name `xml:"chapter"`
	Value   string   `xml:",chardata"`
}

// Chapter is Chapter; normally in a book. Example: Chapter 2
type Chapter *ChapterType

// SersectType ...
type SersectType struct {
	XMLName xml.Name `xml:"sersect"`
	Value   string   `xml:",chardata"`
}

// Sersect is Serial section or book; or the book section
type Sersect *SersectType

// SerpartType ...
type SerpartType struct {
	XMLName xml.Name `xml:"serpart"`
	Value   string   `xml:",chardata"`
}

// Serpart is Part within a serial or book; or the book part
type Serpart *SerpartType

// Absno is Abstract number
type Absno *AbsnoType

// AbsnoType ...
type AbsnoType struct {
	XMLName xml.Name `xml:"absno"`
	Value   string   `xml:",chardata"`
}

// SeriesType ...
type SeriesType struct {
	XMLName xml.Name  `xml:"series"`
	Text    *TextType `xml:"text"`
	Mst     *MstType  `xml:"mst"`
	Msn     *MsnType  `xml:"msn"`
	Issn    *IssnType `xml:"issn"`
}

// Series is *******************************
//
//	SERIES
//	*******************************
//	Series statement
type Series *SeriesType

// MsnType ...
type MsnType struct {
	XMLName xml.Name `xml:"msn"`
	Value   string   `xml:",chardata"`
}

// Msn is Monographic series number
type Msn *MsnType

// MstType ...
type MstType struct {
	XMLName xml.Name `xml:"mst"`
	Value   string   `xml:",chardata"`
}

// Mst is Monographic series title
type Mst *MstType

// EditionType ...
type EditionType struct {
	XMLName xml.Name `xml:"edition"`
	Value   string   `xml:",chardata"`
}

// Edition is Edition statement
//
//	eg. 2nd edition
type Edition *EditionType

// SubtitleType ...
type SubtitleType struct {
	XMLName xml.Name `xml:"subtitle"`
	Value   string   `xml:",chardata"`
}

// Subtitle is *******************************
//
//	Book subtitle
type Subtitle *SubtitleType

// ConferenceType ...
type ConferenceType struct {
	XMLName     xml.Name           `xml:"conference"`
	Text        *TextType          `xml:"text"`
	Conftitle   *ConftitleType     `xml:"conftitle"`
	Date        int                `xml:"date"`
	Confdate    *ConfdateType      `xml:"confdate"`
	Confno      *ConfnoType        `xml:"confno"`
	Confplace   *ConfplaceType     `xml:"confplace"`
	Confsponsor []*ConfsponsorType `xml:"confsponsor"`
}

// Conference is *******************************
//
//	CONFERENCE CITATION
//	*******************************
//
//	There is no standard way of citing conference proceedings; date of the conf. may
//	come before or after place, for example. The tags are specified in a set order
//	where it is not possible or correct then simply use <text>
//
//	Note: not in current version of PatXML
type Conference *ConferenceType

// ConfdateType ...
type ConfdateType struct {
	XMLName xml.Name `xml:"confdate"`
	*RangedateType
}

// RangedateType ...
type RangedateType struct {
	XMLName xml.Name     `xml:"rangedate"`
	Sdate   []*SdateType `xml:"sdate"`
	Edate   []*EdateType `xml:"edate"`
	Time    []*TimeType  `xml:"time"`
}

// ConfsponsorType ...
type ConfsponsorType struct {
	XMLName     xml.Name           `xml:"confsponsor"`
	Addressbook []*AddressbookType `xml:"addressbook"`
}

// Confsponsor is Conference sponsor
type Confsponsor *ConfsponsorType

// ConfplaceType ...
type ConfplaceType struct {
	XMLName xml.Name       `xml:"confplace"`
	Address []*AddressType `xml:"address"`
}

// Confplace is Conference place
type Confplace *ConfplaceType

// ConfnoType ...
type ConfnoType struct {
	XMLName xml.Name `xml:"confno"`
	Value   string   `xml:",chardata"`
}

// Confno is Conference number
type Confno *ConfnoType

// ConftitleType ...
type ConftitleType struct {
	XMLName xml.Name `xml:"conftitle"`
	Value   string   `xml:",chardata"`
}

// Conftitle is Conference title
type Conftitle *ConftitleType

// BooktitleType ...
type BooktitleType struct {
	XMLName xml.Name `xml:"book-title"`
	Value   string   `xml:",chardata"`
}

// Booktitle is The title of the cited book
type Booktitle *BooktitleType

// SerialType ...
type SerialType struct {
	XMLName   xml.Name       `xml:"serial"`
	Newsgroup *NewsgroupType `xml:"newsgroup"`
	Sertitle  *SertitleType  `xml:"sertitle"`
	Alttitle  *AlttitleType  `xml:"alttitle"`
	Subname   []*SubnameType `xml:"subname"`
	Issue     *IssueType     `xml:"issue"`
	Imprint   *ImprintType   `xml:"imprint"`
	Pubdate   *PubdateType   `xml:"pubdate"`
	Descrip   *DescripType   `xml:"descrip"`
	Notes     *NotesType     `xml:"notes"`
	Pubid     *PubidType     `xml:"pubid"`
	Vid       *VidType       `xml:"vid"`
	Ino       *InoType       `xml:"ino"`
	Doi       *DoiType       `xml:"doi"`
	Issn      *IssnType      `xml:"issn"`
	Isbn      *IsbnType      `xml:"isbn"`
	Cpyrt     *CpyrtType     `xml:"cpyrt"`
}

// Serial is Serial citation data:
//
//	Serial: Publication, in any medium, issued in successive
//	parts, usually having numeric or chronological designations,
//	and intended to be continued indefinitely. [Adapted from ISO 3297:1986]
//
//	This describes the volume or issue as a whole and not
//	a particular article within it.
type Serial *SerialType

// CpyrtType ...
type CpyrtType struct {
	XMLName xml.Name `xml:"cpyrt"`
	Value   string   `xml:",chardata"`
}

// Cpyrt is Copyright info. Copyright of publisher of serial
type Cpyrt *CpyrtType

// IsbnType ...
type IsbnType struct {
	XMLName xml.Name `xml:"isbn"`
	Value   string   `xml:",chardata"`
}

// Isbn is International Standard Book Number
type Isbn *IsbnType

// IssnType ...
type IssnType struct {
	XMLName xml.Name `xml:"issn"`
	Value   string   `xml:",chardata"`
}

// Issn is International Standard Serial Number
type Issn *IssnType

// InoType ...
type InoType struct {
	XMLName xml.Name `xml:"ino"`
	Value   string   `xml:",chardata"`
}

// Ino is Issue number
type Ino *InoType

// DoiType ...
type DoiType struct {
	XMLName xml.Name `xml:"doi"`
	Value   string   `xml:",chardata"`
}

// Doi is Digital Object Identifier
type Doi *DoiType

// VidType ...
type VidType struct {
	XMLName xml.Name `xml:"vid"`
	Value   string   `xml:",chardata"`
}

// Vid is Volume id/number
type Vid *VidType

// PubidType ...
type PubidType struct {
	XMLName xml.Name `xml:"pubid"`
	Value   string   `xml:",chardata"`
}

// Pubid is Publisher's unique id
type Pubid *PubidType

// NotesType ...
type NotesType struct {
	XMLName xml.Name `xml:"notes"`
	Value   string   `xml:",chardata"`
}

// Notes is Notes about the serial; e.g. Continues Journal of XYZ 1910-1998, published in
//
//	French and English, etc.
type Notes *NotesType

// DescripType ...
type DescripType struct {
	XMLName xml.Name `xml:"descrip"`
	Value   string   `xml:",chardata"`
}

// Descrip is This element is used for the physical description
//
//	of a book or serial; it pagination, size, whether it is illustrated, etc
//	- generally NOT used in citations in patents. Therefore there is no
//	detailed breakdown of the possible lower elements such as physical size.
//
//	Example: xxvi, 233 p.: ill; 27cm
type Descrip *DescripType

// ImprintType ...
type ImprintType struct {
	XMLName xml.Name       `xml:"imprint"`
	Text    *TextType      `xml:"text"`
	Address *AddressType   `xml:"address"`
	Name    *NameType      `xml:"name"`
	Pubdate []*PubdateType `xml:"pubdate"`
}

// Imprint is Imprint:
//
//	Publication / creation data
//	Place of publication : publisher, date(s) of publication
//	usually only date of publication is used for journal citations
type Imprint *ImprintType

// PubdateType ...
type PubdateType struct {
	XMLName xml.Name `xml:"pubdate"`
	*RangedateType
}

// Pubdate is Publication date used in npl citations,
//
//	may be structured or unstructured
type Pubdate *PubdateType

// TimeType ...
type TimeType struct {
	XMLName xml.Name `xml:"time"`
	Value   string   `xml:",chardata"`
}

// Time is Time; format HHMM
type Time *TimeType

// EdateType ...
type EdateType struct {
	XMLName xml.Name `xml:"edate"`
	Value   string   `xml:",chardata"`
}

// Edate is End date used in pubdate
type Edate *EdateType

// SdateType ...
type SdateType struct {
	XMLName xml.Name `xml:"sdate"`
	Value   string   `xml:",chardata"`
}

// Sdate is Start date used in pubdate
type Sdate *SdateType

// IssueType ...
type IssueType struct {
	XMLName xml.Name `xml:"issue"`
	Value   string   `xml:",chardata"`
}

// Issue is Issue designation;
//
//	Examples:
//	- Annual
//	- 1971-
//	- 1890-1972
type Issue *IssueType

// AlttitleType ...
type AlttitleType struct {
	XMLName xml.Name `xml:"alttitle"`
	Value   string   `xml:",chardata"`
}

// Alttitle is Alternate title for serial; e.g. BMJ = British Medical Journal
type Alttitle *AlttitleType

// NewsgroupType ...
type NewsgroupType struct {
	XMLName xml.Name `xml:"newsgroup"`
	Value   string   `xml:",chardata"`
}

// SertitleType ...
type SertitleType struct {
	XMLName xml.Name `xml:"sertitle"`
	Value   string   `xml:",chardata"`
}

// Sertitle is Serial title; the host document:
//
//	host document: Document containing contributions or separately
//	identifiable component parts that are not physically or
//	bibliographically independent. [ISO 690:1987]
type Sertitle *SertitleType

// AtlType ...
type AtlType struct {
	XMLName xml.Name `xml:"atl"`
	Value   string   `xml:",chardata"`
}

// Atl is Article title
type Atl *AtlType

// DtextType ...
type DtextType struct {
	XMLName xml.Name `xml:"dtext"`
	Value   string   `xml:",chardata"`
}

// Dtext is Descriptive text
type Dtext *DtextType

// EadType ...
type EadType struct {
	XMLName xml.Name `xml:"ead"`
	Value   string   `xml:",chardata"`
}

// Ead is Electronic address use for other than email
type Ead *EadType

// UrlType ...
type UrlType struct {
	XMLName xml.Name `xml:"url"`
	Value   string   `xml:",chardata"`
}

// Url is Universal Resource Locator; e.g. www.wipo.int
type Url *UrlType

// EmailType ...
type EmailType struct {
	XMLName xml.Name `xml:"email"`
	Value   string   `xml:",chardata"`
}

// Email is Email address
type Email *EmailType

// FaxType ...
type FaxType struct {
	XMLName xml.Name `xml:"fax"`
	Value   string   `xml:",chardata"`
}

// Fax is Fax number
type Fax *FaxType

// PhoneType ...
type PhoneType struct {
	XMLName xml.Name `xml:"phone"`
	Value   string   `xml:",chardata"`
}

// Phone is Telephone number
type Phone *PhoneType

// Address is Address components:
//
//	Address formats differ from country to country
//	If no structure possible use text
type Address *AddressType

// AddressType ...
type AddressType struct {
	XMLName      xml.Name          `xml:"address"`
	Address1     *Address1Type     `xml:"address-1"`
	Address2     *Address2Type     `xml:"address-2"`
	Address3     *Address3Type     `xml:"address-3"`
	Mailcode     *MailcodeType     `xml:"mailcode"`
	Pobox        *PoboxType        `xml:"pobox"`
	Room         *RoomType         `xml:"room"`
	Addressfloor *AddressfloorType `xml:"address-floor"`
	Building     *BuildingType     `xml:"building"`
	Street       *StreetType       `xml:"street"`
	City         *CityType         `xml:"city"`
	County       *CountyType       `xml:"county"`
	State        *StateType        `xml:"state"`
	Postcode     *PostcodeType     `xml:"postcode"`
	Country      string            `xml:"country"`
	Text         *TextType         `xml:"text"`
}

// PostcodeType ...
type PostcodeType struct {
	XMLName xml.Name `xml:"postcode"`
	Value   string   `xml:",chardata"`
}

// Postcode is Postal code or zip code
type Postcode *PostcodeType

// StateType ...
type StateType struct {
	XMLName xml.Name `xml:"state"`
	Value   string   `xml:",chardata"`
}

// State is Region of country; e.g., state, province, etc.
type State *StateType

// CountyType ...
type CountyType struct {
	XMLName xml.Name `xml:"county"`
	Value   string   `xml:",chardata"`
}

// County is County, parish, department, etc (mainly UK, USA)
type County *CountyType

// CityType ...
type CityType struct {
	XMLName xml.Name `xml:"city"`
	Value   string   `xml:",chardata"`
}

// City is City or town name
type City *CityType

// StreetType ...
type StreetType struct {
	XMLName xml.Name `xml:"street"`
	Value   string   `xml:",chardata"`
}

// Street is Street may contain house number or name
type Street *StreetType

// BuildingType ...
type BuildingType struct {
	XMLName xml.Name `xml:"building"`
	Value   string   `xml:",chardata"`
}

// Building is Building information in address; e.g., Hoffman building
type Building *BuildingType

// AddressfloorType ...
type AddressfloorType struct {
	XMLName xml.Name `xml:"address-floor"`
	Value   string   `xml:",chardata"`
}

// Addressfloor is Address floor; e.g., 10th
type Addressfloor *AddressfloorType

// RoomType ...
type RoomType struct {
	XMLName xml.Name `xml:"room"`
	Value   string   `xml:",chardata"`
}

// Room is Address room; e.g., Room 55B
type Room *RoomType

// PoboxType ...
type PoboxType struct {
	XMLName xml.Name `xml:"pobox"`
	Value   string   `xml:",chardata"`
}

// Pobox is Post Office Box number
type Pobox *PoboxType

// MailcodeType ...
type MailcodeType struct {
	XMLName xml.Name `xml:"mailcode"`
	Value   string   `xml:",chardata"`
}

// Mailcode is Organizational mail code
type Mailcode *MailcodeType

// Address3Type ...
type Address3Type struct {
	XMLName xml.Name `xml:"address-3"`
	Value   string   `xml:",chardata"`
}

// Address3 is Address, third line
type Address3 *Address3Type

// Address2Type ...
type Address2Type struct {
	XMLName xml.Name `xml:"address-2"`
	Value   string   `xml:",chardata"`
}

// Address2 is Address, second line
type Address2 *Address2Type

// Address1Type ...
type Address1Type struct {
	XMLName xml.Name `xml:"address-1"`
	Value   string   `xml:",chardata"`
}

// Address1 is Address, first line
type Address1 *Address1Type

// NameGroup ...
type NameGroup struct {
	XMLName          xml.Name `xml:"nameGroup"`
	Name             *NameType
	Prefix           *PrefixType
	Lastname         *LastnameType
	Firstname        *FirstnameType
	Middlename       *MiddlenameType
	Suffix           *SuffixType
	Iid              *IidType
	Role             *RoleType
	Orgname          *OrgnameType
	Department       *DepartmentType
	Synonym          []*SynonymType
	Registerednumber *RegisterednumberType
}

// RegisterednumberType ...
type RegisterednumberType struct {
	XMLName xml.Name `xml:"registered-number"`
	Value   string   `xml:",chardata"`
}

// Registerednumber is Registered number
type Registerednumber *RegisterednumberType

// SynonymType ...
type SynonymType struct {
	XMLName xml.Name `xml:"synonym"`
	Value   string   `xml:",chardata"`
}

// Synonym is Synonym
type Synonym *SynonymType

// DepartmentType ...
type DepartmentType struct {
	XMLName xml.Name `xml:"department"`
	Value   string   `xml:",chardata"`
}

// Department is Department, division, section, etc. name
type Department *DepartmentType

// SuffixType ...
type SuffixType struct {
	XMLName xml.Name `xml:"suffix"`
	Value   string   `xml:",chardata"`
}

// Suffix is Name suffix (e.g., II, Jr., Dip., Ing., BA, etc.)
type Suffix *SuffixType

// PrefixType ...
type PrefixType struct {
	XMLName xml.Name `xml:"prefix"`
	Value   string   `xml:",chardata"`
}

// Prefix is Title: e.g., Mr., Mrs., Dr. etc
type Prefix *PrefixType

// RoleType ...
type RoleType struct {
	XMLName xml.Name `xml:"role"`
	Value   string   `xml:",chardata"`
}

// Role is Role; e.g., President, Chairman, etc.
type Role *RoleType

// IidType ...
type IidType struct {
	XMLName xml.Name `xml:"iid"`
	Value   string   `xml:",chardata"`
}

// Iid is Individual id
type Iid *IidType

// OrgnameType ...
type OrgnameType struct {
	XMLName xml.Name `xml:"orgname"`
	Value   string   `xml:",chardata"`
}

// Orgname is Organisation name or company name
type Orgname *OrgnameType

// MiddlenameType ...
type MiddlenameType struct {
	XMLName xml.Name `xml:"middle-name"`
	Value   string   `xml:",chardata"`
}

// Middlename is Middle name(s) or initial(s)
type Middlename *MiddlenameType

// FirstnameType ...
type FirstnameType struct {
	XMLName xml.Name `xml:"first-name"`
	Value   string   `xml:",chardata"`
}

// Firstname is First or given name(s), initial(s)
type Firstname *FirstnameType

// LastnameType ...
type LastnameType struct {
	XMLName xml.Name `xml:"last-name"`
	Value   string   `xml:",chardata"`
}

// Lastname is Last, family, surname
type Lastname *LastnameType

// RelpassageType ...
type RelpassageType struct {
	XMLName   xml.Name       `xml:"rel-passage"`
	Text      *TextType      `xml:"text"`
	Passage   []*PassageType `xml:"passage"`
	Category  *CategoryType  `xml:"category"`
	Relclaims *RelclaimsType `xml:"rel-claims"`
}

// Relpassage is Relevant passage group within patent; most used in search reports. With regards to passage, references
//
//	other than location included for EPO internal use only
type Relpassage *RelpassageType

// RelclaimsType ...
type RelclaimsType struct {
	XMLName xml.Name `xml:"rel-claims"`
	Value   string   `xml:",chardata"`
}

// Relclaims is Relevant claims
//
//	see example above
type Relclaims *RelclaimsType

// CategoryType ...
type CategoryType struct {
	XMLName xml.Name `xml:"category"`
	Value   string   `xml:",chardata"`
}

// Category is Category - see example above
//
//	Categories indicating cited documents (references) of particular relevance, for the EPO:
//
//	Category X: particularly relevant if taken alone;
//	Y: particularly relevant if taken combined with another document of the same category
//	A: technological background
//	O: non-written disclosure
//	P: intermediate document
//	T: theory or principle underlying the invention
//	E: earlier patent document, but published on ,or after the filing date;
//	D: document cited in the application
//	L: document cited for other reasons
//
//	&: member of the same patent family, corresponding document
type Category *CategoryType

// PassageType ...
type PassageType struct {
	XMLName  xml.Name `xml:"passage"`
	Pp       string   `xml:"pp"`
	Ppf      string   `xml:"ppf"`
	Ppl      string   `xml:"ppl"`
	Column   string   `xml:"column"`
	Colf     string   `xml:"colf"`
	Coll     string   `xml:"coll"`
	Para     string   `xml:"para"`
	Paraf    string   `xml:"paraf"`
	Paral    string   `xml:"paral"`
	Line     string   `xml:"line"`
	Linef    string   `xml:"linef"`
	Linel    string   `xml:"linel"`
	Claim    string   `xml:"claim"`
	Figure   string   `xml:"figure"`
	Example  string   `xml:"example"`
	Table    string   `xml:"table"`
	Sequence string   `xml:"sequence"`
	Compound string   `xml:"compound"`
	Bookmark string   `xml:"bookmark"`
}

// Passage is Passage within the cited patent literature. References included for EPO internal use only
type Passage *PassageType

// Date is Date: components of a date. Format: YYYYMMDD
type Date int

// ICEdatetype ...
type ICEdatetype *IntType

// KindType ...
type KindType struct {
	XMLName xml.Name `xml:"kind"`
	Value   string   `xml:",chardata"`
}

// Kind is Document kind code; e.g., A1
//
//	(INID 13, ST.32:B130)
type Kind *KindType

// DocnumberType ...
type DocnumberType struct {
	XMLName xml.Name `xml:"doc-number"`
	Value   string   `xml:",chardata"`
}

// Docnumber is The number of the referenced patent (or application) document
type Docnumber *DocnumberType

// Country is Country: use ST.3 country code; e.g. DE, FR, GB, NL, etc.
//
//	Also includes EP, WO. Always in upper case. Also can use "stateless"
type Country string

// CountryType is Zimbabwe
type CountryType string

// TextType ...
type TextType struct {
	XMLName xml.Name `xml:"text"`
	Value   string   `xml:",chardata"`
}

// Text is If no structure is possible, enter text (without markup)
type Text *TextType

// PreAttlist ...
type PreAttlist struct {
	XMLName         xml.Name `xml:"pre.attlist"`
	XmlSpaceAttr    string   `xml:"xml:space,attr,omitempty"`
	IdAttr          string   `xml:"id,attr,omitempty"`
	ListingtypeAttr string   `xml:"listing-type,attr"`
}

// PreType ...
type PreType struct {
	XMLName        xml.Name `xml:"pre"`
	ExchPreAttlist *PreAttlist
	Value          string `xml:",chardata"`
}

// Pre is *******************************
//
//	PRE
//	*******************************
//	- This element is one method to identify content consisting of text objects that
//	require preservation (pre) of their whitespace in order to preserve internal
//	logical relationships.
//	(e.g., sequence listing fragments, computer program listings)
//	- Not at present used by the EPO; to be discussed ?**
type Pre *PreType

// BrType ...
type BrType struct {
	XMLName xml.Name `xml:"br"`
}

// Br is br - break, line break within a paragraph, etc
type Br *BrType

// BType ...
type BType struct {
	XMLName   xml.Name         `xml:"b"`
	I         []*IType         `xml:"i"`
	U         []*UType         `xml:"u"`
	O         []*OType         `xml:"o"`
	Sup       []*SupType       `xml:"sup"`
	Sub       []*SubType       `xml:"sub"`
	Smallcaps []*SmallcapsType `xml:"smallcaps"`
}

// B is *********************************
//   - FORMATTING TAGS WITHIN <p>
//     *********************************
//     Bold formatting for text
type B *BType

// IType ...
type IType struct {
	XMLName   xml.Name         `xml:"i"`
	B         []*BType         `xml:"b"`
	U         []*UType         `xml:"u"`
	O         []*OType         `xml:"o"`
	Sup       []*SupType       `xml:"sup"`
	Sub       []*SubType       `xml:"sub"`
	Smallcaps []*SmallcapsType `xml:"smallcaps"`
}

// I is Italic formatting for text
type I *IType

// SmallcapsType ...
type SmallcapsType struct {
	XMLName xml.Name `xml:"smallcaps"`
	B       []*BType `xml:"b"`
	U       []*UType `xml:"u"`
	I       []*IType `xml:"i"`
	O       []*OType `xml:"o"`
}

// Smallcaps is Small capitals
type Smallcaps *SmallcapsType

// SupType ...
type SupType struct {
	XMLName xml.Name    `xml:"sup"`
	B       []*BType    `xml:"b"`
	U       []*UType    `xml:"u"`
	I       []*IType    `xml:"i"`
	O       []*OType    `xml:"o"`
	Sup2    []*Sup2Type `xml:"sup2"`
	Sub2    []*Sub2Type `xml:"sub2"`
}

// Sup is Superscripted text
type Sup *SupType

// SubType ...
type SubType struct {
	XMLName xml.Name    `xml:"sub"`
	B       []*BType    `xml:"b"`
	U       []*UType    `xml:"u"`
	I       []*IType    `xml:"i"`
	O       []*OType    `xml:"o"`
	Sup2    []*Sup2Type `xml:"sup2"`
	Sub2    []*Sub2Type `xml:"sub2"`
}

// Sub is Subscripted text
type Sub *SubType

// Sub2Type ...
type Sub2Type struct {
	XMLName xml.Name `xml:"sub2"`
	B       []*BType `xml:"b"`
	U       []*UType `xml:"u"`
	I       []*IType `xml:"i"`
	O       []*OType `xml:"o"`
}

// Sub2 is Subscripted text 2nd level
type Sub2 *Sub2Type

// Sup2Type ...
type Sup2Type struct {
	XMLName xml.Name `xml:"sup2"`
	B       []*BType `xml:"b"`
	U       []*UType `xml:"u"`
	I       []*IType `xml:"i"`
	O       []*OType `xml:"o"`
}

// Sup2 is Superscripted text 2nd level
type Sup2 *Sup2Type

// Exchangedocuments ...
type Exchangedocuments struct {
	XMLName               xml.Name `xml:"exchange-documents"`
	CountryAttr           string   `xml:"country,attr,omitempty"`
	DateproducedAttr      *IntType `xml:"date-produced,attr,omitempty"`
	DateofexchangeAttr    *IntType `xml:"date-of-exchange,attr,omitempty"`
	DtdversionAttr        string   `xml:"dtd-version,attr,omitempty"`
	FileAttr              string   `xml:"file,attr,omitempty"`
	NoofdocumentsAttr     *IntType `xml:"no-of-documents,attr,omitempty"`
	OriginatingofficeAttr string   `xml:"originating-office,attr,omitempty"`
	StatusAttr            string   `xml:"status,attr,omitempty"`
	ExchExchangedocument  []string `xml:"exchange-document"`
}
